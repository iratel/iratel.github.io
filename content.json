{"meta":{"title":"许进沉思录-专注于互联网与中间件基础架构技术研究","subtitle":"Halo💫","description":"Spring Cloud中国社区创始人，入职于阿里,曾入职于唯品会中间件,业余主要研究Spring Cloud。《重新定义Spring Cloud实战》作者","author":"Halo💫","url":"http://xujin.org"},"pages":[{"title":"404 Page Not Found","date":"2017-08-04T15:36:59.000Z","updated":"2019-01-09T15:56:50.499Z","comments":true,"path":"404.html","permalink":"http://xujin.org/404.html","excerpt":"","text":""},{"title":"about","date":"2017-07-28T16:50:51.000Z","updated":"2019-01-10T14:34:17.803Z","comments":true,"path":"about/index.html","permalink":"http://xujin.org/about/index.html","excerpt":"","text":"一.自我介绍 籍贯云南，现居上海。入职于阿里，花名玹霖。软件工程专业，专注于基础架构和各种中间件设计与研发。Spring Cloud中国社区创始人，《重新定义Spring Cloud实战》作者之一。 当当购买地址:http://product.dangdang.com/25348282.html京东购买地址:https://item.jd.com/12447280.html 曾就职于饿了么。 曾就职于唯品会平台架构部，参与唯品会中间件(服务网关,应用框架，代码生成器等)相关的研发工作。 曾参与唯品会互联网金融平台的设计与开发(https://jinrong.vip.com/)， 曾参与基于云计算Iaas的平安科技云平台(www.pinganyun.com)和国泰君安证卷云平台的开发， 曾参与基于云计算Saas平台的云销售管理系统的开发等。开发的私有云产品应用于太平人寿，东亚银行，天翼视讯，上海证券交易所,国泰君安等。 熟练运用各种流行的JavaEE技术进行组合式架构设计与开发。业余时间研究并发编程，中间件，异地多活，Spring Cloud，ZStack(zstack.org.cn)，Mycat等开源项目，以及软件架构设计，程序性能优化，JVM，高并发等！ 二.分享经历 Spring Cloud Zuul与网关中间件 Spring Cloud与中间件及国内使用情况 Spring Cloud 与微服务网关 Spring Cloud与领域驱动架构治理实战 三.联系方式 E-mail: Software_King@qq.com Github: Software_King 网站: http://xujin.org 网络ID:Software_King 微信:Software_King Spring Cloud中国社区:http://springcloud.cn 座右铭:软件世界就是模拟客观世界，从而需求分析，技术驱动，改造世界！"},{"title":"Categories","date":"2018-01-04T16:00:00.000Z","updated":"2019-01-09T15:56:50.511Z","comments":true,"path":"categories/index.html","permalink":"http://xujin.org/categories/index.html","excerpt":"","text":"title: Androiddate: 2018-01-05 00:00:00 type: “categories” title: Hexodate: 2018-01-05 00:00:00 type: “categories”"},{"title":"search","date":"2018-04-01T09:52:02.000Z","updated":"2019-01-09T15:56:50.511Z","comments":true,"path":"search/index.html","permalink":"http://xujin.org/search/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-03-31T16:00:00.000Z","updated":"2019-01-09T15:56:50.512Z","comments":true,"path":"tags/index.html","permalink":"http://xujin.org/tags/index.html","excerpt":"","text":""},{"title":"Android","date":"2018-01-04T16:00:00.000Z","updated":"2019-01-09T15:56:50.510Z","comments":true,"path":"categories/Android/index.html","permalink":"http://xujin.org/categories/Android/index.html","excerpt":"","text":""},{"title":"Hexo","date":"2018-01-04T16:00:00.000Z","updated":"2019-01-09T15:56:50.511Z","comments":true,"path":"categories/Hexo/index.html","permalink":"http://xujin.org/categories/Hexo/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Cloud第二代","slug":"sc/sc2","date":"2018-11-27T06:00:00.000Z","updated":"2019-01-12T04:21:40.872Z","comments":true,"path":"sc/sc2/","link":"","permalink":"http://xujin.org/sc/sc2/","excerpt":"摘要: 随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring Cloud生态圈中的第二代组件的组合，仅代表个人看法。 1. Spring Cloud第一代 Spring Cloud自从推出之后，给大家的感觉就是Spring Cloud做它最擅长的事，也就是高度抽象和封装，强强联手整合最优东西为我所用，比如Netflix开源的Eureka，Hystrix，Ribbon等。而且提供多种技术选型，态度中立而选最优。8天前也就是2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态。引发朋友圈的一些思考。","text":"摘要: 随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring Cloud生态圈中的第二代组件的组合，仅代表个人看法。 1. Spring Cloud第一代 Spring Cloud自从推出之后，给大家的感觉就是Spring Cloud做它最擅长的事，也就是高度抽象和封装，强强联手整合最优东西为我所用，比如Netflix开源的Eureka，Hystrix，Ribbon等。而且提供多种技术选型，态度中立而选最优。8天前也就是2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态。引发朋友圈的一些思考。 虽然Eureka，Hystrix等不再继续开发或维护，但是目前来说不影响使用，不管怎么说感谢开源，向Netflix公司的开源致敬。 随着Spring Cloud生态圈的发展与成长，Spring Cloud陆续推出了自己的一些组件，挑选主要组件说明如下表所示: 组件 来源 说明 Spring-cloud-openfeign 基于Feign的升级 服务之间调用的必备组件 spring-cloud-zuul 来源于Netflix Zuul 目前还在继续维护，但是已经有自己的Spring Cloud Gateway,不久将来逐渐淘汰 spring-cloud-eureka 集成于Netflix Eureka 目前还在跟随Spring Cloud版本升级维护，最终也会被替代 spring-cloud-config 自研 功能不足，国内使用其它配置中心替代，比如携程的Apollo 全链路监控(sleuth+zikpin或pinpont) sleuth自研，其它第三方 国内目前使用最多的是skywaling等上生产 spring-cloud-ribbon 来源于Netflix集成 ribbon目前还在跟随Spring Cloud版本维护中，目前孵化未来替代品spring-cloud-lb Spring-cloud-hystrix 来源于Netflix集成 目前还在跟随Spring Cloud版本维护中目前已经孵化spring-cloud-r4j 2. Spring Cloud 第二代 Spring Cloud第一代和第二代的组件组合汇总，如下表所示。 Spring Cloud第一代 Spring Cloud第二代 网关 Spring Cloud Zuul Spring Cloud Gateway 注册中心 eureka(不再更新)，Consul,ZK 阿里Nacos，拍拍贷radar等可选 配置中心 spring cloud config 阿里Nacos，携程Apollo，随行付Config Keeper 客户端软负载均衡 Ribbon spring-cloud-loadbalancer 熔断器 Hystrix spring-cloud-r4j(Resilience4J)，阿里Sentinel 由于Zuul性能一般，zuul 2.x(一直跳票，虽最终开源）但是Spring Cloud官方已经推出Spring Cloud gateway,Spring Cloud中国社区很久之前已经证实，Spring Cloud将不会集成zuul 2.x，也就是说在不就未来Zuul将从Spring Cloud生态圈中退出。 ribbon由于不支持webFlux的负载均衡，Spring Cloud官方很早就在孵化器项目中孵化spring-cloud-loadbalancer，目前已经将代码合并到spring-cloud-common中，预计在Spring Cloud G版可以使用，预计2018年12月底realese。 至于Hystrix，Netflix在2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态，其实在之前Spring Cloud官方就在孵化spring-cloud-r4j. 3.开源项目的链接本文所提到的开源项目链接汇总如下所示： https://github.com/alibaba/Sentinel https://github.com/spring-cloud-incubator/spring-cloud-r4j 阿里Nacos-https://github.com/alibaba/nacos 随行付Config-keeper-https://github.com/sxfad/config-keeper spring-cloud-loadbalancer https://github.com/ctripcorp/apollo https://github.com/apache/incubator-skywalking","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://xujin.org/categories/Spring-Cloud/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://xujin.org/tags/Spring-Cloud/"}]},{"title":"使用Nacos实现Spring Cloud Gateway的动态路由","slug":"sc/gw/gw10","date":"2018-11-17T06:00:00.000Z","updated":"2019-01-12T03:33:48.579Z","comments":true,"path":"sc/gw/gw10/","link":"","permalink":"http://xujin.org/sc/gw/gw10/","excerpt":"摘要:本文主要介绍通过Nacos下发路由配置实现Spring Cloud Gateway的动态路由。 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。本文是基于Spring Cloud Gateway的动态路由实现基础之上编写，通过Nacos配置服务下发路由配置实现动态路由。","text":"摘要:本文主要介绍通过Nacos下发路由配置实现Spring Cloud Gateway的动态路由。 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。本文是基于Spring Cloud Gateway的动态路由实现基础之上编写，通过Nacos配置服务下发路由配置实现动态路由。 2. Spring Cloud Gateway简单的动态路由实现Spring Cloud Gateway的官方文档并没有讲如何动态配置，查看 Spring Cloud Gateway的源码，发现在org.springframework.cloud.gateway.actuate.GatewayControllerEndpoint类中提供了动态配置的Rest接口，但是需要开启Gateway的端点，而且提供的功能不是很强大。通过参考和GatewayControllerEndpoint相关的代码，可以自己编码实际动态路由配置。下面通过案例的方式去讲解怎么通Nacos实现Spring Cloud Gateway的动态路由。案例工程如spring-cloud-gateway-nacos所示。 代码地址:https://github.com/SpringCloud/spring-cloud-gateway-nacos 3. 简单动态路由的实现3.1 新建Maven工程sc-gateway-server 配置主要的核心依赖如代码清单所示： 代码清单: spring-cloud-gateway-nacos/sc-gateway-server/pom.xml123456789101112131415161718192021222324252627&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;version&gt;0.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 3.2 根据Spring Cloud Gateway的路由模型定义数据传输模型 分别创建GatewayRouteDefinition.java, GatewayPredicateDefinition.java, GatewayFilterDefinition.java这三个类。(1) 创建路由定义模型 12345678910111213public class GatewayRouteDefinition &#123; //路由的Id private String id; //路由断言集合配置 private List&lt;GatewayPredicateDefinition&gt; predicates = new ArrayList&lt;&gt;(); //路由过滤器集合配置 private List&lt;GatewayFilterDefinition&gt; filters = new ArrayList&lt;&gt;(); //路由规则转发的目标uri private String uri; //路由执行的顺序 private int order = 0; //此处省略get和set方法&#125; (2)创建过滤器定义模型 1234567public class GatewayFilterDefinition &#123; //Filter Name private String name; //对应的路由规则 private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;(); //此处省略Get和Set方法&#125; (3)创建路由断言定义模型 1234567public class GatewayPredicateDefinition &#123; //断言对应的Name private String name; //配置的断言规则 private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;(); //此处省略Get和Set方法&#125; 3.3 编写动态路由实现类编写DynamicRouteServiceImpl并实现ApplicationEventPublisherAware接口，代码如下所示 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class DynamicRouteServiceImpl implements ApplicationEventPublisherAware &#123; @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher publisher; //增加路由 public String add(RouteDefinition definition) &#123; routeDefinitionWriter.save(Mono.just(definition)).subscribe(); this.publisher.publishEvent(new RefreshRoutesEvent(this)); return \"success\"; &#125; //更新路由 public String update(RouteDefinition definition) &#123; try &#123; this.routeDefinitionWriter.delete(Mono.just(definition.getId())); &#125; catch (Exception e) &#123; return \"update fail,not find route routeId: \"+definition.getId(); &#125; try &#123; routeDefinitionWriter.save(Mono.just(definition)).subscribe(); this.publisher.publishEvent(new RefreshRoutesEvent(this)); return \"success\"; &#125; catch (Exception e) &#123; return \"update route fail\"; &#125; &#125; //删除路由 public Mono&lt;ResponseEntity&lt;Object&gt;&gt; delete(String id) &#123; return this.routeDefinitionWriter.delete(Mono.just(id)) .then(Mono.defer(() -&gt; Mono.just(ResponseEntity.ok().build()))) .onErrorResume(t -&gt; t instanceof NotFoundException, t -&gt; Mono.just(ResponseEntity.notFound().build())); &#125; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.publisher = applicationEventPublisher; &#125;&#125; 3.4 编写Nacos监听接收下发的路由配置3.4.1 使用Nacos监听下发的配置监听Nacos Config Server下发配置的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class DynamicRouteServiceImplByNacos &#123; @Autowired private DynamicRouteServiceImpl dynamicRouteService; public DynamicRouteServiceImplByNacos() &#123; dynamicRouteByNacosListener(\"sc-gateway\",\"xujin_test\"); &#125; /** * 监听Nacos Server下发的动态路由配置 * @param dataId * @param group */ public void dynamicRouteByNacosListener (String dataId, String group)&#123; try &#123; ConfigService configService=NacosFactory.createConfigService(\"127.0.0.1:8848\"); String content = configService.getConfig(dataId, group, 5000); System.out.println(content); configService.addListener(dataId, group, new Listener() &#123; @Override public void receiveConfigInfo(String configInfo) &#123; RouteDefinition definition= JSON.parseObject(configInfo,RouteDefinition.class); dynamicRouteService.update(definition); &#125; @Override public Executor getExecutor() &#123; return null; &#125; &#125;); &#125; catch (NacosException e) &#123; //todo 提醒:异常自行处理此处省略 &#125; &#125;&#125; 3.4.2 两种方式创建ConfigService使用两种方式创建com.alibaba.nacos.api.config.ConfigService 1.构建Properties创建 使用createConfigService(Properties properties)，代码如下所示:1234Properties properties = new Properties(); properties.put(\"nacos.server-addr\", \"\"); properties.put(PropertyKeyConst.SERVER_ADDR, \"127.0.0.1:8848\"); ConfigService configService=NacosFactory.createConfigService(properties); 注意:PropertyKeyConst是com.alibaba.nacos.api.PropertyKeyConst 2.只传递Nacos Config Server的地址 1ConfigService configService=NacosFactory.createConfigService(\"127.0.0.1:8848\"); 4. 使用Nacos下发配置4.1 Nacos概述 Naocs由阿里开源，Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。github地址:https://github.com/alibaba/nacos 更多Nacos的介绍，请访问官方网站:https://nacos.io/ 4.2 在IDE中启动 Nacos访问https://github.com/alibaba/nacos ,使用Git克隆Nacos代码，直接导入到IDEA中，如下所示设置启动参数，直接启动。 从IDE中启动Nacos是我比较推荐的方式，因为可以随时Debug Nacos任何代码，其它启动方式请参考官网。 5.测试5.1 Nacos中下发Spring Cloud Gateway的路由配置 1.打开浏览器访问URL:http://localhost:8848/nacos/index.html ,Nacos的管控平台如下所示: 2.在Nacos的配置列表点击+按钮，下发Spring Cloud Gateway的路由配置，如下所示: 用于测试的示例数据，如下所示: 123456789101112&#123; \"filters\": [], \"id\": \"jd_route\", \"order\": 0, \"predicates\": [&#123; \"args\": &#123; \"pattern\": \"/jd\" &#125;, \"name\": \"Path\" &#125;], \"uri\": \"http://www.jd.com\"&#125; 5.2 启动sc-gateway-server 1.Debug启动sc-gateway-server,调试截图如下所示: 2.通过Spring Cloud gateway的端点，查看路由信息 3.通过访问http://localhost:8080/jd ,可以转发到京东商城主页 5.3 更新路由配置 1.通过Nacos下发配置，修改Spring Cloud Gateway的动态路由规则 2.查看访问Spring Cloud gateway的端点配置，可以看到动态路由修改如下: 3.通过访问http://localhost:8080/jd ,可以转发到百度相关页面","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"Spring Cloud Gateway的动态路由实现","slug":"sc/gw/gw09","date":"2018-11-03T06:00:00.000Z","updated":"2019-01-12T03:33:39.419Z","comments":true,"path":"sc/gw/gw09/","link":"","permalink":"http://xujin.org/sc/gw/gw09/","excerpt":"摘要:本文主要介绍了Spring Cloud Gateway的动态路由的简单实现方式。 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。本篇文章简单介绍如何实现Spring Cloud Gateway的动态路由。","text":"摘要:本文主要介绍了Spring Cloud Gateway的动态路由的简单实现方式。 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。本篇文章简单介绍如何实现Spring Cloud Gateway的动态路由。 2. Spring Cloud Gateway简单的动态路由实现Spring Cloud Gateway的官方文档并没有讲如何动态配置，查看 Spring Cloud Gateway的源码，发现在org.springframework.cloud.gateway.actuate.GatewayControllerEndpoint类中提供了动态配置的Rest接口，但是需要开启Gateway的端点，而且提供的功能不是很强大。通过参考和GatewayControllerEndpoint相关的代码，可以自己编码实际动态路由配置。下面通过案例的方式去讲解怎么实现Gateway的动态路由配置。案例工程如ch18-7-gateway所示。 代码地址:https://github.com/SpringCloud/spring-cloud-code/blob/master/ch18-7/ch18-7-gateway 3. 简单动态路由的实现3.1 新建Maven工程ch18-7-gateway 配置主要的核心依赖如代码清单18-33所示： 代码清单: ch18-7/ch18-7-gateway/pom.xml1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2 根据Spring Cloud Gateway的路由模型定义数据传输模型 分别创建GatewayRouteDefinition.java, GatewayPredicateDefinition.java, GatewayFilterDefinition.java这三个类。(1) 创建路由定义模型如下代码清单18-34所示：代码清单 18-34: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayRouteDefinition.java 12345678910111213public class GatewayRouteDefinition &#123; //路由的Id private String id; //路由断言集合配置 private List&lt;GatewayPredicateDefinition&gt; predicates = new ArrayList&lt;&gt;(); //路由过滤器集合配置 private List&lt;GatewayFilterDefinition&gt; filters = new ArrayList&lt;&gt;(); //路由规则转发的目标uri private String uri; //路由执行的顺序 private int order = 0; //此处省略get和set方法&#125; (2)创建过滤器定义模型,代码如代码清单18-35所示：代码清单18-35: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayFilterDefinition.java 1234567public class GatewayFilterDefinition &#123; //Filter Name private String name; //对应的路由规则 private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;(); //此处省略Get和Set方法&#125; (3)路由断言定义模型，代码如代码清单18-36所示:代码清单18-36: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayPredicateDefinition.java 1234567public class GatewayPredicateDefinition &#123; //断言对应的Name private String name; //配置的断言规则 private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;(); //此处省略Get和Set方法&#125; 3.3 编写动态路由实现类编写DynamicRouteServiceImpl并实现ApplicationEventPublisherAware接口，代码如代码清单18-37所示: ch18-37/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/route/DynamicRouteServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class DynamicRouteServiceImpl implements ApplicationEventPublisherAware &#123; @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher publisher; //增加路由 public String add(RouteDefinition definition) &#123; routeDefinitionWriter.save(Mono.just(definition)).subscribe(); this.publisher.publishEvent(new RefreshRoutesEvent(this)); return \"success\"; &#125; //更新路由 public String update(RouteDefinition definition) &#123; try &#123; this.routeDefinitionWriter.delete(Mono.just(definition.getId())); &#125; catch (Exception e) &#123; return \"update fail,not find route routeId: \"+definition.getId(); &#125; try &#123; routeDefinitionWriter.save(Mono.just(definition)).subscribe(); this.publisher.publishEvent(new RefreshRoutesEvent(this)); return \"success\"; &#125; catch (Exception e) &#123; return \"update route fail\"; &#125; &#125; //删除路由 public Mono&lt;ResponseEntity&lt;Object&gt;&gt; delete(String id) &#123; return this.routeDefinitionWriter.delete(Mono.just(id)) .then(Mono.defer(() -&gt; Mono.just(ResponseEntity.ok().build()))) .onErrorResume(t -&gt; t instanceof NotFoundException, t -&gt; Mono.just(ResponseEntity.notFound().build())); &#125; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.publisher = applicationEventPublisher; &#125;&#125; 3.4 编写Rest接口编写RouteController类的提供Rest接口，用于动态路由配置。代码如代码清单18-38所示:代码清单 18-38: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/controller/RouteController.java 1234567891011121314151617181920212223242526272829@RestController@RequestMapping(\"/route\")public class RouteController &#123; @Autowired private DynamicRouteServiceImpl dynamicRouteService; //增加路由 @PostMapping(\"/add\") public String add(@RequestBody GatewayRouteDefinition gwdefinition) &#123; try &#123; RouteDefinition definition = assembleRouteDefinition(gwdefinition); return this.dynamicRouteService.add(definition); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"succss\"; &#125; //删除路由 @DeleteMapping(\"/routes/&#123;id&#125;\") public Mono&lt;ResponseEntity&lt;Object&gt;&gt; delete(@PathVariable String id) &#123; return this.dynamicRouteService.delete(id); &#125; //更新路由 @PostMapping(\"/update\") public String update(@RequestBody GatewayRouteDefinition gwdefinition) &#123; RouteDefinition definition = assembleRouteDefinition(gwdefinition); return this.dynamicRouteService.update(definition); &#125;&#125; 3.5 配置application.yml文件在application.yml文件配置应用的配置信息，并开启Spring Cloud Gateway对外提供的端点Rest接口。代码如代码清单18-39所示:代码清单 18-39: ch18-7/ch18-7-gateway/src/main/resources/application.yml配置输出日志如下所示:123456789101112131415# 配置输出日志logging: level: org.springframework.cloud.gateway: TRACE org.springframework.http.server.reactive: DEBUG org.springframework.web.reactive: DEBUG reactor.ipc.netty: DEBUG#开启端点management: endpoints: web: exposure: include: '*' security: enabled: false 3.6 启动ch18-7-gateway应用测试(1) 启动ch18-7-gateway应用之后，由于开启了端点，首先打开浏览器访问端点URL:http://localhost:8080/actuator/gateway/routes ,查看路由信息返回为空，如下图所示: (2)打开PostMan，访问http://localhost:8080/route/add, 发起Post请求，如下图所示,返回success说明向Gateway增加路由配置成功。 然后再打开PostMan访问端点URL:http://localhost:8080/actuator/gateway/routes , 查看路由信息返回如下图所示，可以看到已经添加的路由配置。 (3) 打开浏览器访问http://localhost:8080/jd, 可以正常转发https://www.jd.com/对应的京东商城首页。(4) 通过访问http://localhost:8080/route/update, 对id为jd_route的路由更新配置，如下图所示： 然后再访问路由端点URL,发现路由配置已经被更新，如下图所示: 然后通过浏览器访问http://localhost:8080/taobao ,可以成功转发到淘宝网。(5) 通过访问http: //localhost:8080/route/delete/jd_route,其中的id为路由对应的id，删除路由结果如下图所示: 4.Spring Cloud Gateway推荐文章Spring Cloud Gateway中的权重路由Spring Cloud Gateway中的GatewayFilter和GlobalFilterSpring Cloud Gateway只有Pre和POST两种类型的FilterSpring Cloud Gateway基于服务发现的默认路由规则Spring Cloud Gateway的Before路由断言工厂Spring Cloud Gateway的After路由断言工厂Spring Cloud Gateway揭秘之处理请求流程Spring Cloud Gateway入门案例 5.《重新定义Spring Cloud实战》中的Spring Cloud Gateway第17章Spring Cloud Gateway上篇39917.1 Spring Cloud Gateway概述39917.1.1 什么是Spring Cloud Gateway39917.1.2 Spring Cloud Gateway的核心概念39917.2 Spring Cloud Gateway的工作原理40017.3 Spring Cloud Gateway入门案例40117.4 Spring Cloud Gateway的路由断言40417.4.1 After路由断言工厂40417.4.2 Before路由断言工厂40617.4.3 Between路由断言工厂40617.4.4 Cookie路由断言工厂40717.4.5 Header路由断言工厂40817.4.6 Host路由断言工厂41017.4.7 Method路由断言工厂41117.4.8 Query路由断言工厂41117.4.9 RemoteAddr路由断言工厂41217.5 Spring Cloud Gateway的内置Filter41317.5.1 AddRequestHeader过滤器工厂41317.5.2 AddRequestParameter过滤器41317.5.3 RewritePath过滤器41417.5.4 AddResponseHeader过滤器41517.5.5 StripPrefix过滤器41617.5.6 Retry过滤器41717.5.7 Hystrix过滤器41817.6 本章小结420第18章 Spring Cloud Gateway下篇42118.1 Gateway基于服务发现的路由规则42118.1.1 Gateway的服务发现路由概述42118.1.2 服务发现的路由规则案例42218.2 Gateway Filter和Global Filter42518.2.1 Gateway Filter和Global Filter概述42518.2.2 自定义Gateway Filter案例42518.2.3 自定义Global Filter案例42718.3 Spring Cloud Gateway实战42818.3.1 Spring Cloud Gateway权重路由42818.3.2 Spring Cloud Gateway中Https的使用技巧43118.3.3 Spring Cloud Gateway集成Swagger43618.3.4 Spring Cloud Gateway限流44218.3.5 Spring Cloud Gateway的动态路由45018.4 Spring Cloud Gateway源码篇45818.4.1 Spring Cloud Gateway的处理流程45818.4.2 Gateway中ServerWebExchange构建分析45918.4.3 DispatcherHandler源码分析46018.4.4 RoutePredicateHandlerMapping源码分析46118.4.5 FilteringWebHandler源码分析46218.4.6 执行Filter源码分析46318.5 本章小结465 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273├── ch17-1│ ├── ch17-1-1-gateway│ ├── ch17-1-2-gateway│ ├── ch17-1.iml│ └── pom.xml├── ch17-2│ ├── ch17-2-1-gateway│ ├── ch17-2-2-gateway│ ├── ch17-2-3-gateway│ ├── ch17-2-4-gateway│ ├── ch17-2-5-gateway│ ├── ch17-2-6-gateway│ ├── ch17-2-7-gateway│ ├── ch17-2-8-gateway│ ├── ch17-2-9-gateway│ ├── ch17-2-service│ ├── ch17-2.iml│ └── pom.xml├── ch17-3│ ├── ch17-3-1-gateway│ ├── ch17-3-2-gateway│ ├── ch17-3-3-gateway│ ├── ch17-3-4-gateway│ ├── ch17-3-5-gateway│ ├── ch17-3-6-gateway│ ├── ch17-3-7-gateway│ ├── ch17-3-service│ ├── ch17-3.iml│ └── pom.xml├── ch18-1│ ├── ch18-1-consumer│ ├── ch18-1-eureka│ ├── ch18-1-gateway│ ├── ch18-1-provider│ ├── ch18-1.iml│ └── pom.xml├── ch18-2│ ├── ch18-2-gateway│ ├── ch18-2-provider│ ├── ch18-2.iml│ ├── pom.xml│ └── reademe.txt├── ch18-3│ ├── ch18-3-gateway│ ├── ch18-3-provider│ ├── ch18-3.iml│ └── pom.xml├── ch18-4│ ├── ch18-4-eureka│ ├── ch18-4-gateway-https│ ├── ch18-4-service-a│ ├── ch18-4-service-b│ ├── ch18-4.iml│ ├── pom.xml│ └── reademe.md├── ch18-5│ ├── ch18-5-eureka│ ├── ch18-5-gateway│ ├── ch18-5-service│ ├── ch18-5.iml│ └── pom.xml├── ch18-6│ ├── ch18-6-1-gateway│ ├── ch18-6-2-gateway│ ├── ch18-6-3-gateway│ ├── ch18-6-provider│ ├── ch18-6.iml│ └── pom.xml├── ch18-7│ ├── ch18-7-gateway│ ├── ch18-7.iml│ ├── pom.xml│ └── readme.md Spring Cloud Gateway所有示例代码地址:https://github.com/SpringCloud/spring-cloud-code","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"Spring Cloud Gateway中的权重路由","slug":"sc/gw/gw08","date":"2018-06-09T06:00:00.000Z","updated":"2019-01-12T03:31:12.149Z","comments":true,"path":"sc/gw/gw08/","link":"","permalink":"http://xujin.org/sc/gw/gw08/","excerpt":"摘要:本文主要通过运用Spring Cloud Gateway的WeightRoutePredicateFactory对URL进行权重路由。","text":"摘要:本文主要通过运用Spring Cloud Gateway的WeightRoutePredicateFactory对URL进行权重路由。 1.权重路由1.1 权重路由使用场景在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服务有两个版本，旧版本V1，新版本v2。在线上灰度的时候，需要通过网关动态实时推送，路由权重信息。比如95%的流量走服务v1版本，5%的流量走服务v2版本。 issue: The Spring Cloud Gateway issue of Allow Rolling Deployments https://github.com/spring-cloud/spring-cloud-gateway/issues/67 1.2 Spring Cloud Gateway权重路由原理Spring Cloud Gateway中提供了org.springframework.cloud.gateway.handler.predicate.WeightRoutePredicateFactory去实现根据分组设置权重进行路由，因此使用起来相对比较简单，有兴趣的可以debug阅读源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class WeightRoutePredicateFactory extends AbstractRoutePredicateFactory&lt;WeightConfig&gt; implements ApplicationEventPublisherAware &#123; private static final Log log = LogFactory.getLog(WeightRoutePredicateFactory.class); public static final String GROUP_KEY = WeightConfig.CONFIG_PREFIX + \".group\"; public static final String WEIGHT_KEY = WeightConfig.CONFIG_PREFIX + \".weight\"; private ApplicationEventPublisher publisher; public WeightRoutePredicateFactory() &#123; super(WeightConfig.class); &#125; @Override public void setApplicationEventPublisher(ApplicationEventPublisher publisher) &#123; this.publisher = publisher; &#125; @Override public List&lt;String&gt; shortcutFieldOrder() &#123; return Arrays.asList(GROUP_KEY, WEIGHT_KEY); &#125; @Override public String shortcutFieldPrefix() &#123; return WeightConfig.CONFIG_PREFIX; &#125; @Override public void beforeApply(WeightConfig config) &#123; if (publisher != null) &#123; publisher.publishEvent(new WeightDefinedEvent(this, config)); &#125; &#125; @Override public Predicate&lt;ServerWebExchange&gt; apply(WeightConfig config) &#123; return exchange -&gt; &#123; Map&lt;String, String&gt; weights = exchange.getAttributeOrDefault(WEIGHT_ATTR, Collections.emptyMap()); String routeId = exchange.getAttribute(GATEWAY_PREDICATE_ROUTE_ATTR); // all calculations and comparison against random num happened in // WeightCalculatorWebFilter String group = config.getGroup(); if (weights.containsKey(group)) &#123; String chosenRoute = weights.get(group); if (log.isTraceEnabled()) &#123; log.trace(\"in group weight: \"+ group + \", current route: \" + routeId +\", chosen route: \" + chosenRoute); &#125; return routeId.equals(chosenRoute); &#125; return false; &#125;; &#125;&#125; 2.Spring Cloud Gateway中的权重路由案例2.1 案例代码地址https://github.com/SoftwareKing/sc-gateway/tree/master/ch4 2.2 Spring Cloud Gateway Server说明Spring Cloud Gateway will dispatch 95% of the requests to version 1 and 5% of the traffic to version 2 of a specified service, as shown by the following figure. 我们通过在Spring Cloud Gateway中会配置不同的权重信息到不同URL上，Spring Cloud Gateway会根据我们配置的路由权重信息，将请求分发到不同的源服务组，权重信息如ch4/ch4-gateway中的application.yml所示，主要配置信息如下。 123456789101112131415161718spring: application: name: ch4-gateway cloud: gateway: routes: - id: service1_v1 uri: http://localhost:8081/v1 predicates: - Path=/test - Weight=service1, 95 - id: service1_v2 uri: http://localhost:8081/v2 predicates: - Path=/test - Weight=service1, 5 Weight=service1, 95，Weight=service1, 5就是路由的权重信息。 2.3 源服务源服务在本案例中源服务如ch4-service-provider所示，主要提提供Gateway Server权重路由对应的后端源服务。因为比较简单因此不做详细说明，主要代码如下所示。 1234567891011121314151617181920package org.xujin.sc.service;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import reactor.core.publisher.Mono;@RestControllerpublic class ServiceController &#123; @RequestMapping(value = \"/v1\", produces = \"text/plain;charset=UTF-8\") public Mono&lt;String&gt; v1() &#123; return Mono.just(\"v1\"); &#125; @RequestMapping(value = \"/v2\", produces = \"text/plain;charset=UTF-8\") public Mono&lt;String&gt; v2() &#123; return Mono.just(\"v2\"); &#125;&#125; 2.4 测试分别启动ch4-gateway，ch4-service-provider进行访问:http://localhost:8080/test 测试,发现会根据所设权重进行路由。","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"Spring Cloud Gateway中的GatewayFilter和GlobalFilter","slug":"sc/gw/gw07","date":"2018-05-26T06:00:00.000Z","updated":"2019-01-12T03:30:42.775Z","comments":true,"path":"sc/gw/gw07/","link":"","permalink":"http://xujin.org/sc/gw/gw07/","excerpt":"摘要:本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中自定义使用GatewayFilter和GlobalFilter。","text":"摘要:本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中自定义使用GatewayFilter和GlobalFilter。 1. Spring Cloud gateway的FilterSpring Cloud gateway中的Filter从接口实现上分为两种一种是GatewayFilter，另外一种是GlobalFilter。 1.1 GatewayFilter与GlobalFilter的区别区别用英语可以总结如下:At a high level global filters are applied to all routes, while a gateway filter will be applied to an individual route(s) 在一个高的角度来看，Global filters会被应用到所有的路由上，而Gateway filter将应用到单个路由上或者一个分组的路由上。在下面的案例中将会进行说明。 1.2 本文代码地址 https://github.com/SoftwareKing/sc-gateway/tree/master/ch2 2. GatewayFilter和GlobalFilter2.1 GatewayFilter2.1.1 什么是GatewayFilterContract for interception-style, chained processing of Web requests that may be used to implement cross-cutting, application-agnostic requirements such as security, timeouts, and others. Specific to a Gateway Copied from WebFilter GatewayFilter是从WebFilter中Copy过来的，相当于一个Filter过滤器，可以对访问的URL过滤横切处理，应用场景比如超时，安全等。 从Spring Cloud Gateway的源码中如下所示，可以看出GatewayFilter的使用场景: 12345678910111213141516171819202122232425/** * Contract for interception-style, chained processing of Web requests that may * be used to implement cross-cutting, application-agnostic requirements such * as security, timeouts, and others. Specific to a Gateway * * Copied from WebFilter * * @author Rossen Stoyanchev * @since 5.0 */public interface GatewayFilter extends ShortcutConfigurable &#123; String NAME_KEY = \"name\"; String VALUE_KEY = \"value\"; /** * Process the Web request and (optionally) delegate to the next * &#123;@code WebFilter&#125; through the given &#123;@link GatewayFilterChain&#125;. * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return &#123;@code Mono&lt;Void&gt;&#125; to indicate when request processing is complete */ Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125; GatewayFilter和GlobalFilter两个接口中定义的方法一样都是Mono filter(ServerWebExchange exchange, GatewayFilterChain chain)，唯一的区别就是GatewayFilter继承了ShortcutConfigurable，GlobalFilter没有任何继承。 2.1.2 自定义GatewayFilter(Custom GatewayFilter)如org.xujin.sc.filter.CustomFilter代码所示，通过自定义GatewayFilter对路由转发的处理时长统计。 1234567891011121314151617181920212223242526272829303132333435363738package org.xujin.sc.filter;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.core.Ordered;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;/** * 统计某个或者某种路由的的处理时长 * @author xujin */public class CustomFilter implements GatewayFilter, Ordered &#123; private static final Log log = LogFactory.getLog(GatewayFilter.class); private static final String COUNT_Start_TIME = \"countStartTime\"; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; exchange.getAttributes().put(COUNT_Start_TIME, System.currentTimeMillis()); return chain.filter(exchange).then( Mono.fromRunnable(() -&gt; &#123; Long startTime = exchange.getAttribute(COUNT_Start_TIME); Long endTime=(System.currentTimeMillis() - startTime); if (startTime != null) &#123; log.info(exchange.getRequest().getURI().getRawPath() + \": \" + endTime + \"ms\"); &#125; &#125;) ); &#125; @Override public int getOrder() &#123; return Ordered.LOWEST_PRECEDENCE; &#125;&#125; 2.1.3 Gateway Filter与RouteLocator绑定使用在org.xujin.sc.GatewayServerApplication中customerRouteLocator如下所示: 1234567891011121314151617181920212223@SpringBootApplicationpublic class GatewayServerApplication &#123; @Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder) &#123; return builder.routes() .route(r -&gt; r.path(\"/test/prefix/**\") .filters(f -&gt; f.stripPrefix(2) .filter(new CustomFilter()) .addResponseHeader(\"X-Response-test\", \"test\")) .uri(\"lb://SC-CONSUMER\") .order(0) .id(\"test_consumer_service\") ) .build(); &#125; public static void main(String[] args) &#123; SpringApplication.run(GatewayServerApplication.class, args); &#125;&#125; r.path(“/test/prefix/**”)表示自定义了访问前缀，在真正的Gateway进行路由转发的时候，会用过f.stripPrefix(2)把前缀去掉。 使用场景:可以把对外暴露的URL通过加前缀分组打标。 filter(new CustomFilter() filter(new CustomFilter()，表示把自定义的Filter加到Filter链里面执行，注意一点是自定义GlobalFilter不需要加进去。 uri(“lb://SC-CONSUMER”) uri(“lb://SC-CONSUMER”)表示Spring Cloud Gateway对spring.application.name等于sc-consumer源服务应用中的URL进行协议适配转发。 2.1.4 测试如下:1.访问http://localhost:9000/SC-CONSUMER/hello/xujin 能正常访问。 123DEBUG 31658 --- [ctor-http-nio-2] o.s.c.g.h.RoutePredicateHandlerMapping : Route matched: CompositeDiscoveryClient_SC-CONSUMER2018-05-27 09:58:07.905 DEBUG 31658 --- [ctor-http-nio-2] o.s.c.g.h.RoutePredicateHandlerMapping : Mapping [Exchange: GET http://localhost:9000/SC-CONSUMER/hello/xujin] to Route&#123;id='CompositeDiscoveryClient_SC-CONSUMER', uri=lb://SC-CONSUMER, order=0, predicate=org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$337/1295338046@f2ff0c8, gatewayFilters=[OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactory$$Lambda$717/1168359877@1f74a2b, order=1&#125;]&#125;2018-05-27 09:58:07.905 DEBUG 31658 --- [ctor-http-nio-2] o.s.c.g.handler.FilteringWebHandler : Sorted gatewayFilterFactories: [OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@f5bf288&#125;, order=-1&#125;, OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactory$$Lambda$717/1168359877@1f74a2b, order=1&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@26c77f54&#125;, order=10000&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@4c38cd16&#125;, order=10100&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@2c1d57bc&#125;, order=2147483637&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@6e9a0bea&#125;, order=2147483646&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyRoutingFilter@7ddcb0dc&#125;, order=2147483647&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.ForwardRoutingFilter@3e856100&#125;, order=2147483647&#125;] 从上面的控制台打印日志可以看出，没有打印出该URL对应的耗时。 2.加上URL前缀/test/prefix/访问，测试URL为http://localhost:9000/test/prefix/hello/testCustomFilter/xujin 1232018-05-27 10:01:56.057 DEBUG 31658 --- [ctor-http-nio-2] o.s.c.g.h.RoutePredicateHandlerMapping : Mapping [Exchange: GET http://localhost:9000/test/prefix/hello/testCustomFilter/xujin] to Route&#123;id='test_consumer_service', uri=lb://SC-CONSUMER, order=0, predicate=org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$337/1295338046@6dbaa72e, gatewayFilters=[OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.StripPrefixGatewayFilterFactory$$Lambda$340/1149217113@41fb2078, order=0&#125;, org.xujin.sc.filter.CustomFilter@281885a3, OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.AddResponseHeaderGatewayFilterFactory$$Lambda$342/1099925775@4705cae6, order=0&#125;]&#125;2018-05-27 10:01:56.057 DEBUG 31658 --- [ctor-http-nio-2] o.s.c.g.handler.FilteringWebHandler : Sorted gatewayFilterFactories: [OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@f5bf288&#125;, order=-1&#125;, OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.StripPrefixGatewayFilterFactory$$Lambda$340/1149217113@41fb2078, order=0&#125;, OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.AddResponseHeaderGatewayFilterFactory$$Lambda$342/1099925775@4705cae6, order=0&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@26c77f54&#125;, order=10000&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@4c38cd16&#125;, order=10100&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@2c1d57bc&#125;, order=2147483637&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@6e9a0bea&#125;, order=2147483646&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyRoutingFilter@7ddcb0dc&#125;, order=2147483647&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.ForwardRoutingFilter@3e856100&#125;, order=2147483647&#125;, org.xujin.sc.filter.CustomFilter@281885a3]2018-05-27 10:02:00.347 INFO 31658 --- [ctor-http-nio-8] o.s.cloud.gateway.filter.GatewayFilter : /hello/testCustomFilter/xujin: 859ms 如上日志可以看到/hello/testCustomFilter/xujin: 859ms，Gateway转发的时候去掉了前缀。 2.2 GlobalFilter2.2.1 什么是GlobalFilter The GlobalFilter interface has the same signature as GatewayFilter. These are special filters that are conditionally applied to all routes. (This interface and usage are subject to change in future milestones). Spring Cloud gateway定义了GlobalFilter的接口让我们去自定义实现自己的的GlobalFilter。GlobalFilter是一个全局的Filter，作用于所有的路由。 123456789101112public interface GlobalFilter &#123; /** * Process the Web request and (optionally) delegate to the next * &#123;@code WebFilter&#125; through the given &#123;@link GatewayFilterChain&#125;. * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return &#123;@code Mono&lt;Void&gt;&#125; to indicate when request processing is complete */ Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125; 2.2.2 自定义全局过滤器(Custom GlobalFilter)在这里简单定义AuthSignatureFilter实现GlobalFilter，使用场景就是Gateway对请求的URL校验权限，判断请求的URL是否是合法请求。通过从ServerWebExchange获取请求上下文中authToken对应的值，进行判null处理，其它的check逻辑可以自定定制。 12345678910111213141516171819202122232425262728293031package org.xujin.sc.filter;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;/** * 调用鉴权 */@Componentpublic class AuthSignatureFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; String token = exchange.getRequest().getQueryParams().getFirst(\"authToken\"); if (token == null || token.isEmpty()) &#123; exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; @Override public int getOrder() &#123; return -200; &#125;&#125; GlobalFilter写完了，那问题来了？如何让其在Gateway中运行生效，有两种方式一种直接加@Component注解，另外一种可以在 Spring Config 中配置这个 Bean如下所示: 1234@Beanpublic AuthSignatureFilter authSignatureFilter()&#123; return new AuthSignatureFilter();&#125; 测试1.访问http://localhost:9000/test/prefix/hello/testCustomFilter/xujin 如下所示由于authToken为空401返回. 2.访问http://localhost:9000/test/prefix/hello/testCustomFilter/xujin?authToken=asdasdsddasadsadsadsdadsewew32rg","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"Spring Cloud Gateway基于服务发现的默认路由规则","slug":"sc/gw/gw05","date":"2018-05-21T06:00:00.000Z","updated":"2019-01-12T03:35:27.669Z","comments":true,"path":"sc/gw/gw05/","link":"","permalink":"http://xujin.org/sc/gw/gw05/","excerpt":"摘要:本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/* 和 zuul的默认路由规则http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/*差不多。","text":"摘要:本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/* 和 zuul的默认路由规则http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/*差不多。 1.Spring Gateway概述1.1 什么是Spring Cloud Gateway Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。 1.2 Spring Cloud Gateway的功能Spring Cloud Gateway 的特征： 基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0动态路由 Predicates 和 Filters 作用于特定路由 集成 Hystrix 断路器 集成 Spring Cloud DiscoveryClient 易于编写的 Predicates 和 Filters 限流 路径重写 2. Spring Cloud Gateway的工程流程 客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。 2.1 Pre和POST两种类型的过滤器3.基于服务发现的默认路由规则3.1 zuul和gateway的默认路由规则3.1.1 zuul的默认路由规则说明默认情况下，Zuul会代理所有注册到Eureka Server的微服务，并且Zuul的路由规则如下： http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/** 会被转发到serviceId对应的微服务。 http://localhost:8040/sc-zuul-first-provider/sc/order/2 3.1.2 gateway的默认路由规则下面的案例中会演示：http://localhost:9000/SC-CONSUMER/hello/xujin http://Gateway_HOST:Gateway_PORT/大写的serviceId/**，其中微服务应用名默认大写访问。 3.2 案例示例代码https://github.com/SoftwareKing/sc-gateway/tree/master/ch1 模块 说明 端口 ch1-sc-consumer 服务消费者 8000 ch1-sc-eureka Eureka Server注册中心 8761 ch1-sc-gateway Spring Cloud Gateway Sever 9000 ch1-sc-provider 服务提供者 8001 3.2.1 ch1-sc-gateway工程说明3.2.1.1 Maven依赖Spring Cloud Gateway sever主要的maven依赖如下所示 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.2.1.2 yml文件配置12345678910111213141516171819spring: application: name: sc-gateway-server cloud: gateway: discovery: locator: enabled: trueserver: port: 9000eureka: client: service-url: defaultZone: http://localhost:8761/eureka/logging: level: org.springframework.cloud.gateway: debug 配置说明： spring.cloud.gateway.discovery.locator.enabled：是否与服务发现组件进行结合，通过 serviceId 转发到具体的服务实例。默认为false，设为true便开启通过服务中心的自动根据 serviceId 创建路由的功能。 修改spring cloud gateway server监听的端口为9000 eureka.client.service-url.defaultZone: http://localhost:8761/eureka/,指定注册中心的地址，Spring Cloud Gateway从注册中心获取已经注册的服务列表。 logging.level.org.springframework.cloud.gateway: debug,开启spring-Cloud-gateway的日志级别为debug，方便debug调试。 3.3 启动测试3.3.1 错误的路由规则访问访问Spring Cloud Gateway对应的server，当访问http://localhost:9000/sc-consumer/hello/xujin的时候，报错如下所示，正确的Spring Cloud Gateway的默认路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/** 1234567891011122018-05-18 01:10:49.742 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-CONSUMER applying &#123;pattern=/SC-CONSUMER/**&#125; to Path2018-05-18 01:10:49.743 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-CONSUMER applying filter &#123;regexp=/SC-CONSUMER/(?&lt;remaining&gt;.*), replacement=/$&#123;remaining&#125;&#125; to RewritePath2018-05-18 01:10:49.743 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition matched: CompositeDiscoveryClient_SC-CONSUMER2018-05-18 01:10:49.744 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-PRODUCER applying &#123;pattern=/SC-PRODUCER/**&#125; to Path2018-05-18 01:10:49.744 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-PRODUCER applying filter &#123;regexp=/SC-PRODUCER/(?&lt;remaining&gt;.*), replacement=/$&#123;remaining&#125;&#125; to RewritePath2018-05-18 01:10:49.745 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition matched: CompositeDiscoveryClient_SC-PRODUCER2018-05-18 01:10:49.745 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-GATEWAY-SERVER applying &#123;pattern=/SC-GATEWAY-SERVER/**&#125; to Path2018-05-18 01:10:49.747 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-GATEWAY-SERVER applying filter &#123;regexp=/SC-GATEWAY-SERVER/(?&lt;remaining&gt;.*), replacement=/$&#123;remaining&#125;&#125; to RewritePath2018-05-18 01:10:49.748 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition matched: CompositeDiscoveryClient_SC-GATEWAY-SERVER2018-05-18 01:10:49.748 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.h.RoutePredicateHandlerMapping : Route matched: CompositeDiscoveryClient_SC-CONSUMER2018-05-18 01:10:49.749 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.h.RoutePredicateHandlerMapping : Mapping [Exchange: GET http://localhost:9000/SC-CONSUMER/hello/xujin] to Route&#123;id='CompositeDiscoveryClient_SC-CONSUMER', uri=lb://SC-CONSUMER, order=0, predicate=org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$707/751096818@7f4c6373, gatewayFilters=[OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactory$$Lambda$709/672603106@293895d2, order=1&#125;]&#125;2018-05-18 01:10:49.749 DEBUG 6462 --- [ctor-http-nio-5] o.s.c.g.handler.FilteringWebHandler : Sorted gatewayFilterFactories: [OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@5e85c21b&#125;, order=-1&#125;, OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactory$$Lambda$709/672603106@293895d2, order=1&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@38e83838&#125;, order=10000&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@6ef2f7ad&#125;, order=10100&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@41def031&#125;, order=2147483637&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@4966bab1&#125;, order=2147483646&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyRoutingFilter@22d477c2&#125;, order=2147483647&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.ForwardRoutingFilter@39832280&#125;, order=2147483647&#125;] 从上面的log，看到返回了 404 错误，进一步可以看到 Spring Cloud Gateway 已经为我们的 provider 和 consumer 自动创建了对应的路由转发规则，但是这里的 pattern/regexp 里都是大写的，下面换成大写的测试一下。 3.3.2 Gateway正确的路由规则测试访问正确的http://localhost:9000/SC-CONSUMER/hello/xujin，可以成功访问。 1234567891011122018-05-22 09:04:21.204 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-CONSUMER applying &#123;pattern=/SC-CONSUMER/**&#125; to Path2018-05-22 09:04:21.205 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-CONSUMER applying filter &#123;regexp=/SC-CONSUMER/(?&lt;remaining&gt;.*), replacement=/$&#123;remaining&#125;&#125; to RewritePath2018-05-22 09:04:21.205 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition matched: CompositeDiscoveryClient_SC-CONSUMER2018-05-22 09:04:21.206 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-PRODUCER applying &#123;pattern=/SC-PRODUCER/**&#125; to Path2018-05-22 09:04:21.207 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-PRODUCER applying filter &#123;regexp=/SC-PRODUCER/(?&lt;remaining&gt;.*), replacement=/$&#123;remaining&#125;&#125; to RewritePath2018-05-22 09:04:21.207 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition matched: CompositeDiscoveryClient_SC-PRODUCER2018-05-22 09:04:21.208 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-GATEWAY-SERVER applying &#123;pattern=/SC-GATEWAY-SERVER/**&#125; to Path2018-05-22 09:04:21.208 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition CompositeDiscoveryClient_SC-GATEWAY-SERVER applying filter &#123;regexp=/SC-GATEWAY-SERVER/(?&lt;remaining&gt;.*), replacement=/$&#123;remaining&#125;&#125; to RewritePath2018-05-22 09:04:21.209 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.r.RouteDefinitionRouteLocator : RouteDefinition matched: CompositeDiscoveryClient_SC-GATEWAY-SERVER2018-05-22 09:04:21.209 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.h.RoutePredicateHandlerMapping : Route matched: CompositeDiscoveryClient_SC-CONSUMER2018-05-22 09:04:21.209 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.h.RoutePredicateHandlerMapping : Mapping [Exchange: GET http://localhost:9000/SC-CONSUMER/hello/xujin] to Route&#123;id='CompositeDiscoveryClient_SC-CONSUMER', uri=lb://SC-CONSUMER, order=0, predicate=org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$706/57023854@24f1a91e, gatewayFilters=[OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactory$$Lambda$708/2036079541@cbb7393, order=1&#125;]&#125;2018-05-22 09:04:21.209 DEBUG 1677 --- [ctor-http-nio-2] o.s.c.g.handler.FilteringWebHandler : Sorted gatewayFilterFactories: [OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@29a98d9f&#125;, order=-1&#125;, OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactory$$Lambda$708/2036079541@cbb7393, order=1&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@544e8149&#125;, order=10000&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@55d58825&#125;, order=10100&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@2da3b078&#125;, order=2147483637&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@1a96d94c&#125;, order=2147483646&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyRoutingFilter@19a64eae&#125;, order=2147483647&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.ForwardRoutingFilter@7fb66650&#125;, order=2147483647&#125;] 可以看出，Spring Cloud Gateway 自动的为我们的 consumer 创建了一个路由，类似于下边这样12345678routes: - id: CompositeDiscoveryClient_SC-CONSUMER uri: lb://SC-CONSUMER order: 0 predicates: - Path=/SC-CONSUMER/** filters: - RewritePath=/SC-CONSUMER/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; 所以从zuul迁移到gateway的时候，服务路由规则中的微服务应用Id默认从小写变为大写。","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"Spring Cloud Gateway只有Pre和POST两种类型的Filter","slug":"sc/gw/gw06","date":"2018-05-21T06:00:00.000Z","updated":"2019-01-12T03:30:08.378Z","comments":true,"path":"sc/gw/gw06/","link":"","permalink":"http://xujin.org/sc/gw/gw06/","excerpt":"摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter。","text":"摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter。 zuul的Filter类型Zuul 的 Filter 是通过filterType()方法来指定，一个 Filter 只能对应一种类型，要么是 “pre” 要么是“post” Spring Cloud Gateway的Filter类型Spring Cloud Gateway 基于 Project Reactor 和 WebFlux，采用响应式编程风格，打开它的 Filter 的接口GatewayFilter你会发现它只有一个方法filter Pre类型的Filter在Spring Cloud Gateway源码中定义了一个Pre类型的Filter，code将会在chain.filter() 之前被执行,代码:AddRequestHeader 12345678910111213141516171819202122package org.springframework.cloud.gateway.filter.factory;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.http.server.reactive.ServerHttpRequest;/** * @author Spencer Gibb */public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory &#123; @Override public GatewayFilter apply(NameValueConfig config) &#123; return (exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest().mutate() .header(config.getName(), config.getValue()) .build(); return chain.filter(exchange.mutate().request(request).build()); &#125;; &#125;&#125; Post类型的Filter对于Post类型的Filter，SetStatus代码将会在chain.filter(exchange).then()里面的代码运行。 12345678910111213141516public class SetStatusGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;SetStatusGatewayFilterFactory.Config&gt; &#123; @Override public GatewayFilter apply(Config config) &#123; final HttpStatus status = ServerWebExchangeUtils.parse(config.status); return (exchange, chain) -&gt; &#123; return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; // check not really needed, since it is guarded in setStatusCode, // but it's a good example if (!exchange.getResponse().isCommitted()) &#123; setResponseStatus(exchange, status); &#125; &#125;)); &#125;; &#125;&#125;","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"公益Eureka Server与定制方法","slug":"sc/sc-diy-eureka","date":"2018-05-14T06:00:00.000Z","updated":"2019-01-12T03:46:24.845Z","comments":true,"path":"sc/sc-diy-eureka/","link":"","permalink":"http://xujin.org/sc/sc-diy-eureka/","excerpt":"摘要: 本文主要简单介绍如何定制一个eureka server，并直接指出最优的定制方式。","text":"摘要: 本文主要简单介绍如何定制一个eureka server，并直接指出最优的定制方式。 1. Spring Cloud中国公益Eureka ServerEureka Server为作为Spring Cloud开发过程中常用的注册中心组件，作为基础设施组件，开发学习过程中，经常需要自己创建Eureka Server应用和重启。为了帮助开发者快速学习入门。Spring Cloud中国社区特搭建一个公益注册中心，仅作为帮助Spring Cloud的开发者进行学习和调试。为了更好服务大家，请勿对本注册中心进行压测。定制的Eureka Server注册中心UI如下所示。 1.1 访问地址 http://eureka.springcloud.cn 2.定制Eureka Serrver的UI2.1 为什么要定制Eureka Server 原因两点: 1.觉得默认的UI比较丑 2.Eureka Server想客制化一下 至于Spring Cloud Eureka的UI客制化成什么样子由你而定！ 3. 两种方法定制Eureka Server3.1 直接修改eureka server的源代码 直接修改eureka server的源代码，该方法是最纯的方式，而且每次有一个Eureka Server的版本都需要去修改。 3.2 只修改Eureka Server的UI只需要修改对应的html+css+文案即可，完全不用去修改Eureka Server的源码,强烈推荐。 源码参考地址:https://github.com/SpringCloud/spring-cloud-eureka 3.3 为什么我定制自己的UI加进去 为什么我定制自己的UI加进去，就可以直接Run，那源码代码中的UI是不是被覆盖了？ 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.springcloud.eureka&lt;/groupId&gt; &lt;artifactId&gt;eureka-server-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 如上maven配置所示，官方的spring-cloud-starter-netflix-eureka-server依赖信息配置在下面，由maven的依赖加载顺序决定，定制的UI优先加载显示。 4. 如何在项目中使用DIY的Eureka Server只需要配置maven依赖即可:123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.springcloud.eureka&lt;/groupId&gt; &lt;artifactId&gt;eureka-server-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;","categories":[{"name":"Eureka Server","slug":"Eureka-Server","permalink":"http://xujin.org/categories/Eureka-Server/"}],"tags":[{"name":"Eureka Server","slug":"Eureka-Server","permalink":"http://xujin.org/tags/Eureka-Server/"}]},{"title":"Spring Cloud Gateway的Before路由断言工厂","slug":"sc/gw/gw04","date":"2018-03-28T06:00:00.000Z","updated":"2019-01-12T03:35:55.349Z","comments":true,"path":"sc/gw/gw04/","link":"","permalink":"http://xujin.org/sc/gw/gw04/","excerpt":"摘要:在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。","text":"摘要:在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。 1. Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念: 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。 2. 什么是Before路由断言 Before路由断言工厂带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之前会成功匹配，否则不能成功匹配。 3. Before路由断言工厂的案例3.1 引入pom依赖pom.xml依赖配置如下所示: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 3.2 application.yml文件配置:1234567891011121314151617181920server: port: 8082spring: cloud: gateway: routes: - id: before_route uri: http://xujin.org predicates: - Before=2022-03-13T00:54:30.877+08:00[Asia/Shanghai]logging: level: org.springframework.cloud.gateway: TRACE org.springframework.http.server.reactive: DEBUG org.springframework.web.reactive: DEBUG reactor.ipc.netty: DEBUGmanagement.endpoints.web.exposure.include: '*' Spring Cloud Gateway提供两种方式去配置Before路由断言工厂，这里介绍的是yml文件的配置方式。 3.3 等价的@Bean配置12345678910111213@Beanpublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123; ZonedDateTime datetime = LocalDateTime.now().plusDays(1).atZone(ZoneId.systemDefault()); //@formatter:off return builder.routes() .route(\"before_route\", r -&gt; r.before(datetime) .uri(\"http://xujin.org\")) .build(); //@formatter:on &#125; Spring Cloud Gateway提供两种方式去配置After路由断言工厂，这里介绍的是@Bean的配置方式。不管通过yml文件配置或者通过@Bean的方式配置是等价的。 3.4 测试如下:访问http://localhost:8082/ 成功转发到http://xujin.org。","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"Spring Cloud Gateway的After路由断言工厂","slug":"sc/gw/gw03","date":"2018-03-25T06:00:00.000Z","updated":"2019-01-12T03:24:23.992Z","comments":true,"path":"sc/gw/gw03/","link":"","permalink":"http://xujin.org/sc/gw/gw03/","excerpt":"摘要:本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。","text":"摘要:本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。 1.Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念: 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。 2.什么是After路由断言 After Route Predicate Factory带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之后会成功匹配，否则不能成功匹配。 3.After路由断言工厂的案例3.1 引入pom依赖pom.xml依赖配置如下所示: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 3.2 application.yml文件配置:123456789101112131415161718192021server: port: 8081spring: cloud: gateway: routes: - id: after_route uri: http://xujin.org predicates: - After=2018-03-18T17:32:58.129+08:00[Asia/Shanghai]logging: level: org.springframework.cloud.gateway: TRACE org.springframework.http.server.reactive: DEBUG org.springframework.web.reactive: DEBUG reactor.ipc.netty: DEBUGmanagement.endpoints.web.exposure.include: '*' Spring Cloud Gateway提供两种方式去配置After路由断言工厂，这里介绍的是yml文件的配置方式。 3.3 等价的@Bean配置123456789@Beanpublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123; ZonedDateTime minusTime = LocalDateTime.now().minusDays(1).atZone(ZoneId.systemDefault()); return builder.routes() .route(\"after_route\", r -&gt; r.after(minusTime) .uri(\"http://xujin.org\")) .build(); &#125; Spring Cloud Gateway提供两种方式去配置After路由断言工厂，这里介绍的是@Bean的配置方式。不管通过yml文件配置或者通过@Bean的方式配置是等价的。 3.4 测试如下:访问http://localhost:8081/成功转发到http://xujin.org","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"Spring Cloud Gateway揭秘之处理请求流程","slug":"sc/gw/gw02","date":"2018-03-17T06:00:00.000Z","updated":"2019-01-12T03:20:23.909Z","comments":true,"path":"sc/gw/gw02/","link":"","permalink":"http://xujin.org/sc/gw/gw02/","excerpt":"摘要:本篇文章主要从源码的角度揭秘Spring Cloud Gateway的怎么处理请求流程。","text":"摘要:本篇文章主要从源码的角度揭秘Spring Cloud Gateway的怎么处理请求流程。 1.Spring Gateway概述 Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。 2. Spring Cloud gateway请求入口分析 不管是Zuul，还是Spring Cloud Gateway还是基于Netty的自研网关，都会把请求进来的Request，或者返回的Response进行包装，转换提取为网关运行的上下文信息，而在Spring Cloud gateway中网关的上下文为ServerWebExchange。 2.1 入口HttpServerRequest和HttpServerResponse转换Spring Cloud Gateway的请求入口，org.springframework.http.server.reactive.ReactorHttpHandlerAdapter#apply方法 123456789101112131415161718192021222324@Override public Mono&lt;Void&gt; apply(HttpServerRequest request, HttpServerResponse response) &#123; NettyDataBufferFactory bufferFactory = new NettyDataBufferFactory(response.alloc()); ServerHttpRequest adaptedRequest; ServerHttpResponse adaptedResponse; try &#123; adaptedRequest = new ReactorServerHttpRequest(request, bufferFactory); adaptedResponse = new ReactorServerHttpResponse(response, bufferFactory); &#125; catch (URISyntaxException ex) &#123; logger.error(\"Invalid URL \" + ex.getMessage(), ex); response.status(HttpResponseStatus.BAD_REQUEST); return Mono.empty(); &#125; if (adaptedRequest.getMethod() == HttpMethod.HEAD) &#123; adaptedResponse = new HttpHeadResponseDecorator(adaptedResponse); &#125; return this.httpHandler.handle(adaptedRequest, adaptedResponse) .doOnError(ex -&gt; logger.error(\"Handling completed with error\", ex)) .doOnSuccess(aVoid -&gt; logger.debug(\"Handling completed with success\")); &#125; PS，代码来源于spring-web-5.0.4.RELEASE.jar此方法为Spring Cloud Gateway的请求入口方法，该方法的作用就是把接收到的HttpServerRequest或者最终需要返回的HttpServerResponse，包装转换为ReactorServerHttpRequest和ReactorServerHttpResponse。 2.2 构造Spring Cloud gateway的上下文ServerWebExchange在org.springframework.web.server.adapter.HttpWebHandlerAdapter的182行，代码如下所示: 1234567@Override public Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response) &#123; ServerWebExchange exchange = createExchange(request, response); return getDelegate().handle(exchange) .onErrorResume(ex -&gt; handleFailure(request, response, ex)) .then(Mono.defer(response::setComplete)); &#125; createExchange()将ServerHttpRequest ServerHttpResponse构建网关上下文ServerWebExchange。 PS:其中org.springframework.web.server.handler.WebHandlerDecorator.getDelegate()通过委托的方式获取一系列需要处理的WebHandler. 2.3 进入Filter链org.springframework.cloud.gateway.handler.FilteringWebHandler#handle方法，即77行，代码如下所示 12345678910111213@Overridepublic Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123; Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR); List&lt;GatewayFilter&gt; gatewayFilters = route.getFilters(); List&lt;GatewayFilter&gt; combined = new ArrayList&lt;&gt;(this.globalFilters); combined.addAll(gatewayFilters); //TODO: needed or cached? AnnotationAwareOrderComparator.sort(combined); logger.debug(\"Sorted gatewayFilterFactories: \"+ combined); return new DefaultGatewayFilterChain(combined).filter(exchange);&#125; 2.4 执行Filter链1234567891011121314151617181920private static class DefaultGatewayFilterChain implements GatewayFilterChain &#123; private int index; private final List&lt;GatewayFilter&gt; filters; public DefaultGatewayFilterChain(List&lt;GatewayFilter&gt; filters) &#123; this.filters = filters; &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange) &#123; if (this.index &lt; filters.size()) &#123; GatewayFilter filter = filters.get(this.index++); return filter.filter(exchange, this); &#125; else &#123; return Mono.empty(); // complete &#125; &#125; &#125; 2.5 Gateway Filter委托为Gloable Filter执行123456789101112131415161718192021private static class GatewayFilterAdapter implements GatewayFilter &#123; private final GlobalFilter delegate; public GatewayFilterAdapter(GlobalFilter delegate) &#123; this.delegate = delegate; &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; return this.delegate.filter(exchange, chain); &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(\"GatewayFilterAdapter&#123;\"); sb.append(\"delegate=\").append(delegate); sb.append('&#125;'); return sb.toString(); &#125; &#125; 2.6 预告待续在之后的文章中，将会揭秘Spring Cloud Gateway的架构设计，Filter链设计，以及启动装在流程等。","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud 源码分析","slug":"Spring-Cloud-源码分析","permalink":"http://xujin.org/tags/Spring-Cloud-源码分析/"},{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"Spring Cloud Gateway入门案例","slug":"sc/gw/gw-01","date":"2018-03-15T06:00:00.000Z","updated":"2019-01-12T03:21:16.579Z","comments":true,"path":"sc/gw/gw-01/","link":"","permalink":"http://xujin.org/sc/gw/gw-01/","excerpt":"摘要:本篇文章主要介绍了什么是Spring Cloud Gateway，并基于Spring Cloud Gateway的Finchley.M8版本编写一个Spring Cloud Gateway的入门案例，即基本代理的路由转发配置。","text":"摘要:本篇文章主要介绍了什么是Spring Cloud Gateway，并基于Spring Cloud Gateway的Finchley.M8版本编写一个Spring Cloud Gateway的入门案例，即基本代理的路由转发配置。 1.Spring Gateway概述1.1 什么是Spring Cloud Gateway Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。 2. Spring Cloud Gateway入门案例2.1 创建maven工程配置Spring Cloud Gateway的相关Maven依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;ch18-1&lt;/artifactId&gt; &lt;groupId&gt;cn.springcloud.book&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;ch18-1-gateway&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;ch18-1-gateway&lt;/name&gt; &lt;url&gt;http://springcloud.cn&lt;/url&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.M8&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 2.2 Spring Cloud Gateway主程序SpringCloudGatewayApplication.java，代码如下所示: 12345678910111213141516171819202122232425package cn.springcloud.book.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class SpringCloudGatewayApplication &#123; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123; return builder.routes() //basic proxy .route(r -&gt; r.path(\"/baidu\") .uri(\"http://baidu.com:80/\") ).build(); &#125; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudGatewayApplication.class, args); &#125;&#125; 2.3 编写application.yml文件123456789101112131415161718192021server: port: 8080spring: application: name: spring-cloud-gatewayspring: cloud: gateway: routes: - id: xujin_route uri: http://www.xujin.org:80/ predicates: - Path=/xujinlogging: level: org.springframework.cloud.gateway: TRACE org.springframework.http.server.reactive: DEBUG org.springframework.web.reactive: DEBUG reactor.ipc.netty: DEBUG 2.4 基本代理路由配置等同写法Spring Cloud Gateway提供了两种配置路由规则的方法 第一:通过@Bean自定义RouteLocator12345678@Beanpublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123; return builder.routes() //basic proxy .route(r -&gt; r.path(\"/baidu\") .uri(\"http://baidu.com:80/\") ).build();&#125; 第二:通过属于文件或者yml文件配置 12345678spring: cloud: gateway: routes: - id: xujin_route uri: http://www.xujin.org:80/ predicates: - Path=/xujin PS,以上两种方式等同。 2.5 错误的示范代码如下:12345678@Beanpublic RouteLocator routingConfig() &#123; return Routes.locator() .route(\"xujin_route\") .uri(\"http://xujin.org\") .predicate(host(\"**.xujin.org\")) .build();&#125; 温馨提示，上面这种写法是基于Spring Cloud Gateway FM4的版本，相关代码已废弃，目前Spring Cloud Gateway将会在FM9之后Realese。 2.6 运行测试 访问http://localhost:8080/baidu,路由转发到http://www.baidu.com 访问http://localhost:8080/xujin,路由转发到http://xujin.orgyml 12345678@Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123; return builder.routes() //basic proxy .route(r -&gt; r.path(\"/baidu\") .uri(\"http://baidu.com:80/\") ).build(); &#125; 12345678spring: cloud: gateway: routes: - id: xujin_route uri: http://www.xujin.org:80/ predicates: - Path=/xujin","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"Spring Cloud 源码分析","slug":"Spring-Cloud-源码分析","permalink":"http://xujin.org/tags/Spring-Cloud-源码分析/"},{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://xujin.org/tags/Spring-Cloud-Gateway/"}]},{"title":"SC中Eureka Server的HA和安全身份验证","slug":"sc/sc-eureka-02","date":"2017-03-25T06:00:00.000Z","updated":"2019-01-12T03:48:16.249Z","comments":true,"path":"sc/sc-eureka-02/","link":"","permalink":"http://xujin.org/sc/sc-eureka-02/","excerpt":"摘要:在《跟我学Spring Cloud》中的上一篇文章中简单介绍了使用Eureka实现服务的注册与发现。在这篇文章中主要介绍一下Eureka Server注册中心的HA以及Eureka Server的身份验证。","text":"摘要:在《跟我学Spring Cloud》中的上一篇文章中简单介绍了使用Eureka实现服务的注册与发现。在这篇文章中主要介绍一下Eureka Server注册中心的HA以及Eureka Server的身份验证。 什么是高可用高可用 High Availability，即高可用HA。在分布式情况下，我们经常说4个9(99.99%)或者5个9(99.999%)。举个简单例子，如果一个微服务分布式系统依赖于30个微服务，每个微服务可用性是99.99%，那么整个微服务系统的可用性就是99.99%的30次方 ≈ 99.7% ，也就是说有0.3%系统是不可用的，0.3%意味着如果Qps很高，有一亿次请求的话，那么就会有30万次失败。换算成时间大约每月有2个小时服务不稳定。特别是随着服务依赖数量的变多，微服务不稳定的概率会成指数性上升。因此要保证微服务应用的HA需要从各方面入手，下面会介绍一下如何实现Eureka Server的HA。参考工程如下所示。 Tips：代码示例:https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-ha Eureka Server的HAEureka Server的HA两个工程演示HA 如示例工程所示，我新建了两个Project分别为sc-eureka-ha-server1，sc-eureka-ha-server2， 我们知道在Eureka Server的Standalone模式下面，由于只有一个Eureka Server，所以我们通过配置如下信息关闭Eureka Server的自我注册和抓取注册信息，但是两个Eureka Server之间需要设置为True，相互注册相互感知对方注册信息的变化，从而实现信息同步。 1.sc-eureka-ha-server1的application.yml配置Info 如下： 123456789spring: application: name: sc-eureka-ha-server1server: port: 8761 # 指定该Eureka实例的端口eureka: client: serviceUrl: defaultZone: http://localhost:8762/eureka/ 2.sc-eureka-ha-server2的application.yml配置Info 如下 12345678910spring: application: name: sc-eureka-ha-server2 server: port: 8762 # 指定该Eureka实例的端口eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 3.主程序入口代码没什么区别如下: 1234567@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 4.分别启动sc-eureka-ha-server1和sc-eureka-ha-server2，访问http://localhost:8761/ ,http://localhost:8762/ ，如下: 5.服务提供者sc-eureka-ha-provider其它代码见工程,application.yml如下所示。 1234567891011 server: port: 8000 spring: application: name: sc-eureka-ha-provider eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ tips: 把服务提供者的服务注册信息，注册到Eureka Server 01上。 启动服务提供者，见如下图所示。 片刻服务提供者的信息也同步到Eureka Server02上面 Jar方式演示HA Eureka Server的HA，其实可以通过jar的方式指定使用不同的profile配置的方式，在本地运行两个Eureka Server。只需将Eureka server的application.yml修改如下：12345678910111213141516171819202122232425spring: application: name: sc-eureka-ha-server --- spring: profiles: peer1 server: port: 8761 eureka: instance: hostname: peer1.xujin.org client: serviceUrl: defaultZone: http://peer2.xujin.org:8762/eureka/ --- spring: profiles: peer2 server: port: 8762 eureka: instance: hostname: peer2.xujin.org client: serviceUrl: defaultZone: http://peer1.xujin.org:8761/eureka/ 通过配置switcHosts或者自行配置HostName对应的IP地址,把工程打成jar之后，运行如下命令123 java -jar sc-eureka-ha-server1-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2java -jar sc-eureka-ha-server1-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1 测试如下: 安全身份验证 如果客户端的eureka.client.serviceUrl.defaultZone参数值(即Eureka Server的地址)中包含HTTP Basic Authentication信息，如http://user:password@localhost:8761/eureka，那么客户端就会自动使用该用户名、密码信息与Eureka服务端进行验证。如果你需要更复杂的验证逻辑，你必须注册一个DiscoveryClientOptionalArgs组件，并将ClientFilter组件注入，在这里定义的逻辑会在每次客户端向服务端发起请求时执行。 Tips：代码示例:https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-security 访问Eureka Server安全身份验证 如工程sc-eureka-securit中的sc-eureka-security-server工程所示，在pom.xml中增加依赖如下: 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; application.yml如下 123456789101112131415161718 server: port: 8761 # 指定该Eureka实例的端口eureka: client: #表示是否将自己注册到Eureka Server上，默认为true，当前应用为Eureka Server所以无需注册 registerWithEureka: false #表示是否从Eureka Server获取注册信息，默认为true。因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据，故而设为false。 fetchRegistry: false #Eureka Server的访问地址，服务注册和client获取服务注册信息均通过该URL，多个服务注册地址用,隔开 serviceUrl: defaultZone: http://localhost:8761/eureka/ security: basic: enabled: true user: name: xujin password: 123 3.启动Eureka server测试，如下图所示 服务提供者注册Eureka Server安全身份验证1.服务提供者只需注册时修改application.yml 1234567891011 server: port: 8000 spring: application: name: sc-eureka-security-provider eureka: client: service-url: defaultZone: http://xujin:123@localhost:8761/eureka/ Tips:如上所示:http://用户名:密码@localhost:8761/eureka/","categories":[{"name":"跟我学Spring Cloud","slug":"跟我学Spring-Cloud","permalink":"http://xujin.org/categories/跟我学Spring-Cloud/"}],"tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/tags/Spring-Cloud-Eureka/"}]},{"title":"使用Spring Cloud Eureka实现服务注册与发现","slug":"sc/sc-eureka-01","date":"2017-03-23T06:00:00.000Z","updated":"2019-01-12T03:48:54.822Z","comments":true,"path":"sc/sc-eureka-01/","link":"","permalink":"http://xujin.org/sc/sc-eureka-01/","excerpt":"摘要:由于目前，网上的Spring Cloud的学习的案列，比较凌乱而且没有形成整个体系，因此特开一个专题为跟我学Spring Cloud，希望帮助到有需要的人。本文主要介绍如何使用Spring Cloud中的Eureka组件快速实现微服务的服务注册与发现。至于安全模式和Eureka Server的HA,后面的文章会详细介绍。如果您觉得，有想了解的内容，参与评论留言。","text":"摘要:由于目前，网上的Spring Cloud的学习的案列，比较凌乱而且没有形成整个体系，因此特开一个专题为跟我学Spring Cloud，希望帮助到有需要的人。本文主要介绍如何使用Spring Cloud中的Eureka组件快速实现微服务的服务注册与发现。至于安全模式和Eureka Server的HA,后面的文章会详细介绍。如果您觉得，有想了解的内容，参与评论留言。 什么是服务注册与发现服务注册与发现 在服务化的早期，服务不是很多，服务的注册与发现并不是什么新鲜的名词，Nginx+内部域名服务器方式，甚至Nginx+host文件配置方式也能完成服务的注册与发现。服务上下线需要在nginx,服务器做相应的配置，一旦服务的IP端口发生变化，都需要在nginx上做相应的配置，为了解决这个问题引入服务注册中心。 服务注册,即服务在启动的时候就将服务的IP,端口,版本号等EndPoint注册到注册中心(Eueka,Zookeeper,Consul)对服务进行统一管理. 服务发现,简单的就是说，不管服务上下线，当对某个服务发起请求时，能够快速的从本地缓存或者注册中心的注册列表中，快速找到服务提供者。 服务化早期的做法示例工程说明 Tips：代码示例:https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-first Spring MVC中基于无状态的REST 工程可以参考sc-rest-demo下面的sc-rest-provider和sc-rest-consumer，具体使用如下代码所示：123456789101112131415161718192021@RestController@RequestMapping(\"/sc\")public class ConsumerController &#123; @Autowired private RestTemplate restTemplate; // 从属性文件中读取服务提供的URL @Value(\"$&#123;order.orderServiceUrl&#125;\") private String orderServiceUrl; @GetMapping(\"/consumer/&#123;id&#125;\") public OrderModel getOrderInfo(@PathVariable Long id) &#123; // this.restTemplate.getForObject(\"http://localhost:8000/sc/order/\" + // id,OrderModel.class); return this.restTemplate.getForObject(this.orderServiceUrl + \"/sc/order/\" + id, OrderModel.class); &#125;&#125; 大家注意到没，把http://localhost:8000 ,硬编码到程序中，是不是比较low。可以采用上面代码中的方式：orderServiceUrl解决。但是这样还是比较low,下面介绍一下引入Eureka实现服务注册与发现的处理。 使用Eureka实现服务的注册与发现搭建注册中心-Eureka Server 1.引入依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\"?&gt;&lt;project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 引入spring boot的依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;sc-eureka-first-server-HA01&lt;/artifactId&gt; &lt;name&gt;sc-eureka-first-server-HA01&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 引入Spring Cloud Eureka依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 引入spring cloud的依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Camden.SR5&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; &lt;!-- 添加spring-boot的maven插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 在Resources目录下创建application.yml123456789101112131415server: port: 8761 # 指定该Eureka实例的端口eureka: client: #表示是否将自己注册到Eureka Server上，默认为true，当前应用为Eureka Server所以无需注册 registerWithEureka: false #表示是否从Eureka Server获取注册信息，默认为true。因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据，故而设为false。 fetchRegistry: false #Eureka Server的访问地址，服务注册和client获取服务注册信息均通过该URL，多个服务注册地址用,隔开 serviceUrl: defaultZone: http://localhost:8761/eureka/# 参考文档：http://projects.spring.io/spring-cloud/docs/1.0.3/spring-cloud.html#_standalone_mode# 参考文档：http://my.oschina.net/buwei/blog/618756 3.创建Spring Boot主应用程序启动代码12345678910111213141516171819package org.xujin.sc.eureka.server;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * Eureka Server * @author xujin */@SpringBootApplication@EnableEurekaServerpublic class SpringCloudEurekaServer &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudEurekaServer.class, args); &#125;&#125; 启动Eureka server测试： 启动sc-eureka-first-server-HA01，访问http://localhost:8761/ ,如下图所示: 创建服务提供者 1.服务提供者，为了演示在这里提供一个简单的订单查询服务，如工程sc-eureka-first-provider01和sc-eureka-first-provider02所示。 2.主程序入口代码，如下所示：123456789101112131415161718192021package org.xujin.sc.eureka.first.order;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * 服务提供者端，加上@EnableDiscoveryClient注解，完成服务注册。 * @author xujin * @site http://xujin.org */@SpringBootApplication@EnableDiscoveryClient// @EnableEurekaClientpublic class OrderProviderSpringBootAppliaction &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderProviderSpringBootAppliaction.class, args); &#125;&#125; Tips:如果使用Eureka, 可以使用@EnableEurekaClient注解，但是推荐使用@EnableDiscoveryClient代替@EnableEurekaClient注解，因为@EnableDiscoveryClient是一个高度的抽象， 来自于spring-cloud-commons， 由于Spring Cloud选型是中立的因此抽象出该接口， 当服务注册中心选型改变为Eureka，ZK，Consul时，不需要修改原有代码中的注解。 3.服务提供者暴露的服务-OrderController.java12345678910111213@RestControllerpublic class OrderController &#123; @Autowired private OrderService orderService; @GetMapping(\"/sc/order/&#123;id&#125;\") public OrderModel findOrderById(@PathVariable Long id) &#123; OrderModel orderModel = orderService.findOrderByOrderId(id); return orderModel; &#125;&#125; 启动服务提供者，把服务注册信息，注册到Eureka Server注册中心启动sc-eureka-first-provider01,当启动其中一个服务后刷新Eureka Server会出现安全模式,如下图所示: 启动sc-eureka-first-provider02，刷新Eureka Server如下图所示。 创建服务消费者 服务消费者主要是一个简单的用户服务，用户服务查询订单服务的订单信息。 1.引入相应的依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 &lt;?xml version=\"1.0\"?&gt;&lt;project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.xujin.sc&lt;/groupId&gt; &lt;artifactId&gt;sc-eureka-first-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;sc-eureka-first-consumer&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 引入spring boot的依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.6&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 引入spring cloud的依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Camden.SR4&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 添加spring-boot的maven插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.主程序入口代码12345678910111213141516171819202122package org.xujin.sc.eureka.user;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;//消费者端加入服务发现注解@EnableDiscoveryClient@SpringBootApplicationpublic class UserConsumerApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerApplication.class, args); &#125;&#125; 消费者调用Controller。 12345678910111213141516171819202122232425262728@RestControllerpublic class UserController &#123; private static final Logger logger = LoggerFactory.getLogger(UserController.class); @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; // discoveryClient获取服务列表中，应用名为sc-eureka-first-provider一个服务注册信息 public String serviceUrl() &#123; List&lt;ServiceInstance&gt; list = discoveryClient .getInstances(\"sc-eureka-first-provider\"); if (list != null &amp;&amp; list.size() &gt; 0) &#123; return String.valueOf(list.get(0).getUri()); &#125; return null; &#125; @GetMapping(\"/sc/user/&#123;id&#125;\") public Order findByIdByEurekaServer(@PathVariable Long id) &#123; String providerServiceUrl = serviceUrl(); return this.restTemplate.getForObject(providerServiceUrl + \"sc/order/\" + id, Order.class); &#125;&#125; 如上述代码，所示使用discoveryClient.getInstances(&quot;sc-eureka-first-provider&quot;)获取服务名为sc-eureka-first-provider的服务注册列表信息。 测试先后启动sc-eureka-first-consumer,如没有异常，打开浏览器访问:http://localhost:8010/sc/user/2 ,debug如下所示可以看到 在刷新一下Eureka Server，如图下所示,此时安全模式关闭。 关于安全模式，在本篇文章中，暂不讨论，后面将会专写一篇文章介绍，请暂时忽略。 获取消费者获取服务端消费列表 使用EurekaClient获取服务注册信息 1234567 @Autowiredprivate EurekaClient discoveryClient;public String serviceUrl() &#123; InstanceInfo instance = discoveryClient.getNextServerFromEureka(\"STORES\", false); return instance.getHomePageUrl();&#125; 使用DiscoveryClient获取服务注册信息 12345678910 @Autowiredprivate DiscoveryClient discoveryClient;public String serviceUrl() &#123; List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(\"STORES\"); if (list != null &amp;&amp; list.size() &gt; 0 ) &#123; return list.get(0).getUri(); &#125; return null;&#125; 参考链接：https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc 小结 上面这个例子使用Eureka实现了服务的注册与发现，但是有一个问题就是获取服务注册列表的方式比较low并且太方便，还有一个问题就是没有使用负载均衡（Load Balance)，这样就没法实现微服务的HA。在后面的文章将会介绍Eureka Server的HA和使用Robbin实现LB。。","categories":[{"name":"跟我学Spring Cloud","slug":"跟我学Spring-Cloud","permalink":"http://xujin.org/categories/跟我学Spring-Cloud/"}],"tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/tags/Spring-Cloud-Eureka/"}]},{"title":"Spring Cloud Eureka服务下线(Cancel)源码分析","slug":"sc/sc-eureka-cancle","date":"2016-11-19T06:00:00.000Z","updated":"2019-01-12T04:25:00.258Z","comments":true,"path":"sc/sc-eureka-cancle/","link":"","permalink":"http://xujin.org/sc/sc-eureka-cancle/","excerpt":"摘要:在本篇文章中主要对Eureka的Cancel(服务下线)进行源码分析，在Service Provider服务shut down的时候，需要及时通知Eureka Server把自己剔除，从而避免其它客户端调用已经下线的服务，导致服务不可用。 Cancel(服务下线)概述在Service Provider服务shut down的时候，需要及时通知Eureka Server把自己剔除，从而避免客户端调用已经下线的服务。 服务提供者端源码分析 在eureka-client-1.4.1中的com.netflix.discovery.DiscoveryClient中shutdown()的867行。","text":"摘要:在本篇文章中主要对Eureka的Cancel(服务下线)进行源码分析，在Service Provider服务shut down的时候，需要及时通知Eureka Server把自己剔除，从而避免其它客户端调用已经下线的服务，导致服务不可用。 Cancel(服务下线)概述在Service Provider服务shut down的时候，需要及时通知Eureka Server把自己剔除，从而避免客户端调用已经下线的服务。 服务提供者端源码分析 在eureka-client-1.4.1中的com.netflix.discovery.DiscoveryClient中shutdown()的867行。 123456789101112131415161718192021222324252627282930313233/** * Shuts down Eureka Client. Also sends a deregistration request to the * eureka server. */ @PreDestroy @Override public synchronized void shutdown() &#123; if (isShutdown.compareAndSet(false, true)) &#123; logger.info(\"Shutting down DiscoveryClient ...\"); if (statusChangeListener != null &amp;&amp; applicationInfoManager != null) &#123; applicationInfoManager.unregisterStatusChangeListener(statusChangeListener.getId()); &#125; cancelScheduledTasks(); // If APPINFO was registered if (applicationInfoManager != null &amp;&amp; clientConfig.shouldRegisterWithEureka()) &#123; applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN); //调用下线接口 unregister(); &#125; if (eurekaTransport != null) &#123; eurekaTransport.shutdown(); &#125; heartbeatStalenessMonitor.shutdown(); registryStalenessMonitor.shutdown(); logger.info(\"Completed shut down of DiscoveryClient\"); &#125; &#125; Tips @PreDestroy注解或shutdown()的方法是服务下线的入口 在eureka-client-1.4.1中的com.netflix.discovery.DiscoveryClient中unregister（）的897行12345678910111213141516 /** * unregister w/ the eureka service. */ void unregister() &#123; // It can be null if shouldRegisterWithEureka == false if(eurekaTransport != null &amp;&amp; eurekaTransport.registrationClient != null) &#123; try &#123; logger.info(\"Unregistering ...\"); //发送服务下线请求 EurekaHttpResponse&lt;Void&gt; httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId()); logger.info(PREFIX + appPathIdentifier + \" - deregister status: \" + httpResponse.getStatusCode()); &#125; catch (Exception e) &#123; logger.error(PREFIX + appPathIdentifier + \" - de-registration failed\" + e.getMessage(), e); &#125; &#125;&#125; Eureka Server服务下线实现细节 在com.netflix.eureka.resources.InstanceResource中的280行中的cancelLease()方法 123456789101112131415@DELETEpublic Response cancelLease( @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) &#123; //调用cancel boolean isSuccess = registry.cancel(app.getName(), id, \"true\".equals(isReplication)); if (isSuccess) &#123; logger.debug(\"Found (Cancel): \" + app.getName() + \" - \" + id); return Response.ok().build(); &#125; else &#123; logger.info(\"Not Found (Cancel): \" + app.getName() + \" - \" + id); return Response.status(Status.NOT_FOUND).build(); &#125;&#125; 在org.springframework.cloud.netflix.eureka.server.InstanceRegistry中的95行的cancel()方法， 123456@Overridepublic boolean cancel(String appName, String serverId, boolean isReplication) &#123; handleCancelation(appName, serverId, isReplication); //调用父类中的cancel return super.cancel(appName, serverId, isReplication);&#125; 在com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中的376行 123456789101112131415161718 @Override public boolean cancel(final String appName, final String id, final boolean isReplication) &#123; if (super.cancel(appName, id, isReplication)) &#123; //服务下线成功后，同步更新信息到其它Eureka Server节点 replicateToPeers(Action.Cancel, appName, id, null, null, isReplication); synchronized (lock) &#123; if (this.expectedNumberOfRenewsPerMin &gt; 0) &#123; // Since the client wants to cancel it, reduce the threshold (1 for 30 seconds, 2 for a minute) this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin - 2; this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold()); &#125; &#125; return true; &#125; return false;&#125; 4.在com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中的618行，主要接口实现方式和register基本一致：首先更新自身Eureka Server中服务的状态，再同步到其它Eureka Server中。12345678910111213141516171819202122232425private void replicateToPeers(Action action, String appName, String id, InstanceInfo info /* optional */, InstanceStatus newStatus /* optional */, boolean isReplication) &#123; Stopwatch tracer = action.getTimer().start(); try &#123; if (isReplication) &#123; numberOfReplicationsLastMin.increment(); &#125; // If it is a replication already, do not replicate again as this will create a poison replication if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123; return; &#125; // 同步把服务信息同步到其它的Eureka Server中 for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123; // If the url represents this host, do not replicate to yourself. if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123; continue; &#125; //根据action做相应操作的同步 replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node); &#125; &#125; finally &#123; tracer.stop(); &#125; &#125; 至此，Eureka服务续约源码分析结束，大家有兴趣可自行阅读。 源码分析链接 其它源码分析链接: Spring Cloud中@EnableEurekaClient源码分析: http://xujin.org/sc/sc-enableEurekaClient-annonation/ Spring Cloud Eureka服务注册源码分析： http://xujin.org/sc/sc-eureka-register/ Spring Cloud Eureka服务续约(Renew)源码分析 http://xujin.org/sc/sc-eureka-renew/","categories":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/categories/Spring-Cloud-Eureka/"}],"tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/tags/Spring-Cloud-Eureka/"}]},{"title":"Spring Cloud Eureka服务续约(Renew)源码分析","slug":"sc/sc-eureka-renew","date":"2016-11-13T06:00:00.000Z","updated":"2019-01-12T04:36:27.970Z","comments":true,"path":"sc/sc-eureka-renew/","link":"","permalink":"http://xujin.org/sc/sc-eureka-renew/","excerpt":"摘要:在本篇文章中主要对Eureka的Renew(服务续约)，从服务提供者发起续约请求开始分析，通过阅读源码和画时序图的方式，展示Eureka服务续约的整个生命周期。服务续约主要是把服务续约的信息更新到自身的Eureka Server中，然后再同步到其它Eureka Server中。 1. Renew(服务续约)1.1 概述Renew（服务续约）操作由Service Provider定期调用，类似于heartbeat。目的是隔一段时间Service Provider调用接口，告诉Eureka Server它还活着没挂，不要把它T了。通俗的说就是它们两之间的心跳检测，避免服务提供者被剔除掉。请参考:Spring Cloud Eureka名词解释","text":"摘要:在本篇文章中主要对Eureka的Renew(服务续约)，从服务提供者发起续约请求开始分析，通过阅读源码和画时序图的方式，展示Eureka服务续约的整个生命周期。服务续约主要是把服务续约的信息更新到自身的Eureka Server中，然后再同步到其它Eureka Server中。 1. Renew(服务续约)1.1 概述Renew（服务续约）操作由Service Provider定期调用，类似于heartbeat。目的是隔一段时间Service Provider调用接口，告诉Eureka Server它还活着没挂，不要把它T了。通俗的说就是它们两之间的心跳检测，避免服务提供者被剔除掉。请参考:Spring Cloud Eureka名词解释 1.2 服务续约配置 Renew操作会在Service Provider定时发起，用来通知Eureka Server自己还活着。 这里有两个比较重要的配置需要如下，可以在Run之前配置。1eureka.instance.leaseRenewalIntervalInSeconds Renew频率。默认是30秒，也就是每30秒会向Eureka Server发起Renew操作。1eureka.instance.leaseExpirationDurationInSeconds 服务失效时间。默认是90秒，也就是如果Eureka Server在90秒内没有接收到来自Service Provider的Renew操作，就会把Service Provider剔除。 2. Renew源码分析2.1 服务提供者实现细节 服务提供者发发起服务续约的时序图，如下图所示,大家先直观的看一下时序图，等阅读完源码再回顾一下。 在com.netflix.discovery.DiscoveryClient.initScheduledTasks()中的1272行，TimedSupervisorTask会定时发起服务续约，代码如下所示:123456789101112// Heartbeat timer scheduler.schedule( new TimedSupervisorTask( \"heartbeat\", scheduler, heartbeatExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, new HeartbeatThread() ), renewalIntervalInSecs, TimeUnit.SECONDS); 2.在com.netflix.discovery.DiscoveryClient中的1393行，有一个HeartbeatThread线程发起续约操作123456789 private class HeartbeatThread implements Runnable &#123; public void run() &#123; //调用eureka-client中的renew if (renew()) &#123; lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis(); &#125; &#125;&#125; renew()调用eureka-client-1.4.11.jarcom.netflix.discovery.DiscoveryClient中829行renew()发起PUT Reset请求，调用com.netflix.eureka.resources.InstanceResource中的renewLease()续约。12345678910111213141516171819/** * Renew with the eureka service by making the appropriate REST call */ boolean renew() &#123; EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse; try &#123; httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null); logger.debug(\"&#123;&#125; - Heartbeat status: &#123;&#125;\", PREFIX + appPathIdentifier, httpResponse.getStatusCode()); if (httpResponse.getStatusCode() == 404) &#123; REREGISTER_COUNTER.increment(); logger.info(\"&#123;&#125; - Re-registering apps/&#123;&#125;\", PREFIX + appPathIdentifier, instanceInfo.getAppName()); return register(); &#125; return httpResponse.getStatusCode() == 200; &#125; catch (Throwable e) &#123; logger.error(\"&#123;&#125; - was unable to send heartbeat!\", PREFIX + appPathIdentifier, e); return false; &#125; &#125; 2.2 Netflix中的Eureka Core实现细节 NetFlix中Eureka Core中的服务续约时序图，如下图所示。 打开com.netflix.eureka.resources.InstanceResource中的106行的renewLease()方法，代码如下: 123456789101112private final PeerAwareInstanceRegistry registry@PUTpublic Response renewLease( @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication, @QueryParam(\"overriddenstatus\") String overriddenStatus, @QueryParam(\"status\") String status, @QueryParam(\"lastDirtyTimestamp\") String lastDirtyTimestamp) &#123; boolean isFromReplicaNode = \"true\".equals(isReplication); //调用 boolean isSuccess = registry.renew(app.getName(), id, isFromReplicaNode); //其余省略&#125; 点开registry.renew(app.getName(), id, isFromReplicaNode);我们可以看到，调用了org.springframework.cloud.netflix.eureka.server.InstanceRegistry中的renew（）方法，代码如下: 1234567891011121314151617181920212223 @Override public boolean renew(final String appName, final String serverId, boolean isReplication) &#123; log(\"renew \" + appName + \" serverId \" + serverId + \", isReplication &#123;&#125;\" + isReplication); List&lt;Application&gt; applications = getSortedApplications(); for (Application input : applications) &#123; if (input.getName().equals(appName)) &#123; InstanceInfo instance = null; for (InstanceInfo info : input.getInstances()) &#123; if (info.getHostName().equals(serverId)) &#123; instance = info; break; &#125; &#125; publishEvent(new EurekaInstanceRenewedEvent(this, appName, serverId, instance, isReplication)); break; &#125; &#125; //调用com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中的renew方法 return super.renew(appName, serverId, isReplication);&#125; 3.从super.renew()看到调用了父类中的com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中420行的renew()方法，代码如下:123456789 public boolean renew(final String appName, final String id, final boolean isReplication) &#123; //服务续约成功， if (super.renew(appName, id, isReplication)) &#123; //然后replicateToPeers同步其它Eureka Server中的数据 replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication); return true; &#125; return false;&#125; 3.1 从上面代码中super.renew(appName, id, isReplication)可以看出调用的是com.netflix.eureka.registry.AbstractInstanceRegistry中345行的renew()方法，代码如下所示12345678910111213141516171819202122232425262728293031323334353637383940public boolean renew(String appName, String id, boolean isReplication) &#123; RENEW.increment(isReplication); Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName); Lease&lt;InstanceInfo&gt; leaseToRenew = null; if (gMap != null) &#123; leaseToRenew = gMap.get(id); &#125; if (leaseToRenew == null) &#123; RENEW_NOT_FOUND.increment(isReplication); logger.warn(\"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;\", appName, id); return false; &#125; else &#123; InstanceInfo instanceInfo = leaseToRenew.getHolder(); if (instanceInfo != null) &#123; // touchASGCache(instanceInfo.getASGName()); InstanceStatus overriddenInstanceStatus = this.getOverriddenInstanceStatus( instanceInfo, leaseToRenew, isReplication); if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123; logger.info(\"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;\" + \"; re-register required\", instanceInfo.getId()); RENEW_NOT_FOUND.increment(isReplication); return false; &#125; if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123; Object[] args = &#123; instanceInfo.getStatus().name(), instanceInfo.getOverriddenStatus().name(), instanceInfo.getId() &#125;; logger.info( \"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. \" + \"Hence setting the status to overridden status\", args); instanceInfo.setStatus(overriddenInstanceStatus); &#125; &#125; renewsLastMin.increment(); leaseToRenew.renew(); return true; &#125; &#125; 其中 leaseToRenew.renew()是调用com.netflix.eureka.lease.Lease中的62行的renew()方法123456789/** * Renew the lease, use renewal duration if it was specified by the * associated &#123;@link T&#125; during registration, otherwise default duration is * &#123;@link #DEFAULT_DURATION_IN_SECS&#125;. */public void renew() &#123; lastUpdateTimestamp = System.currentTimeMillis() + duration;&#125; 3.2 replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication);调用自身的replicateToPeers()方法，在com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中的618行，主要接口实现方式和register基本一致：首先更新自身Eureka Server中服务的状态，再同步到其它Eureka Server中。12345678910111213141516171819202122232425private void replicateToPeers(Action action, String appName, String id, InstanceInfo info /* optional */, InstanceStatus newStatus /* optional */, boolean isReplication) &#123; Stopwatch tracer = action.getTimer().start(); try &#123; if (isReplication) &#123; numberOfReplicationsLastMin.increment(); &#125; // If it is a replication already, do not replicate again as this will create a poison replication if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123; return; &#125; // 同步把续约信息同步到其它的Eureka Server中 for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123; // If the url represents this host, do not replicate to yourself. if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123; continue; &#125; //根据action做相应操作的同步 replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node); &#125; &#125; finally &#123; tracer.stop(); &#125; &#125; 至此，Eureka服务续约源码分析结束，大家有兴趣可自行阅读。 2.3 源码分析链接 其它源码分析链接: Spring Cloud中@EnableEurekaClient源码分析: http://blog.xujin.org/sc/sc-enableEurekaClient-annonation/ Spring Cloud Eureka服务注册源码分析： http://blog.xujin.org/sc/sc-eureka-register/","categories":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/categories/Spring-Cloud-Eureka/"}],"tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/tags/Spring-Cloud-Eureka/"},{"name":"Spring Cloud 源码分析","slug":"Spring-Cloud-源码分析","permalink":"http://xujin.org/tags/Spring-Cloud-源码分析/"}]},{"title":"Spring Cloud中@EnableEurekaClient源码分析","slug":"sc/sc-enableEurekaClient-annonation","date":"2016-11-06T06:00:00.000Z","updated":"2019-01-12T04:01:26.567Z","comments":true,"path":"sc/sc-enableEurekaClient-annonation/","link":"","permalink":"http://xujin.org/sc/sc-enableEurekaClient-annonation/","excerpt":"摘要:在这篇文章中主要介绍一下Spring Cloud中的@EnableEurekaClient注解，从源码的角度分析是如何work的，让大家能了解Spring Cloud如何通过@EnableEurekaClient注解对NetFlix Eureka Client进行封装为它所用。 NetFlix Eureka client简介NetFlix Eureka clientEureka client 负责与Eureka Server 配合向外提供注册与发现服务接口。首先看下eureka client是怎么定义，Netflix的 eureka client的行为在LookupService中定义，Lookup service for finding active instances，定义了，从outline中能看到起“规定”了如下几个最基本的方法。服务发现必须实现的基本类：com.netflix.discovery.shared.LookupService，可以自行查看源码。 Eureka client与Spring Cloud类关系 Eureka client与Spring Cloud Eureka Client类图，如下所示:在上图中，我加了前缀，带有S的是Spring Cloud封装的，带有N是NetFlix原生的。","text":"摘要:在这篇文章中主要介绍一下Spring Cloud中的@EnableEurekaClient注解，从源码的角度分析是如何work的，让大家能了解Spring Cloud如何通过@EnableEurekaClient注解对NetFlix Eureka Client进行封装为它所用。 NetFlix Eureka client简介NetFlix Eureka clientEureka client 负责与Eureka Server 配合向外提供注册与发现服务接口。首先看下eureka client是怎么定义，Netflix的 eureka client的行为在LookupService中定义，Lookup service for finding active instances，定义了，从outline中能看到起“规定”了如下几个最基本的方法。服务发现必须实现的基本类：com.netflix.discovery.shared.LookupService，可以自行查看源码。 Eureka client与Spring Cloud类关系 Eureka client与Spring Cloud Eureka Client类图，如下所示:在上图中，我加了前缀，带有S的是Spring Cloud封装的，带有N是NetFlix原生的。 org.springframework.cloud.netflix.eureka.EurekaDiscoveryClient中49行的eurekaClient就是com.netflix.discovery.EurekaClient，代码如下所示:12345678@RequiredArgsConstructorpublic class EurekaDiscoveryClient implements DiscoveryClient &#123; public static final String DESCRIPTION = \"Spring Cloud Eureka Discovery Client\"; private final EurekaInstanceConfig config; // Netflix中的Eureka Client private final EurekaClient eurekaClient; //其余省略&#125; Tips:org.springframework.cloud.netflix.eureka.EurekaDiscoveryClient实现了DiscoveryClient，并依赖于com.netflix.discovery.EurekaClient 点开com.netflix.discovery.EurekaClient查看代码，可以看出EurekaClient继承了LookupService并实现了EurekaClient接口。 1234@ImplementedBy(DiscoveryClient.class)public interface EurekaClient extends LookupService &#123; //其余省略&#125; com.netflix.discovery.DiscoveryClient是netflix使用的客户端，从其class的注释可以看到他主要做这几件事情：a) Registering the instance with Eureka Serverb) Renewalof the lease with Eureka Serverc) Cancellation of the lease from Eureka Server during shutdown 其中com.netflix.discovery.DiscoveryClient实现了com.netflix.discovery.EurekaClient,而spring Cloud中的org.springframework.cloud.netflix.eureka.EurekaDiscoveryClient，依赖于com.netflix.discovery.EurekaClient，因此Spring Cloud与NetFlix的关系由此联系到一起。12345678@Singletonpublic class DiscoveryClient implements EurekaClient &#123; private static final Logger logger = LoggerFactory.getLogger(DiscoveryClient.class); // Constants public static final String HTTP_X_DISCOVERY_ALLOW_REDIRECT = \"X-Discovery-AllowRedirect\"; //其余省略&#125; @EnableEurekaClient注解入口分析 在上面小节中，理清了NetFlix Eureka与Spring cloud中类的依赖关系，下面将以@EnableEurekaClient为入口，分析主要调用链中的类和方法。 @EnableEurekaClient使用 用过spring cloud的同学都知道，使用@EnableEurekaClient就能简单的开启Eureka Client中的功能，如下代码所示。123456789@EnableEurekaClient@SpringBootApplicationpublic class CloudEurekaClientApplication &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(CloudEurekaClientApplication.class).web(true).run(args); &#125;&#125; 通过@EnableEurekaClient这个简单的注解，在spring cloud应用启动的时候，就可以把EurekaDiscoveryClient注入，继而使用NetFlix提供的Eureka client。 打开EnableEurekaClient这个类，可以看到这个自定义的annotation @EnableEurekaClient里面没有内容。它的作用就是开启Eureka discovery的配置，正是通过这个标记，autoconfiguration就可以加载相关的Eureka类。那我们看下它是怎么做到的。 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@EnableDiscoveryClientpublic @interface EnableEurekaClient &#123;&#125; 在上述代码中，我们看到，EnableEurekaClient上面加入了另外一个注解@EnableDiscoveryClient，看看这个注解的代码如下所示: 123456789101112/** * Annotation to enable a DiscoveryClient implementation. * @author Spencer Gibb */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(EnableDiscoveryClientImportSelector.class)public @interface EnableDiscoveryClient &#123;&#125; 这个注解import了EnableDiscoveryClientImportSelector.class这样一个类，其实就是通过这个类来加载需要用到的bean。点开EnableDiscoveryClientImportSelector类，如下代码: 12345678910111213141516@Order(Ordered.LOWEST_PRECEDENCE - 100)public class EnableDiscoveryClientImportSelector extends SpringFactoryImportSelector&lt;EnableDiscoveryClient&gt; &#123; @Override protected boolean isEnabled() &#123; return new RelaxedPropertyResolver(getEnvironment()).getProperty( \"spring.cloud.discovery.enabled\", Boolean.class, Boolean.TRUE); &#125; @Override protected boolean hasDefaultFactory() &#123; return true; &#125;&#125; 看到这里有覆盖了父类SpringFactoryImportSelector的一个方法isEnabled，注意，默认是TRUE，也就是只要import了这个配置，就会enable。 在其父类org.springframework.cloud.commons.util.SpringFactoryImportSelector的String[] selectImports(AnnotationMetadata metadata)方法中正是根据这个标记类判定是否加载如下定义的类。在源码第59行，局部代码如下所示。1234567891011121314151617181920212223242526272829@Override public String[] selectImports(AnnotationMetadata metadata) &#123; if (!isEnabled()) &#123; return new String[0]; &#125; AnnotationAttributes attributes = AnnotationAttributes.fromMap( metadata.getAnnotationAttributes(this.annotationClass.getName(), true)); Assert.notNull(attributes, \"No \" + getSimpleName() + \" attributes found. Is \" + metadata.getClassName() + \" annotated with @\" + getSimpleName() + \"?\"); // Find all possible auto configuration classes, filtering duplicates List&lt;String&gt; factories = new ArrayList&lt;&gt;(new LinkedHashSet&lt;&gt;(SpringFactoriesLoader .loadFactoryNames(this.annotationClass, this.beanClassLoader))); if (factories.isEmpty() &amp;&amp; !hasDefaultFactory()) &#123; throw new IllegalStateException(\"Annotation @\" + getSimpleName() + \" found, but there are no implementations. Did you forget to include a starter?\"); &#125; if (factories.size() &gt; 1) &#123; // there should only ever be one DiscoveryClient, but there might be more than // one factory log.warn(\"More than one implementation \" + \"of @\" + getSimpleName() + \" (now relying on @Conditionals to pick one): \" + factories); &#125; return factories.toArray(new String[factories.size()]); &#125; 在源码中70-71行，即在org.springframework.core.io.support.SpringFactoriesLoader 中的109行的loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader)方法12345678910111213141516171819 public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); &#125; return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() + \"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); &#125;&#125; 实际调用loadFactoryNames其实加载META-INF/spring.factories下的class。12345 /*** The location to look for factories.* &lt;p&gt;Can be present in multiple JAR files. */ public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; 而在spring-cloud-netflix-eureka-client\\src\\main\\resources\\META-INF\\spring.factories中配置，用于加载一系列配置信息和Dependences Bean可以看到EnableAutoConfiguration的包含了EurekaClientConfigServerAutoConfiguration。1234567891011org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\\org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceAutoConfiguration,\\org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\\org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfigurationorg.springframework.cloud.bootstrap.BootstrapConfiguration=\\org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfigurationorg.springframework.cloud.client.discovery.EnableDiscoveryClient=\\org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration 打开org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration可以看到EurekaClientAutoConfiguration具体的注入信息。 具体@EnableEurekaClien注解开启之后，服务启动后，是服务怎么注册的请参考，下面链接：http://blog.xujin.org/sc/sc-eureka-register/ 其它源码分析链接 Spring Cloud中@EnableEurekaClient源码分析: http://blog.xujin.org/sc/sc-enableEurekaClient-annonation/ Spring Cloud Eureka服务注册源码分析： http://blog.xujin.org/sc/sc-eureka-register/ Spring Cloud Eureka服务续约(Renew)源码分析 http://blog.xujin.org/sc/sc-eureka-renew/ Spring Cloud Eureka服务下线(Cancel)源码分析 http://blog.xujin.org/sc/sc-eureka-cancle/","categories":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/categories/Spring-Cloud-Eureka/"}],"tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/tags/Spring-Cloud-Eureka/"},{"name":"Spring Cloud 源码分析","slug":"Spring-Cloud-源码分析","permalink":"http://xujin.org/tags/Spring-Cloud-源码分析/"}]},{"title":"Spring Cloud Eureka服务注册源码分析","slug":"sc/sc-eureka-register","date":"2016-11-01T06:00:00.000Z","updated":"2019-01-12T04:30:38.822Z","comments":true,"path":"sc/sc-eureka-register/","link":"","permalink":"http://xujin.org/sc/sc-eureka-register/","excerpt":"摘要:在上一篇中，介绍了Eureka的相关的知识，解释了Eureka为什么适合做服务发现和注册。接下来，在本篇文章将通过源码分析的方式，看一下Eureka是怎么work的。本章主要介绍Eureka的服务注册。那eureka client如何将本地服务的注册信息发送到远端的注册服务器eureka server上。通过下面的源码分析，看出Eureka Client的定时任务调用Eureka Server的REST接口，而Eureka接收到调用请求后会处理服务的注册以及Eureka Server中的数据同步的问题。 服务注册 服务注册，想必大家并不陌生，就是服务提供者启动的时候，把自己提供的服务信息，例如 服务名，IP，端口号，版本号等信息注册到注册中心，比如注册到ZK中。那eureka client如何将本地服务的注册信息发送到远端的注册服务器eureka server上。通过下面的源码分析，看出服务注册可以认为是Eureka client自己完成，不需要服务本身来关心。 Eureka Client的定时任务调用Eureka Server的提供接口实现思路其实也挺简单，在com.netflix.discovery.DiscoveryClient启动的时候，会初始化一个定时任务，定时的把本地的服务配置信息，即需要注册到远端的服务信息自动刷新到注册服务器上。首先看一下Eureka的代码，在spring-cloud-netflix-eureka-server工程中可以找到这个依赖eureka-client-1.4.11.jar查看代码可以看到，com.netflix.discovery.DiscoveryClient.java中的1240行可以看到Initializes all scheduled tasks，在1277行，可以看到InstanceInfoReplicator定时任务。","text":"摘要:在上一篇中，介绍了Eureka的相关的知识，解释了Eureka为什么适合做服务发现和注册。接下来，在本篇文章将通过源码分析的方式，看一下Eureka是怎么work的。本章主要介绍Eureka的服务注册。那eureka client如何将本地服务的注册信息发送到远端的注册服务器eureka server上。通过下面的源码分析，看出Eureka Client的定时任务调用Eureka Server的REST接口，而Eureka接收到调用请求后会处理服务的注册以及Eureka Server中的数据同步的问题。 服务注册 服务注册，想必大家并不陌生，就是服务提供者启动的时候，把自己提供的服务信息，例如 服务名，IP，端口号，版本号等信息注册到注册中心，比如注册到ZK中。那eureka client如何将本地服务的注册信息发送到远端的注册服务器eureka server上。通过下面的源码分析，看出服务注册可以认为是Eureka client自己完成，不需要服务本身来关心。 Eureka Client的定时任务调用Eureka Server的提供接口实现思路其实也挺简单，在com.netflix.discovery.DiscoveryClient启动的时候，会初始化一个定时任务，定时的把本地的服务配置信息，即需要注册到远端的服务信息自动刷新到注册服务器上。首先看一下Eureka的代码，在spring-cloud-netflix-eureka-server工程中可以找到这个依赖eureka-client-1.4.11.jar查看代码可以看到，com.netflix.discovery.DiscoveryClient.java中的1240行可以看到Initializes all scheduled tasks，在1277行，可以看到InstanceInfoReplicator定时任务。 在DiscoveryClient中初始化一个InstanceInfoReplicator，其实里面封装了以定时任务。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Initializes all scheduled tasks. */ private void initScheduledTasks() &#123; if (clientConfig.shouldFetchRegistry()) &#123; // registry cache refresh timer int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds(); int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound(); scheduler.schedule( new TimedSupervisorTask( \"cacheRefresh\", scheduler, cacheRefreshExecutor, registryFetchIntervalSeconds, TimeUnit.SECONDS, expBackOffBound, new CacheRefreshThread() ), registryFetchIntervalSeconds, TimeUnit.SECONDS); &#125; if (clientConfig.shouldRegisterWithEureka()) &#123; int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs(); int expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound(); logger.info(\"Starting heartbeat executor: \" + \"renew interval is: \" + renewalIntervalInSecs); // Heartbeat timer scheduler.schedule( new TimedSupervisorTask( \"heartbeat\", scheduler, heartbeatExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, new HeartbeatThread() ), renewalIntervalInSecs, TimeUnit.SECONDS); // InstanceInfo replicator /**************************封装了定时任务**********************************/ instanceInfoReplicator = new InstanceInfoReplicator( this, instanceInfo, clientConfig.getInstanceInfoReplicationIntervalSeconds(), 2); // burstSize statusChangeListener = new ApplicationInfoManager.StatusChangeListener() &#123; @Override public String getId() &#123; return \"statusChangeListener\"; &#125; @Override public void notify(StatusChangeEvent statusChangeEvent) &#123; if (InstanceStatus.DOWN == statusChangeEvent.getStatus() || InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123; // log at warn level if DOWN was involved logger.warn(\"Saw local status change event &#123;&#125;\", statusChangeEvent); &#125; else &#123; logger.info(\"Saw local status change event &#123;&#125;\", statusChangeEvent); &#125; instanceInfoReplicator.onDemandUpdate(); &#125; &#125;; if (clientConfig.shouldOnDemandUpdateStatusChange()) &#123; applicationInfoManager.registerStatusChangeListener(statusChangeListener); &#125; //点击可以查看start方法 instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds()); &#125; else &#123; logger.info(\"Not registering with Eureka server per configuration\"); &#125; &#125; 2.以initialDelayMs为间隔调用。1234567public void start(int initialDelayMs) &#123; if (started.compareAndSet(false, true)) &#123; instanceInfo.setIsDirty(); // for initial register Future next = scheduler.schedule(this, initialDelayMs, TimeUnit.SECONDS); scheduledPeriodicRef.set(next); &#125;&#125; 3.ScheduledExecutorService的task的具体业务定义在com.netflix.discovery.InstanceInfoReplicator.run()中，也就是InstanceInfoReplicator中的98-113行，可以看到调用了了client的register方法。1234567891011121314151617 public void run() &#123; try &#123; discoveryClient.refreshInstanceInfo(); Long dirtyTimestamp = instanceInfo.isDirtyWithTime(); if (dirtyTimestamp != null) &#123; //客户端发送hhtp注册请求的真正入口 discoveryClient.register(); instanceInfo.unsetIsDirty(dirtyTimestamp); &#125; &#125; catch (Throwable t) &#123; logger.warn(\"There was a problem with the instance info replicator\", t); &#125; finally &#123; Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS); scheduledPeriodicRef.set(next); &#125;&#125; 4.com.netflix.discovery.DiscoveryClient中的 register()方法，大概在811行。123456789101112131415161718/** * Register with the eureka service by making the appropriate REST call. */boolean register() throws Throwable &#123; logger.info(PREFIX + appPathIdentifier + \": registering service...\"); EurekaHttpResponse&lt;Void&gt; httpResponse; try &#123; //Eureka Client客户端，调用Eureka服务端的入口 httpResponse = eurekaTransport.registrationClient.register(instanceInfo); &#125; catch (Exception e) &#123; logger.warn(\"&#123;&#125; - registration failed &#123;&#125;\", PREFIX + appPathIdentifier, e.getMessage(), e); throw e; &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"&#123;&#125; - registration status: &#123;&#125;\", PREFIX + appPathIdentifier, httpResponse.getStatusCode()); &#125; return httpResponse.getStatusCode() == 204;&#125; Eureka server端接到请求后的处理打开spring-cloud-netflix-eureka-server工程或spring-cloud-netflix-eureka-client过程，找到相应的maven依赖jar，如下图所示 1.Eureka server服务端请求入口ApplicationResource.java文件中第183行，如下所示，可以看出Eureka是通过http post的方式去服务注册1234567891011121314151617181920212223242526272829303132333435363738394041424344@POST @Consumes(&#123;\"application/json\", \"application/xml\"&#125;) public Response addInstance(InstanceInfo info, @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) &#123; logger.debug(\"Registering instance &#123;&#125; (replication=&#123;&#125;)\", info.getId(), isReplication); // validate that the instanceinfo contains all the necessary required fields if (isBlank(info.getId())) &#123; return Response.status(400).entity(\"Missing instanceId\").build(); &#125; else if (isBlank(info.getHostName())) &#123; return Response.status(400).entity(\"Missing hostname\").build(); &#125; else if (isBlank(info.getAppName())) &#123; return Response.status(400).entity(\"Missing appName\").build(); &#125; else if (!appName.equals(info.getAppName())) &#123; return Response.status(400).entity(\"Mismatched appName, expecting \" + appName + \" but was \" + info.getAppName()).build(); &#125; else if (info.getDataCenterInfo() == null) &#123; return Response.status(400).entity(\"Missing dataCenterInfo\").build(); &#125; else if (info.getDataCenterInfo().getName() == null) &#123; return Response.status(400).entity(\"Missing dataCenterInfo Name\").build(); &#125; // handle cases where clients may be registering with bad DataCenterInfo with missing data DataCenterInfo dataCenterInfo = info.getDataCenterInfo(); if (dataCenterInfo instanceof UniqueIdentifier) &#123; String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId(); if (isBlank(dataCenterInfoId)) &#123; boolean experimental = \"true\".equalsIgnoreCase(serverConfig.getExperimental(\"registration.validation.dataCenterInfoId\")); if (experimental) &#123; String entity = \"DataCenterInfo of type \" + dataCenterInfo.getClass() + \" must contain a valid id\"; return Response.status(400).entity(entity).build(); &#125; else if (dataCenterInfo instanceof AmazonInfo) &#123; AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo; String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId); if (effectiveId == null) &#123; amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId()); &#125; &#125; else &#123; logger.warn(\"Registering DataCenterInfo of type &#123;&#125; without an appropriate id\", dataCenterInfo.getClass()); &#125; &#125; &#125; //InstanceRegistry.java文件中的88行的405行register方法 registry.register(info, \"true\".equals(isReplication)); return Response.status(204).build(); // 204 to be backwards compatible &#125; 2.如下图所示可以看到，从ApplicationResource.java怎么进入到PeerAwareInstanceRegistryImpl中的register方法InstanceRegistry.java文件中的88行，可以看到调用PeerAwareInstanceRegistryImpl中的405行register方法123456@Overridepublic void register(final InstanceInfo info, final boolean isReplication) &#123; handleRegistration(info, resolveInstanceLeaseDuration(info), isReplication); //调用PeerAwareInstanceRegistryImpl中的405行register方法 super.register(info, isReplication); &#125; 3.PeerAwareInstanceRegistryImpl中的405行register方法，代码如下所示。阅读方法上面的注释，就知道该方法是注册服务信息并把Eureka Server中的配置信息同步。执行注册的动作在com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.register(InstanceInfo info, boolean isReplication)中，具体代码如下所示： 12345678910111213141516171819202122/** * Registers the information about the &#123;@link InstanceInfo&#125; and replicates * this information to all peer eureka nodes. If this is replication event * from other replica nodes then it is not replicated. * * @param info * the &#123;@link InstanceInfo&#125; to be registered and replicated. * @param isReplication * true if this is a replication event from other replica nodes, * false otherwise. */ @Override public void register(final InstanceInfo info, final boolean isReplication) &#123; int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS; if (info.getLeaseInfo() != null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) &#123; leaseDuration = info.getLeaseInfo().getDurationInSecs(); &#125; //调用父类方法注册 super.register(info, leaseDuration, isReplication); // 同步Eureka中的服务信息 replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication); &#125; 4.AbstractInstanceRegistry.java中192行，可以看到Eureka真正的服务注册实现的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Registers a new instance with a given duration. * * @see com.netflix.eureka.lease.LeaseManager#register(java.lang.Object, int, boolean) */ public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) &#123; try &#123; read.lock(); Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName()); REGISTER.increment(isReplication); if (gMap == null) &#123; final ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = new ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;(); gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap); if (gMap == null) &#123; gMap = gNewMap; &#125; &#125; Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId()); // Retain the last dirty timestamp without overwriting it, if there is already a lease if (existingLease != null &amp;&amp; (existingLease.getHolder() != null)) &#123; Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp(); Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp(); logger.debug(\"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;\", existingLastDirtyTimestamp, registrationLastDirtyTimestamp); if (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123; logger.warn(\"There is an existing lease and the existing lease's dirty timestamp &#123;&#125; is greater\" + \" than the one that is being registered &#123;&#125;\", existingLastDirtyTimestamp, registrationLastDirtyTimestamp); logger.warn(\"Using the existing instanceInfo instead of the new instanceInfo as the registrant\"); registrant = existingLease.getHolder(); &#125; &#125; else &#123; // The lease does not exist and hence it is a new registration synchronized (lock) &#123; if (this.expectedNumberOfRenewsPerMin &gt; 0) &#123; // Since the client wants to cancel it, reduce the threshold // (1 // for 30 seconds, 2 for a minute) this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2; this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold()); &#125; &#125; logger.debug(\"No previous lease information found; it is new registration\"); &#125; Lease&lt;InstanceInfo&gt; lease = new Lease&lt;InstanceInfo&gt;(registrant, leaseDuration); if (existingLease != null) &#123; lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp()); &#125; gMap.put(registrant.getId(), lease); synchronized (recentRegisteredQueue) &#123; recentRegisteredQueue.add(new Pair&lt;Long, String&gt;( System.currentTimeMillis(), registrant.getAppName() + \"(\" + registrant.getId() + \")\")); &#125; // This is where the initial state transfer of overridden status happens if (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123; logger.debug(\"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the \" + \"overrides\", registrant.getOverriddenStatus(), registrant.getId()); if (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123; logger.info(\"Not found overridden id &#123;&#125; and hence adding it\", registrant.getId()); overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus()); &#125; &#125; InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId()); if (overriddenStatusFromMap != null) &#123; logger.info(\"Storing overridden status &#123;&#125; from map\", overriddenStatusFromMap); registrant.setOverriddenStatus(overriddenStatusFromMap); &#125; // Set the status based on the overridden status rules InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication); registrant.setStatusWithoutDirty(overriddenInstanceStatus); // If the lease is registered with UP status, set lease service up timestamp if (InstanceStatus.UP.equals(registrant.getStatus())) &#123; lease.serviceUp(); &#125; registrant.setActionType(ActionType.ADDED); recentlyChangedQueue.add(new RecentlyChangedItem(lease)); registrant.setLastUpdatedTimestamp(); invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress()); logger.info(\"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)\", registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication); &#125; finally &#123; read.unlock(); &#125; &#125; 更多的细节源码内容，大家可以自己阅读。 总结ApplicationResource类接收Http服务请求，调用PeerAwareInstanceRegistryImpl的register方法，PeerAwareInstanceRegistryImpl完成服务注册后，调用replicateToPeers向其它Eureka Server节点（Peer）做状态同步。如下图所示。","categories":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/categories/Spring-Cloud-Eureka/"}],"tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/tags/Spring-Cloud-Eureka/"},{"name":"Spring Cloud 源码分析","slug":"Spring-Cloud-源码分析","permalink":"http://xujin.org/tags/Spring-Cloud-源码分析/"}]},{"title":"Spring Cloud Netflix之Eureka下篇原理","slug":"sc/sc-eureka-mid","date":"2016-10-25T06:00:00.000Z","updated":"2019-01-12T04:04:14.487Z","comments":true,"path":"sc/sc-eureka-mid/","link":"","permalink":"http://xujin.org/sc/sc-eureka-mid/","excerpt":"摘要:本文主要介绍Eureka的工作原理，Eureka 组件分为两部分：Eureka server和 Eureka client。而客户端又分为 Application Service 客户端和 Application Client 客户端两种。Eureka 的工作机制每个 region 都有自己的 Eureka 服务器集群，每个 zone 至少要有一个 Eureka 服务器以应对 zone 瘫痪。","text":"摘要:本文主要介绍Eureka的工作原理，Eureka 组件分为两部分：Eureka server和 Eureka client。而客户端又分为 Application Service 客户端和 Application Client 客户端两种。Eureka 的工作机制每个 region 都有自己的 Eureka 服务器集群，每个 zone 至少要有一个 Eureka 服务器以应对 zone 瘫痪。 概述名词解释 Renew:我的理解是续约，为什么叫续约呢？Renew（服务续约）操作由Service Provider定期调用，类似于heartbeat。目的是隔一段时间Service Provider调用接口，告诉Eureka Server它还活着没挂，不要把它踢掉。通俗的说就是它们两之间的心跳检测，避免服务提供者被剔除掉。 Cancel（服务下线）一般在Service Provider挂了或shut down的时候调用，用来把自身的服务从Eureka Server中删除，以防客户端调用到不存在的服务。 Fetch Registries(获取注册信息)，Fetch Registries由Service Consumer(服务消费者)调用，用来获取Eureka Server上注册的服务info。 Eviction(剔除)Eviction（失效服务剔除）用来定期在Eureka Server检测失效的服务，检测标准就是超过一定时间没有Renew的服务。回顾Eureka架构图Eureka架构图Eureka架构图如下图所示，github地址:https://github.com/netflix/eurekadocument地址:https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance&ensp; 从图中我们可以看出，Eureka 组件分为两部分：Eureka server和 Eureka client。而客户端又分为 Application Service 客户端和 Application Client 客户端两种。Eureka 的工作机制每个 region 都有自己的 Eureka 服务器集群，每个 zone 至少要有一个 Eureka 服务器以应对 zone 瘫痪。&ensp; Application Service 在启动时注册到 Eureka 服务器，之后每 30 秒钟发送心跳以更新自身状态,即Renew(续约)。如果该客户端没能发送心跳更新，它将在 90 秒之后被其注册的 Eureka 服务器剔除，即Eviction(剔除)。来自任意 zone 的 Application Client 可以获取这些注册信息(每隔 30 秒查看一次)并依此定位到在任何区域可以给自己提供服务的提供者(即Fetch Registries)，进而进行远程调用。 服务提供者本身携带的Eureka Client既能服务注册，服务续约，也能通过client定位服务和调用其它的服务。 服务注册服务注册 服务注册源码分析，请参考:http://blog.xujin.org/sc/sc-eureka-register/ Renew(服务续约)服务续约 Renew操作会在Service Provider端定期发起，用来通知Eureka Server自己还活着。 这里有两个比较重要的配置需要注意一下：1eureka.instance.leaseRenewalIntervalInSeconds Renew频率。默认是30秒，也就是每30秒会向Eureka Server发起Renew操作。1eureka.instance.leaseExpirationDurationInSeconds 服务失效时间。默认是90秒，也就是如果Eureka Server在90秒内没有接收到来自Service Provider的Renew操作，就会把Service Provider剔除。","categories":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/categories/Spring-Cloud-Eureka/"}],"tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://xujin.org/tags/Spring-Cloud-Eureka/"}]},{"title":"什么是Spring Cloud Config？","slug":"sc/sc-config","date":"2016-10-19T06:00:00.000Z","updated":"2019-01-12T03:44:13.973Z","comments":true,"path":"sc/sc-config/","link":"","permalink":"http://xujin.org/sc/sc-config/","excerpt":"前言:在单体应用中，我们一般的做法是把Property和Code放在一起，没有什么问题。但是在分布式系统中，由于存在多个服务实例，需要分别管理到每个具体的服务工程中的配置，上线需要准备check list 并逐个检查每个上线的服务是否正确。在系统上线之后修改某个配置，需要重启服务。这样开发就相当麻烦。因此我们急需需要把分布式系统中的配置信息抽取出来统一管理，服务获取系统信息时有一个覆盖顺序:property–&gt; Evn—-&gt;配置中心。这样修改环境变量或者修改配置中心的配置就能取到最新的配置信息。在唯品会 Venus Framework中我们专门设计了这个功能。Spring cloud出现之后，避免了大家重复造轮子。 什么是 Spring Cloud Config ?其官方文档中对自己的定义是如下，官网连接:Spring Cloud Config。 Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system.With the Config Server you have a central place to manage external properties for applications across all environments. 简单来说，Spring Cloud Config就是我们通常意义上的配置中心 - 把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。","text":"前言:在单体应用中，我们一般的做法是把Property和Code放在一起，没有什么问题。但是在分布式系统中，由于存在多个服务实例，需要分别管理到每个具体的服务工程中的配置，上线需要准备check list 并逐个检查每个上线的服务是否正确。在系统上线之后修改某个配置，需要重启服务。这样开发就相当麻烦。因此我们急需需要把分布式系统中的配置信息抽取出来统一管理，服务获取系统信息时有一个覆盖顺序:property–&gt; Evn—-&gt;配置中心。这样修改环境变量或者修改配置中心的配置就能取到最新的配置信息。在唯品会 Venus Framework中我们专门设计了这个功能。Spring cloud出现之后，避免了大家重复造轮子。 什么是 Spring Cloud Config ?其官方文档中对自己的定义是如下，官网连接:Spring Cloud Config。 Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system.With the Config Server you have a central place to manage external properties for applications across all environments. 简单来说，Spring Cloud Config就是我们通常意义上的配置中心 - 把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。 另外，Spring Cloud Config提供基于以下3个维度的配置管理： 应用 这个比较好理解，每个配置都是属于某一个应用的 环境 每个配置都是区分环境的，如dev, test, prod等 版本 这个可能是一般的配置中心所缺乏的，就是对同一份配置的不同版本管理，比如:可以通过Git进行版本控制。 Spring Cloud Config提供版本的支持，也就是说对于一个应用的不同部署实例，可以从服务端获取到不同版本的配置，这对于一些特殊场景如：灰度发布，A/B测试等提供了很好的支持。 为什么会诞生Spring Cloud Config? 配置中心目前现状:不管是开源的(百度的disconf)，还是一些公司自己闭源投入使用的产品已经不少了，那为什么还会诞生Spring Cloud Config呢？ 在我看来，Spring Cloud Config在以下几方面还是有比较独特的优势，如下： 基于应用、环境、版本三个维度管理 这个在前面提过了，主要是有版本的支持 配置存储支持Git 这个就比较有特色了，后端基于Git存储，一方面程序员非常熟悉，另一方面在部署上会非常简单，而且借助于Git，天生就能非常好的支持版本 当然，它还支持其它的存储如本地文件、SVN等 和Spring无缝集成 它无缝支持Spring里面Environment和PropertySource的接口 所以对于已有的Spring应用程序的迁移成本非常低，在配置获取的接口上是完全一致的 Spring Cloud Config 入门例子上述节点主要介绍了Spring cloud的相关理论，大家对Spring Cloud Config有了一个初步的认识，接下来例子让大家感受一下Spring cloud config的魅力。 Overview 上图简要描述了一个普通Spring Cloud Config应用的场景。其中主要有以下几个组件： Config Client Client很好理解，就是使用了Spring Cloud Config的应用 Spring Cloud Config提供了基于Spring的客户端，应用只要在代码中引入Spring Cloud Config Client的jar包即可工作 Config Server Config Server是需要独立部署的一个web应用，它负责把git上的配置返回给客户端 Remote Git Repository 远程Git仓库，一般而言，我们会把配置放在一个远程仓库，通过现成的git客户端来管理配置 Local Git Repostiory Config Server的本地Git仓库 Config Server接到来自客户端的配置获取请求后，会先把远程仓库的配置clone到本地的临时目录，然后从临时目录读取配置并返回","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://xujin.org/categories/Spring-Cloud/"}],"tags":[{"name":"Spring Cloud Config","slug":"Spring-Cloud-Config","permalink":"http://xujin.org/tags/Spring-Cloud-Config/"}]},{"title":"关于SpringCloud中国社区以及国内使用情况","slug":"sc/springcloud","date":"2016-10-03T06:00:00.000Z","updated":"2019-01-12T04:32:01.781Z","comments":true,"path":"sc/springcloud/","link":"","permalink":"http://xujin.org/sc/springcloud/","excerpt":"Spring Cloud中国社区起源 其实当Spring Cloud项目刚在github上出现的时候，我就一直在关注其项目发展，到了2015年8月，由于个人兴趣研究Spring Cloud项目，由于国内相关文档较少，当时就想建立一个中国社区，于是就先把域名注册了，选中域名为springcloud.cn。 为什么要发起Spring Cloud中国社区 Spring Cloud发展到2016年，国内关注的人越来越多，但是相应学习交流的平台和材料比较分散，不利于学习交流，因此Spring Cloud中国社区应运而生。 Spring Cloud中国社区是国内首个Spring Cloud构建微服务架构的交流社区。我们致力于为Spring Boot或Spring Cloud技术人员提供分享和交流的平台，推动Spring Cloud在中国的普及和应用。 欢迎CTO、架构师、开发者等，在这里学习与交流使用Spring Cloud的实战经验。 目前QQ群人数:7000+,微信群:2000+. 扫描下面二维码或者微信搜索SpringCloud，关注社区公众号 Spring Cloud中国社区QQ群①:415028731 Spring cloud中国社区QQ群②:530321604 Spring Cloud中国社区官网:http://springcloud.cn Spring Cloud中国社区论坛:http://springcloud.cn Spring Cloud中国社区文档:http://docs.springcloud.cn spring cloud目前国内使用情况 中国联通子公司http://flp.baidu.com/feedland/video/?entry=box_searchbox_feed&amp;id=144115189637730162&amp;from=timeline&amp;isappinstalled=0","text":"Spring Cloud中国社区起源 其实当Spring Cloud项目刚在github上出现的时候，我就一直在关注其项目发展，到了2015年8月，由于个人兴趣研究Spring Cloud项目，由于国内相关文档较少，当时就想建立一个中国社区，于是就先把域名注册了，选中域名为springcloud.cn。 为什么要发起Spring Cloud中国社区 Spring Cloud发展到2016年，国内关注的人越来越多，但是相应学习交流的平台和材料比较分散，不利于学习交流，因此Spring Cloud中国社区应运而生。 Spring Cloud中国社区是国内首个Spring Cloud构建微服务架构的交流社区。我们致力于为Spring Boot或Spring Cloud技术人员提供分享和交流的平台，推动Spring Cloud在中国的普及和应用。 欢迎CTO、架构师、开发者等，在这里学习与交流使用Spring Cloud的实战经验。 目前QQ群人数:7000+,微信群:2000+. 扫描下面二维码或者微信搜索SpringCloud，关注社区公众号 Spring Cloud中国社区QQ群①:415028731 Spring cloud中国社区QQ群②:530321604 Spring Cloud中国社区官网:http://springcloud.cn Spring Cloud中国社区论坛:http://springcloud.cn Spring Cloud中国社区文档:http://docs.springcloud.cn spring cloud目前国内使用情况 中国联通子公司http://flp.baidu.com/feedland/video/?entry=box_searchbox_feed&amp;id=144115189637730162&amp;from=timeline&amp;isappinstalled=0 上海米么金服 指点无限（北京）科技有限公司 易保软件 目前在定制开发中 http://www.ebaotech.com/cn/ 广州简法网络 深圳睿云智合科技有限公司 持续交付产品基于Spring Cloud研发 http://www.wise2c.com 猪八戒网 上海云首科技有限公司 华为 整合netty进来用rpc 包括nerflix那套东西 需要注意的是sleuth traceid的传递需要自己写。tps在物理机上能突破20w 东软 南京云帐房网络科技有限公司 四众互联(北京)网络科技有限公司 深圳摩令技术科技有限公司 广州万表网 视觉中国 上海秦苍信息科技有限公司-买单侠 爱油科技(大连)有限公司爱油科技基于SpringCloud的微服务实践 广发银行 卖货郎(http://www.51mhl.com/） 拍拍贷 甘肃电信 新浪商品部 春秋航空 冰鉴科技 万达网络科技集团-共享商业平台-共享供应链中心 网易乐得技术团队 饿了么某技术团队 高阳捷迅信息科技–话费中心业务平台–凭证查询及收单系统数据在统计之中，会一直持续更新，敬请期待！ 捐赠社区发展捐赠社区 如果你觉得，Spring Cloud中国社区还可以，为了更好的发展，你可以捐赠社区，点击下面的打赏捐赠，捐赠的钱将用于社区发展和线下meeting up。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://xujin.org/categories/Spring-Cloud/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://xujin.org/tags/Spring-Cloud/"}]}]}