[{"author":"许进","categories":"Spring Boot Admin","content":" 摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-nacos-discovery进行整合使用。\n1. 整合概述 通过搭建一个Spring Boot Admin Server，并将其通过spring-cloud-starter-alibaba-nacos-discovery注册到Nacos Server中即可。 源码工程地址为:https://github.com/SoftwareKing/sba-nacos\n 说明本文使用的Spring Boot Admin的版本为2.1.2，Spring Cloud的版本为Greenwich.RELEASE，Spring Cloud Alibaba的版本为0.2.1.RELEASE。至于其它版本，请读者自行适配处理。\n 2. 创建sba-nacos工程 1.创建sba-nacos工程，添加maven依赖如下所示:\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;project xmlns=\u0026amp;quot;http://maven.apache.org/POM/4.0.0\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;modelVersion\u0026amp;gt;4.0.0\u0026amp;lt;/modelVersion\u0026amp;gt; \u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-parent\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.xujin.moss\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sba-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring.boot.admin.version\u0026amp;gt;2.1.2\u0026amp;lt;/spring.boot.admin.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;Greenwich.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-alibaba-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.2.1.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;de.codecentric\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-admin-starter-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring.boot.admin.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-web\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.jolokia\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;jolokia-core\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;finalName\u0026amp;gt;sba-nacos\u0026amp;lt;/finalName\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;/project\u0026amp;gt;   创 …","date":1568635200,"description":"本文主要讲解如何将`Spring Boot Admin`与Spring Cloud Alibaba中的`spring-cloud-starter-alibaba-nacos-discovery`进行整合使用","dir":"blog/sba-nacos/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"1fee7fce363eec566663cb4106b047af","permalink":"/blog/sba-nacos/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/sba-nacos/","summary":"摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-","tags":["Spring Boot Admin"],"title":"Spring Boot Admin和Nacos集成","type":"blog","url":"/blog/sba-nacos/","wordcount":1075},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中自定义使用GatewayFilter和GlobalFilter。\n1. Spring Cloud gateway的Filter Spring Cloud gateway中的Filter从接口实现上分为两种一种是GatewayFilter，另外一种是GlobalFilter。\n1.1 GatewayFilter与GlobalFilter的区别 区别用英语可以总结如下: At a high level global filters are applied to all routes, while a gateway filter will be applied to an individual route(s) \u0026amp;gt;在一个高的角度来看，Global filters会被应用到所有的路由上，而Gateway filter将应用到单个路由上或者一个分组的路由上。在下面的案例中将会进行说明。\n1.2 本文代码地址  https://github.com/SoftwareKing/sc-gateway/tree/master/ch2\n 2. GatewayFilter和GlobalFilter 2.1 GatewayFilter 2.1.1 什么是GatewayFilter Contract for interception-style, chained processing of Web requests that may be used to implement cross-cutting, application-agnostic requirements such as security, timeouts, and others. Specific to a Gateway Copied from WebFilter \u0026amp;gt;GatewayFilter是从WebFilter中Copy过来的，相当于一个Filter过滤器，可以对访问的URL过滤横切处理，应用场景比如超时，安全等。\n从Spring Cloud Gateway的源码中如下所示，可以看出GatewayFilter的使用场景:\n/** * Contract for interception-style, chained processing of Web requests that may * be used to implement cross-cutting, application-agnostic requirements such * as security, timeouts, and others. Specific to a Gateway * * Copied from WebFilter * * @author Rossen Stoyanchev * @since 5.0 */ public interface GatewayFilter extends ShortcutConfigurable { String NAME_KEY = \u0026amp;quot;name\u0026amp;quot;; String VALUE_KEY = \u0026amp;quot;value\u0026amp;quot;; /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link GatewayFilterChain}. * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); }   GatewayFilter和GlobalFilter两个接口中定义的方法一样都是Mono filter(ServerWebExchange exchange, GatewayFilterChain chain)，唯一的区别就是GatewayFilter继承了ShortcutConfigurable，GlobalFilter没有任何继承。\n 2.1.2 自定义GatewayFilter(Custom GatewayFilter) 如org.xujin.sc.filter.CustomFilter代码所示，通过自定义GatewayFilter对路由转发的处理时长统计。\npackage org.xujin.sc.filter; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.core.Ordered; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; /** * 统计某个或者某种路由的的处理时长 * @author xujin */ public class CustomFilter implements GatewayFilter, Ordered { private static final Log log = LogFactory.getLog(GatewayFilter.class); private static final String COUNT_Start_TIME = \u0026amp;quot;countStartTime\u0026amp;quot;; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { exchange.getAttributes().put(COUNT_Start_TIME, System.currentTimeMillis()); return chain.filter(exchange).then( Mono.fromRunnable(() -\u0026amp;gt; { Long startTime = …","date":1568635200,"description":"本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中自定义使用GatewayFilter和GlobalFilter","dir":"blog/scg-03/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"bc295a947c11a9a185c090e0014dc4dd","permalink":"/blog/scg-03/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-03/","summary":"摘要:本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway中的GatewayFilter和GlobalFilter","type":"blog","url":"/blog/scg-03/","wordcount":2441},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/* 和 zuul的默认路由规则http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/*差不多。\n1.Spring Gateway概述 1.1 什么是Spring Cloud Gateway Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n1.2 Spring Cloud Gateway的功能 Spring Cloud Gateway 的特征： * 基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0 动态路由 * Predicates 和 Filters 作用于特定路由 * 集成 Hystrix 断路器 * 集成 Spring Cloud DiscoveryClient * 易于编写的 Predicates 和 Filters * 限流 * 路径重写\n2. Spring Cloud Gateway的工程流程 客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。\n2.1 Pre和POST两种类型的过滤器 3.基于服务发现的默认路由规则 3.1 zuul和gateway的默认路由规则 3.1.1 zuul的默认路由规则 说明默认情况下，Zuul会代理所有注册到Eureka Server的微服务，并且Zuul的路由规则如下： http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/** 会被转发到serviceId对应的微服务。 http://localhost:8040/sc-zuul-first-provider/sc/order/2 3.1.2 gateway的默认路由规则 下面的案例中会演示：http://localhost:9000/SC-CONSUMER/hello/xujin \u0026amp;gt;http://Gateway_HOST:Gateway_PORT/大写的serviceId/**，其中微服务应用名默认大写访问。\n3.2 案例示例代码 https://github.com/SoftwareKing/sc-gateway/tree/master/ch1\n   模块 说明 端口     ch1-sc-consumer 服务消费者 8000   ch1-sc-eureka Eureka Server注册中心 8761   ch1-sc-gateway Spring Cloud Gateway Sever 9000   ch1-sc-provider 服务提供者 8001    3.2.1 ch1-sc-gateway工程说明 3.2.1.1 Maven依赖 Spring Cloud Gateway sever主要的maven依赖如下所示\n\u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt;  3.2.1.2 yml文件配置 spring: application: name: sc-gateway-server cloud: gateway: discovery: locator: enabled: true server: port: 9000 eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ logging: level: org.springframework.cloud.gateway: debug  配置说明：\n spring.cloud.gateway.discovery.locator.enabled：是否与服务发现组件进行结合，通过 serviceId 转发到具体的服务实例。默认为false，设为true便开启通过服务中心的自动根据 serviceId 创建路由的功能。\n  修改spring cloud gateway server监听的端口为9000\n  eureka.client.service-url.defaultZone: http://localhost:8761/eureka/,指定注册中心的地址，Spring Cloud Gateway从注册中心获取已经注册的服务列表。\n  logging.level.org.springframework.cloud.gateway: debug,开启spring-Cloud-gateway的日志级别为debug，方便debug调试。\n 3.3 启动测试 3.3.1 错误的路由规则访问 访问Spring Cloud Gateway对应的server，当访问http://localhost:9000/sc-consumer/hello/xujin的时候，报错如下所示，正确的Spring Cloud Gateway的默认路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/**\n2018-05-18 01:10:49.742 DEBUG 6462 --- [ctor-http-nio-5] …","date":1568635200,"description":"本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/* 和 zuul的默认路由规则http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/*差不多。","dir":"blog/scg-05/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"f4e10165d1ff5f623b0311c5575caeb3","permalink":"/blog/scg-05/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-05/","summary":"摘要:本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gat","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway基于服务发现的默认路由规则","type":"blog","url":"/blog/scg-05/","wordcount":2160},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。\n1. Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念: * 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 * 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 * 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。\n2. 什么是Before路由断言 Before路由断言工厂带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之前会成功匹配，否则不能成功匹配。\n3. Before路由断言工厂的案例 3.1 引入pom依赖 pom.xml依赖配置如下所示:\n\u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring-cloud.version\u0026amp;gt;Finchley.M9\u0026amp;lt;/spring-cloud.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring-cloud.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-devtools\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;runtime\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-test\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;test\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Milestones\u0026amp;lt;/name\u0026amp;gt; …","date":1568635200,"description":"在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就`抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway`，欢迎大家`加我微信Software_King`，进入Spring Cloud中国社区微信群交流","dir":"blog/scg-06/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"d0fba303626198b42f1309b342162467","permalink":"/blog/scg-06/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-06/","summary":"摘要:在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的Before路由断言工厂","type":"blog","url":"/blog/scg-06/","wordcount":1255},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。`本篇文章简单介绍如何实现Spring Cloud Gateway的动态路由。\n2. Spring Cloud Gateway简单的动态路由实现 Spring Cloud Gateway的官方文档并没有讲如何动态配置，查看 Spring Cloud Gateway的源码，发现在org.springframework.cloud.gateway.actuate.GatewayControllerEndpoint类中提供了动态配置的Rest接口，但是需要开启Gateway的端点，而且提供的功能不是很强大。通过参考和GatewayControllerEndpoint相关的代码，可以自己编码实际动态路由配置。 下面通过案例的方式去讲解怎么实现Gateway的动态路由配置。案例工程如ch18-7-gateway所示。\n 代码地址:https://github.com/SpringCloud/spring-cloud-code/blob/master/ch18-7/ch18-7-gateway\n 3. 简单动态路由的实现 3.1 新建Maven工程ch18-7-gateway 配置主要的核心依赖如代码清单18-33所示： 代码清单: ch18-7/ch18-7-gateway/pom.xml\n\u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt;  3.2 根据Spring Cloud Gateway的路由模型定义数据传输模型 分别创建GatewayRouteDefinition.java, GatewayPredicateDefinition.java, GatewayFilterDefinition.java这三个类。 (1) 创建路由定义模型如下代码清单18-34所示： 代码清单 18-34: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayRouteDefinition.java\npublic class GatewayRouteDefinition { //路由的Id private String id; //路由断言集合配置 private List\u0026amp;lt;GatewayPredicateDefinition\u0026amp;gt; predicates = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由过滤器集合配置 private List\u0026amp;lt;GatewayFilterDefinition\u0026amp;gt; filters = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由规则转发的目标uri private String uri; //路由执行的顺序 private int order = 0; //此处省略get和set方法 }  (2)创建过滤器定义模型,代码如代码清单18-35所示： 代码清单18-35: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayFilterDefinition.java\npublic class GatewayFilterDefinition { //Filter Name private String name; //对应的路由规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  (3)路由断言定义模型，代码如代码清单18-36所示: 代码清单18-36: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayPredicateDefinition.java\npublic class GatewayPredicateDefinition { //断言对应的Name private String name; //配置的断言规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  3.3 编写动态路由实现类 编写DynamicRouteServiceImpl并实现ApplicationEventPublisherAware接口，代码如代码清单18-37所示: ch18-37/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/route/DynamicRouteServiceImpl.java\n@Service public class DynamicRouteServiceImpl implements ApplicationEventPublisherAware { @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher …","date":1568635200,"description":"本文主要介绍了Spring Cloud Gateway的动态路由的简单实现方式","dir":"blog/scg-dmy-route/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"680d0fc1e514c0358efcb358f76e3aad","permalink":"/blog/scg-dmy-route/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-dmy-route/","summary":"1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的动态路由的简单实现方式","type":"blog","url":"/blog/scg-dmy-route/","wordcount":2175},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服务有两个版本，旧版本V1，新版本v2。在线上灰度的时候，需要通过网关动态实时推送，路由权重信息。比如95%的流量走服务v1版本，5%的流量走服务v2版本。\n issue: The Spring Cloud Gateway issue of Allow Rolling Deployments https://github.com/spring-cloud/spring-cloud-gateway/issues/67\n 1.2 Spring Cloud Gateway权重路由原理 Spring Cloud Gateway中提供了org.springframework.cloud.gateway.handler.predicate.WeightRoutePredicateFactory去实现根据分组设置权重进行路由，因此使用起来相对比较简单，有兴趣的可以debug阅读源码。\npublic class WeightRoutePredicateFactory extends AbstractRoutePredicateFactory\u0026amp;lt;WeightConfig\u0026amp;gt; implements ApplicationEventPublisherAware { private static final Log log = LogFactory.getLog(WeightRoutePredicateFactory.class); public static final String GROUP_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.group\u0026amp;quot;; public static final String WEIGHT_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.weight\u0026amp;quot;; private ApplicationEventPublisher publisher; public WeightRoutePredicateFactory() { super(WeightConfig.class); } @Override public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } @Override public List\u0026amp;lt;String\u0026amp;gt; shortcutFieldOrder() { return Arrays.asList(GROUP_KEY, WEIGHT_KEY); } @Override public String shortcutFieldPrefix() { return WeightConfig.CONFIG_PREFIX; } @Override public void beforeApply(WeightConfig config) { if (publisher != null) { publisher.publishEvent(new WeightDefinedEvent(this, config)); } } @Override public Predicate\u0026amp;lt;ServerWebExchange\u0026amp;gt; apply(WeightConfig config) { return exchange -\u0026amp;gt; { Map\u0026amp;lt;String, String\u0026amp;gt; weights = exchange.getAttributeOrDefault(WEIGHT_ATTR, Collections.emptyMap()); String routeId = exchange.getAttribute(GATEWAY_PREDICATE_ROUTE_ATTR); // all calculations and comparison against random num happened in // WeightCalculatorWebFilter String group = config.getGroup(); if (weights.containsKey(group)) { String chosenRoute = weights.get(group); if (log.isTraceEnabled()) { log.trace(\u0026amp;quot;in group weight: \u0026amp;quot;+ group + \u0026amp;quot;, current route: \u0026amp;quot; + routeId +\u0026amp;quot;, chosen route: \u0026amp;quot; + chosenRoute); } return routeId.equals(chosenRoute); } return false; }; } }  2.Spring Cloud Gateway中的权重路由案例 2.1 案例代码地址 https://github.com/SoftwareKing/sc-gateway/tree/master/ch4\n2.2 Spring Cloud Gateway Server说明 Spring Cloud Gateway will dispatch 95% of the requests to version 1 and 5% of the traffic to version 2 of a specified service, as shown by the following figure.\n我们通过在Spring Cloud Gateway中会配置不同的权重信息到不同URL上，Spring Cloud Gateway会根据我们配置的路由权重信息，将请求分发到不同的源服务组，权重信息如ch4/ch4-gateway中的application.yml所示，主要配置信息如下。\nspring: application: name: ch4-gateway cloud: gateway: routes: - id: service1_v1 uri: http://localhost:8081/v1 predicates: - Path=/test - Weight=service1, 95 - id: service1_v2 uri: http://localhost:8081/v2 predicates: - Path=/test - Weight=service1, 5   Weight=service1, 95，Weight=service1, 5就是路由的权重信息。\n 2.3 源服务 源服务在本案例中源服务如ch4-service-provider所示，主要提提供Gateway Server权重路由对应的后端源服务。因为比较简单因此不做详细说明，主要代码如下所示。 …","date":1568635200,"description":"本文主要通过运用Spring Cloud Gateway的WeightRoutePredicateFactory对URL进行权重路由。","dir":"blog/scg-02/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"871e57eed714194e7f86d5f3d20d9934","permalink":"/blog/scg-02/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":2,"relpermalink":"/blog/scg-02/","summary":"1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的权重路由","type":"blog","url":"/blog/scg-02/","wordcount":946},{"author":"许进","categories":"Spring Cloud","content":" 摘要: 随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring Cloud生态圈中的第二代组件的组合，仅代表个人看法。\n1. Spring Cloud第一代 Spring Cloud自从推出之后，给大家的感觉就是Spring Cloud做它最擅长的事，也就是高度抽象和封装，强强联手整合最优东西为我所用，比如Netflix开源的Eureka，Hystrix，Ribbon等。而且提供多种技术选型，态度中立而选最优。8天前也就是2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态。引发朋友圈的一些思考。\n 虽然Eureka，Hystrix等不再继续开发或维护，但是目前来说不影响使用，不管怎么说感谢开源，向Netflix公司的开源致敬。\n 随着Spring Cloud生态圈的发展与成长，Spring Cloud陆续推出了自己的一些组件，挑选主要组件说明如下表所示:\n   组件 来源 说明     Spring-cloud-openfeign 基于Feign的升级 服务之间调用的必备组件   spring-cloud-zuul 来源于Netflix Zuul 目前还在继续维护，但是已经有自己的Spring Cloud Gateway,不久将来逐渐淘汰   spring-cloud-eureka 集成于Netflix Eureka 目前还在跟随Spring Cloud版本升级维护，最终也会被替代   spring-cloud-config 自研 功能不足，国内使用其它配置中心替代，比如携程的Apollo   全链路监控(sleuth+zikpin或pinpont) sleuth自研，其它第三方 国内目前使用最多的是skywaling等上生产   spring-cloud-ribbon 来源于Netflix集成 ribbon目前还在跟随Spring Cloud版本维护中，目前孵化未来替代品spring-cloud-lb   Spring-cloud-hystrix 来源于Netflix集成 目前还在跟随Spring Cloud版本维护中目前已经孵化spring-cloud-r4j    2. Spring Cloud 第二代 Spring Cloud第一代和第二代的组件组合汇总，如下表所示。\n    Spring Cloud第一代 Spring Cloud第二代     网关 Spring Cloud Zuul Spring Cloud Gateway   注册中心 eureka(不再更新)，Consul,ZK 阿里Nacos，拍拍贷radar等可选   配置中心 spring cloud config 阿里Nacos，携程Apollo，随行付Config Keeper   客户端软负载均衡 Ribbon spring-cloud-loadbalancer   熔断器 Hystrix spring-cloud-r4j(Resilience4J)，阿里Sentinel     由于Zuul性能一般，zuul 2.x(一直跳票，虽最终开源）但是Spring Cloud官方已经推出Spring Cloud gateway,Spring Cloud中国社区很久之前已经证实，Spring Cloud将不会集成zuul 2.x，也就是说在不就未来Zuul将从Spring Cloud生态圈中退出。\n  ribbon由于不支持webFlux的负载均衡，Spring Cloud官方很早就在孵化器项目中孵化spring-cloud-loadbalancer，目前已经将代码合并到spring-cloud-common中，预计在Spring Cloud G版可以使用，预计2018年12月底realese。\n  至于Hystrix，Netflix在2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态，其实在之前Spring Cloud官方就在孵化spring-cloud-r4j.\n 3.开源项目的链接 本文所提到的开源项目链接汇总如下所示：\nhttps://github.com/alibaba/Sentinel\nhttps://github.com/spring-cloud-incubator/spring-cloud-r4j\n阿里Nacos-https://github.com/alibaba/nacos\n随行付Config-keeper-https://github.com/sxfad/config-keeper\nspring-cloud-loadbalancer\nhttps://github.com/ctripcorp/apollo\nhttps://github.com/apache/incubator-skywalking\n","date":1568635200,"description":"随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring Cloud生态圈中的第二代组件的组合，仅代表个人看法","dir":"blog/sc-2/","fuzzywordcount":1500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"02d95b1104da8ff37650da89b3170f26","permalink":"/blog/sc-2/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/sc-2/","summary":"摘要: 随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring","tags":["Spring Cloud"],"title":"Spring Cloud第二代","type":"blog","url":"/blog/sc-2/","wordcount":1472},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。本文是基于Spring Cloud Gateway的动态路由实现 基础之上编写，通过Nacos配置服务下发路由配置实现动态路由。\n2. Spring Cloud Gateway简单的动态路由实现 Spring Cloud Gateway的官方文档并没有讲如何动态配置，查看 Spring Cloud Gateway的源码，发现在org.springframework.cloud.gateway.actuate.GatewayControllerEndpoint类中提供了动态配置的Rest接口，但是需要开启Gateway的端点，而且提供的功能不是很强大。通过参考和GatewayControllerEndpoint相关的代码，可以自己编码实际动态路由配置。 下面通过案例的方式去讲解怎么通Nacos实现Spring Cloud Gateway的动态路由。案例工程如spring-cloud-gateway-nacos所示。\n 代码地址:https://github.com/SpringCloud/spring-cloud-gateway-nacos\n 3. 简单动态路由的实现 3.1 新建Maven工程sc-gateway-server 配置主要的核心依赖如代码清单所示： 代码清单: spring-cloud-gateway-nacos/sc-gateway-server/pom.xml\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.4.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;fastjson\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.2.47\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  3.2 根据Spring Cloud Gateway的路由模型定义数据传输模型 分别创建GatewayRouteDefinition.java, GatewayPredicateDefinition.java, GatewayFilterDefinition.java这三个类。 (1) 创建路由定义模型\npublic class GatewayRouteDefinition { //路由的Id private String id; //路由断言集合配置 private List\u0026amp;lt;GatewayPredicateDefinition\u0026amp;gt; predicates = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由过滤器集合配置 private List\u0026amp;lt;GatewayFilterDefinition\u0026amp;gt; filters = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由规则转发的目标uri private String uri; //路由执行的顺序 private int order = 0; //此处省略get和set方法 }  (2)创建过滤器定义模型\npublic class GatewayFilterDefinition { //Filter Name private String name; //对应的路由规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  (3)创建路由断言定义模型\npublic class GatewayPredicateDefinition { //断言对应的Name private String name; //配置的断言规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  3.3 编写动态路由实现类 编写DynamicRouteServiceImpl并实现ApplicationEventPublisherAware接口，代码如下所示\n@Service public class DynamicRouteServiceImpl implements ApplicationEventPublisherAware { @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher publisher; //增加路由 public String add(RouteDefinition definition) { routeDefinitionWriter.save(Mono.just(definition)).subscribe(); …","date":1568635200,"description":"本文主要介绍通过Nacos下发路由配置实现Spring Cloud Gateway的动态路由","dir":"blog/scg-nacos-01/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"969fce0835ece8dc960882e28fb219e5","permalink":"/blog/scg-nacos-01/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-nacos-01/","summary":"1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，","tags":["Spring Cloud Gateway"],"title":"使用Nacos实现Spring Cloud Gateway的动态路由","type":"blog","url":"/blog/scg-nacos-01/","wordcount":2494},{"author":"许进","categories":"Moss","content":" 摘要: 本文介绍了什么是Moss以及Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生产应用可配置多种服务上线通知工具，支持多种注册中心，比如Eureka，Consul，Nacos.支持动态连接注册中心进去切换进行服务治理操作。\n1.什么是Moss 1.1 什么是服务治理 服务治理，我也称之为微服务治理，是指用来管理微服务的整个生命周期。包括应用的创建，服务名的规范，服务的上下线，服务的迁移，整个服务的生老病死等方方面面的治理。\n1.2 Moss概述 Moss(莫斯)是服务治理平台的代号，取名灵感来自电影《流浪地球》中的莫斯(Moss),Moss是电影《流浪地球》中领航员号空间站的人工智能机器人-负责管理空间站所有事务以及流浪地球的计划，而Moss跟Boos一样，是所有微服务的老板，所有微服务的生命周期将归其统管。\n为什么会出现Moss？因为基于Spring Cloud的微服务体系，缺乏统一的可视化的纳管治理平台。\n Spring Cloud中国社区从2017年11月份，开始规划Spring Cloud Admin的开发和设计，专注于研究这个领域。 代码地址:https://github.com/SpringCloud/Moss\n #### 1.2.1 竞品分析\nMoss的竞品分析对比如下表所示:\n   对比选项 Spring Boot Admin Moss     服务画像 ❌ ✅   服务实例画像 ☑️ ✅   支持单Eureka ☑️ ✅   支持单Nacos ☑️ ✅   支持多Eureka，在线动态增加，删除,切换 ❌️ ✅   前端技术 Vue Ant Design Pro   支持Spring Boot 1.5.X和Spring Boot 2.0.X ☑️ ✅   服务调用拓扑 ❌ ✅   在线查看Jar依赖 ❌ ✅   服务归属(项目，Owner) ❌ ✅   服务和实例支持模糊查询 ❌ ✅   服务闪烁告警 ❌ ✅   服务评分打星 ❌ ✅   服务列表画像 ❌ ✅   服务实例列表画像 ❌ ✅   服务实例内部组件列表，使用哪些Spring Cloud组件 ❌ ✅     其中☑️表示功能相对较弱 ✅表示功能完整强大 ❌表示功能缺失\n 1.2.1 Moss RoadMap Roadmap 时间点：\n✅表示当前稳定可用版本\n   版本 Milestone 主要特性     ✅1.0.0.RELEASE 2019.4.21 稳定可用版本    1.2.2 Moss开发团队    姓名 角色 github地址     SoftwareKing Owner https://github.com/SoftwareKing   iShawnWang 前端开发 https://github.com/iShawnWang    1.3 Moss的功能  Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生产应用可配置多种服务上线通知工具，支持多种注册中心，比如Eureka，Consul，Nacos.支持动态连接注册中心进去切换进行服务治理操作。  1.3.1 服务画像  服务画像:  服务概要信息-包括服务实例数，UP数，DOWN数，OffLine数，服务归属的项目，归属的Owner等。 服务健康指标-展示服务的健康信息 服务请求映射-展示出服务对外提供的所有REST接口 服务调用链-展示服务的依赖调用拓扑 服务API监控-通过http trace和全链路监控对API进行监控 服务内部组件状态-内部组件的依赖，使用版本状态 服务性能指标-对服务进行QPS，性能指标收集打分 服务评级-自动根据评级规则对服务进行跑批评分打星。     PS: Spring Boot Admin服务墙，如上图所示，看完之后谁能告诉我，它的服务画像能画出什么来。 Moss的服务画像列表如下所示，对比显而易见！\n 1.3.2 服务实例画像  服务实例画像\n 实例调用拓扑-对接Skywalking，PinPoint等获取实例调用拓扑  实例Build信息-实例构建信息  实例Git提交信息-最后一次提交人的Git详细信息  Spring Cloud使用功能列表 实例的健康信息 实例的上下线Event信息  服务日志级别-查看应用的日志级别,根据需要调整日志级别打印对应日志级别的信息  环境配置-查看当前应用的环境配置信息 实例JMX信息-分类展示实例的JMX信息  查看JVM-实时展示应用实例的内存使用情况，GC次数，以及CPU和内存使用率  查看日志-增量实时获取应用的info日志或Error日志  查看线程-查看当前实例的线程情况  查看实例内部依赖-查看实例的内部Jar依赖情况，统计分析展示依赖拓扑等  HttpTrace-按时间展示http请求的轨迹信息，包括请求的路径，Response的状态，调用耗时等     支持GC Log日志查看   1.3.3 服务纳管 项目对应多个应用，每个应用由多个实例组成提供具体的服务，服务的生命周期管理需要可控，可追溯，可监控，可规范。 由Spring Cloud体系构建的微服务体系，应用名即服务名。服务纳管分为历史应用纳管和新应用纳管。\n 新应用纳管: 新应用使用Moss-Client，启动时连接Moss对应用名进行统一拦截check，从而规范应用名。 旧应用纳管: 旧应用引入对应的版本的Moss-Client，在Moss平台对其手动接入管理，录入应用名。  1.3.4 多注册中心支持 Moss通过注册中心接管Spring Cloud体系的微服务。支持动态连接注册中心，填注册中心的URL即可，快速接管服务。\n1.3.5 服务报表数据 Moss通过注册中心接管Spring Cloud体系的微服务。然后获取每个服务使用Spring Boot的版本和Spring Cloud的版本，Moss的接入率以报表数据展示。\n1.3.6 事件日志 1.3.7 元数据管理 1.3.9 Spring Cloud组件使用情况 2.Moss的架构设计 2.1 Moss的架构设计 Moss基于Spring Boot Admin 2.1.3版中的spring-boot-admin-server模块二次开发，基于可扩展思想。前端采用Ant Design Pro，采用Spring Boot+shiro+JWT+LDAP实现整个权限认证管理。通过Moss-Cloud-Adapter模块支持多注册中心，应用启动对应用名进行check是否规范。\n 实现细节后续补充\n 2.2 Moss的服务设计 Moss服务端主要自动探测EndPoint，代理EndPoint，对接各种注册中心，提供可视化的管理。\n2.3 Moss的客户端设计 moss客户端主要用于内置预设自研端点和管理配置信息，使接入方无感知接入。 \u0026amp;gt;实现细节后续补充\n2.3.1 Moss-Client Moss客户端支持两种Spring Boot版本，分别是Spring Boot 1.5.X和Spring Boot 2.X，使用只需引 …","date":1551787200,"description":"本文介绍了什么是Moss以及Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生产应用可配置多种服务上线通知工具，支持多种注册中心，比如Eureka，Consul，Nacos.支持动态连接注册中心进去切换进行服务治理操作\"","dir":"blog/moss-01/","fuzzywordcount":3400,"kind":"page","lang":"zh","lastmod":1551787200,"objectID":"d57df3f930018a6b44395a936c98645b","permalink":"/blog/moss-01/","publishdate":"2019-03-05T20:00:00+08:00","readingtime":7,"relpermalink":"/blog/moss-01/","summary":"摘要: 本文介绍了什么是Moss以及Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生","tags":["Moss"],"title":"Moss-让Spring Cloud应用“不再流浪”","type":"blog","url":"/blog/moss-01/","wordcount":3353},{"author":"admin","categories":"社区沙龙","content":"  活动主题：Spring Cloud中国社区沙龙-北京站 活动时间：2018-10-28 13:00 ~ 2018-10-28 17:30 活动形式：现场沙龙  介绍 Spring Cloud中国社区(http://springcloud.cn) 是国内基于Spring Cloud微服务体系创建的非盈利技术社区，发展至今刚好两周岁。自2016年10月份创建以来，在北京，上海，深圳，成都等地举办了多次技术沙龙，提供技术交流平台,帮助数万开发者快速学习Spring Cloud并用于生产。\n本次Spring Cloud中国社区两周年技术沙龙活动不仅有资深导师，还有现场抽奖福利相送哦，欢迎大家报名！\n更多访问:https://www.hdb.com/party/ayvf2.html\n","date":1539771600,"description":"Spring Cloud中国社区沙龙-北京站","dir":"activities/sofa-channel-1/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1539771600,"objectID":"5c79d2fac126784ef412f107470b2924","permalink":"/activities/sofa-channel-1/","publishdate":"2018-10-17T10:20:00Z","readingtime":1,"relpermalink":"/activities/sofa-channel-1/","summary":"活动主题：Spring Cloud中国社区沙龙-北京站 活动时间：2018-10-28 13:00 ~ 2018-10-28 17:30 活动形式：现场沙龙 介绍 Spring Cloud中国社区(htt","tags":["社区沙龙","Spring Cloud中国社区"],"title":"Spring Cloud中国社区沙龙-北京站","type":"activities","url":"/activities/sofa-channel-1/","wordcount":301},{"author":null,"categories":null,"content":" 1.Halo Framework概述 Halo Framework是基于DDD+CQRS+扩展点+流程编排的应用框架，致力于采用领域驱动的设计思想，规范控制程序员的随心所欲，从而解决软件的复杂性问题。\nHalo设计原则简单，即在高内聚，低耦合，可扩展，易理解的指导思想下，尽可能的贯彻面向对象的设计思想和领域驱动设计的原则。\n Halo Framework是基于DDD+CQRS+扩展点的应用框架，业务系统使用之自带光环!\n 2. Halo主要模块 Halo Framework的主要模块如下所示:\n Halo主要模块  CQRS：读写分离架构-所有请求封装为命令对象，通过Command Bus分发到命令处理器执行，通过Event和Event Bus等实现读写分离。\n** halo-DDD: 根据领域驱动设计思想，自定义注解 @Entity(实体)，@Factory(工厂), @DomainService(领域服务), @ValueObject(值对象)，@DomainRepository(资源库)，@DomainAbility(域能力) 等进行战术设计，落地DDD，实现 业务与业务 隔离。\n** halo-extension：基于扩展点的设计思想，自定义 @ExtensionPoint(扩展点注解) 和 @Extension(扩展注解), 实现 平台和插件 隔离。\n** halo-flow：基于流程编排思想，开发业务组件，编排应用内部已有业务资产，快速响应前台需求，久而久之形成大量可复用的业务组件库。\n Halo-tools  ** halo-codegen: 通过设计代码生成器, 快速生成最佳实践的基础代码和规范，提高开发效率和生产力，让业务开发人员专注于业务开发。\n3. Halo Framework设计 4. Halo Framework设计思想 Halo框架的主要思想是 流程组合节点,节点调用域服务,域服务包含若干域能力,域能力下若干个业务扩展。\n 业务包与平台分离的插件化架构： 平台提供插件包注册机制，实现业务方插件包在运行期的注册。业务代码只允许存在于插件包中， 与平台代码严格分离。业务包的代码配置库也与平台的代码库分离，通过二方包的方式，提供给容器加载\n 全链路统一的业务身份：\n平台需要能有按“业务身份”进行业务与业务之间逻辑隔离的能力，而不是传统SPI架构不区分业务身份， 简单过滤的方式。如何设计这个业务身份，也成为业务间隔离架构的关键。\n 管理域与运行域分离： 业务逻辑不能依靠运行期动态计算，要能在静态期进行定义并可视化呈现。 业务定义中出现的规则叠加冲突，也在静态器进行冲突决策。在运行期，严格按照静态器定义的业务规则、冲突决策策略执行。\n  ","date":1536710400,"description":"","dir":"projects/halo/overview/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1536710400,"objectID":"1c0eabc80d52d3a471789f3649e676a0","permalink":"/projects/halo/overview/","publishdate":"2018-09-12T00:00:00Z","readingtime":3,"relpermalink":"/projects/halo/overview/","summary":"1.Halo Framework概述 Halo Framework是基于DDD+CQRS+扩展点+流程编排的应用框架，致力于采用领域驱动的设计思想，规范控制程序员","tags":null,"title":"Halo 介绍","type":"projects","url":"/projects/halo/overview/","wordcount":1025},{"author":null,"categories":null,"content":" Q: Halo Flow有啥应用场景？ 应用内部流程编排\nQ: Halo DDD是什么？ Halo DDD是Halo框架对领域驱动的封装\n","date":1536710400,"description":"","dir":"projects/halo/faq/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1536710400,"objectID":"198a0121280caeeaef0d1e43aef5025f","permalink":"/projects/halo/faq/","publishdate":"2018-09-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo/faq/","summary":"Q: Halo Flow有啥应用场景？ 应用内部流程编排 Q: Halo DDD是什么？ Halo DDD是Halo框架对领域驱动的封装","tags":null,"title":"常见问题","type":"projects","url":"/projects/halo/faq/","wordcount":49},{"author":null,"categories":null,"content":"Halo使用了一些三方开源组件，他们分别是：\n一些主要依赖：\n Spring under Apache 2.0 license Spring Boot under Apache 2.0 license SLF4j under the MIT License  一些扩展依赖：\n nuxeo under Apache License, Version 2.0  \u0026amp;hellip; 其它整理中。\n","date":1536710400,"description":"","dir":"projects/halo/notice/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1536710400,"objectID":"bc49aaa37163a452cf0c4f82aabd62a8","permalink":"/projects/halo/notice/","publishdate":"2018-09-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo/notice/","summary":"Halo使用了一些三方开源组件，他们分别是： 一些主要依赖： Spring under Apache 2.0 license Spring Boot under Apache 2.0 license SLF4j under the MIT License 一些扩展依赖： nuxeo under Apache License, Version 2.0 \u0026hellip; 其它整理中。","tags":null,"title":"版权声明","type":"projects","url":"/projects/halo/notice/","wordcount":65},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter。\nzuul的Filter类型 Zuul 的 Filter 是通过filterType()方法来指定，一个 Filter 只能对应一种类型，要么是 “pre” 要么是“post”\nSpring Cloud Gateway的Filter类型 Spring Cloud Gateway 基于 Project Reactor 和 WebFlux，采用响应式编程风格，打开它的 Filter 的接口GatewayFilter你会发现它只有一个方法filter\nPre类型的Filter 在Spring Cloud Gateway源码中定义了一个Pre类型的Filter，code将会在chain.filter() 之前被执行,代码:AddRequestHeader\npackage org.springframework.cloud.gateway.filter.factory; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.http.server.reactive.ServerHttpRequest; /** * @author Spencer Gibb */ public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory { @Override public GatewayFilter apply(NameValueConfig config) { return (exchange, chain) -\u0026amp;gt; { ServerHttpRequest request = exchange.getRequest().mutate() .header(config.getName(), config.getValue()) .build(); return chain.filter(exchange.mutate().request(request).build()); }; } }  Post类型的Filter 对于Post类型的Filter，SetStatus 代码将会在chain.filter(exchange).then()里面的代码运行。\npublic class SetStatusGatewayFilterFactory extends AbstractGatewayFilterFactory\u0026amp;lt;SetStatusGatewayFilterFactory.Config\u0026amp;gt; { @Override public GatewayFilter apply(Config config) { final HttpStatus status = ServerWebExchangeUtils.parse(config.status); return (exchange, chain) -\u0026amp;gt; { return chain.filter(exchange).then(Mono.fromRunnable(() -\u0026amp;gt; { // check not really needed, since it is guarded in setStatusCode, // but it\u0026#39;s a good example if (!exchange.getResponse().isCommitted()) { setResponseStatus(exchange, status); } })); }; } }  ","date":1526904000,"description":"Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter","dir":"blog/scg-04/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1526904000,"objectID":"51ce631c9eb7e07fa908f9e83bcdebf9","permalink":"/blog/scg-04/","publishdate":"2018-05-21T20:00:00+08:00","readingtime":1,"relpermalink":"/blog/scg-04/","summary":"摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Fi","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway只有Pre和POST两种类型的Filter","type":"blog","url":"/blog/scg-04/","wordcount":491},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。\n1.Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念:\n 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。  2.什么是After路由断言 After Route Predicate Factory带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之后会成功匹配，否则不能成功匹配。\n3.After路由断言工厂的案例 3.1 引入pom依赖 pom.xml依赖配置如下所示:\n\u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring-cloud.version\u0026amp;gt;Finchley.M9\u0026amp;lt;/spring-cloud.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring-cloud.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-devtools\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;runtime\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-test\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;test\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Milestones\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/milestone\u0026amp;lt;/url\u0026amp;gt; …","date":1521979200,"description":"本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就`抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway`，欢迎大家`加我微信Software_King`，进入Spring Cloud中国社区微信群交流","dir":"blog/scg-07/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1521979200,"objectID":"e49c0b6cd3d0db865ccfa6efa135b616","permalink":"/blog/scg-07/","publishdate":"2018-03-25T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-07/","summary":"摘要:本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Sprin","tags":["Spring Cloud Gateway"],"title":" Spring Cloud Gateway的After路由断言工厂","type":"blog","url":"/blog/scg-07/","wordcount":1200},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.Spring Gateway概述 Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n2. Spring Cloud gateway请求入口分析 不管是Zuul，还是Spring Cloud Gateway还是基于Netty的自研网关，都会把请求进来的Request，或者返回的Response进行包装，转换提取为网关运行的上下文信息，而在Spring Cloud gateway中网关的上下文为ServerWebExchange。\n2.1 入口HttpServerRequest和HttpServerResponse转换 Spring Cloud Gateway的请求入口，org.springframework.http.server.reactive.ReactorHttpHandlerAdapter#apply方法\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; apply(HttpServerRequest request, HttpServerResponse response) { NettyDataBufferFactory bufferFactory = new NettyDataBufferFactory(response.alloc()); ServerHttpRequest adaptedRequest; ServerHttpResponse adaptedResponse; try { adaptedRequest = new ReactorServerHttpRequest(request, bufferFactory); adaptedResponse = new ReactorServerHttpResponse(response, bufferFactory); } catch (URISyntaxException ex) { logger.error(\u0026amp;quot;Invalid URL \u0026amp;quot; + ex.getMessage(), ex); response.status(HttpResponseStatus.BAD_REQUEST); return Mono.empty(); } if (adaptedRequest.getMethod() == HttpMethod.HEAD) { adaptedResponse = new HttpHeadResponseDecorator(adaptedResponse); } return this.httpHandler.handle(adaptedRequest, adaptedResponse) .doOnError(ex -\u0026amp;gt; logger.error(\u0026amp;quot;Handling completed with error\u0026amp;quot;, ex)) .doOnSuccess(aVoid -\u0026amp;gt; logger.debug(\u0026amp;quot;Handling completed with success\u0026amp;quot;)); }   PS，代码来源于spring-web-5.0.4.RELEASE.jar 此方法为Spring Cloud Gateway的请求入口方法，该方法的作用就是把接收到的HttpServerRequest或者最终需要返回的HttpServerResponse，包装转换为ReactorServerHttpRequest和ReactorServerHttpResponse。\n 2.2 构造Spring Cloud gateway的上下文ServerWebExchange 在org.springframework.web.server.adapter.HttpWebHandlerAdapter的182行，代码如下所示:\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; handle(ServerHttpRequest request, ServerHttpResponse response) { ServerWebExchange exchange = createExchange(request, response); return getDelegate().handle(exchange) .onErrorResume(ex -\u0026amp;gt; handleFailure(request, response, ex)) .then(Mono.defer(response::setComplete)); }   createExchange()将ServerHttpRequest ServerHttpResponse构建网关上下文ServerWebExchange。\n  PS:其中org.springframework.web.server.handler.WebHandlerDecorator.getDelegate()通过委托的方式获取一系列需要处理的WebHandler.\n 2.3 进入Filter链 org.springframework.cloud.gateway.handler.FilteringWebHandler#handle方法，即77行，代码如下所示\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; handle(ServerWebExchange exchange) { Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR); List\u0026amp;lt;GatewayFilter\u0026amp;gt; gatewayFilters = route.getFilters(); List\u0026amp;lt;GatewayFilter\u0026amp;gt; combined = new ArrayList\u0026amp;lt;\u0026amp;gt;(this.globalFilters); combined.addAll(gatewayFilters); //TODO: needed or cached? AnnotationAwareOrderComparator.sort(combined); logger.debug(\u0026amp;quot;Sorted gatewayFilterFactories: \u0026amp;quot;+ combined); return new DefaultGatewayFilterChain(combined).filter(exchange); }  2.4 执行Filter链 private static class DefaultGatewayFilterChain …","date":1521288000,"description":"本篇文章主要从源码的角度揭秘Spring Cloud Gateway的怎么处理请求流程。","dir":"blog/scg-08/","fuzzywordcount":1400,"kind":"page","lang":"zh","lastmod":1521288000,"objectID":"e4fe27d91a1a644302436dd065d99463","permalink":"/blog/scg-08/","publishdate":"2018-03-17T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-08/","summary":"1.Spring Gateway概述 Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway揭秘之处理请求流程","type":"blog","url":"/blog/scg-08/","wordcount":1382},{"author":null,"categories":null,"content":" Halo Boot概述 Halo Boot 是基于 Spring Boot 的研发框架，基于Spring Boot 的中间件轻量集成方案，与标准的 Spring Boot 工程无缝集成。其在完美集成各个中间件的前提下对用户提供了易用、统一的编程界面。\n","date":-62135596800,"description":"","dir":"projects/halo-boot/overview/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4eeda33d905f654466cf4fa4ba02a0cf","permalink":"/projects/halo-boot/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-boot/overview/","summary":"Halo Boot概述 Halo Boot 是基于 Spring Boot 的研发框架，基于Spring Boot 的中间件轻量集成方案，与标准的 Spring Boot 工程无缝集成。其在完美集成各个中间件的前提下对用","tags":null,"title":"Halo Boot 介绍","type":"projects","url":"/projects/halo-boot/overview/","wordcount":85},{"author":null,"categories":null,"content":" 1. Halo Tools概述 Enhances Your Productivity When Developing Applications Based on Halo Framework\n2. Halo Tools功能  1、支持向导式快速搭建中台应用和传统应 2、在应用Spring Application启动入口程序中中点击@Domain前面的图标可快速维护应用和中台业务域的关系 3、Halo Setting中的Halo Server支持自定义代码生成器服务端和Halo Admin中台可视化服务端URL 4、Halo Setting中的Data Source支持对数据源进行管理 5、Halo Setting中的Halo Config支持对插件的功能进行关闭和打开 6、右键支持创建13种Java类，包括创建实体，域服务，流程，资源库，Controller等 7、右键创建数据对象支持选择数据库连接和向导式创建工程支持选择数据库连接  3.安装 安装如下图所示:\n","date":-62135596800,"description":"","dir":"projects/halo-tools/overview/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f2c2227fd81b6c978dbd17420d245bff","permalink":"/projects/halo-tools/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-tools/overview/","summary":"1. Halo Tools概述 Enhances Your Productivity When Developing Applications Based on Halo Framework 2. Halo Tools功能 1、支持向导式快速搭建中台应用和传统应 2、在应用Spring Application启","tags":null,"title":"Halo Tools概述","type":"projects","url":"/projects/halo-tools/overview/","wordcount":335},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"IDEA插件-添加右键菜单 ","dir":"guides/idea-01/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2c09bbf8567719f35f684f9d554c7d00","permalink":"/guides/idea-01/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/idea-01/","summary":"","tags":null,"title":"IDEA插件-添加右键菜单","type":"guides","url":"/guides/idea-01/","wordcount":0},{"author":null,"categories":null,"content":" 1.什么是Moss 1.1 什么是服务治理 服务治理，我也称之为微服务治理，是指用来管理微服务的整个生命周期。包括应用的创建，服务名的规范，服务的上下线，服务的迁移，整个服务的生老病死等方方面面的治理。\n1.2 Moss概述 Moss(莫斯)是服务治理平台的代号，取名灵感来自电影《流浪地球》中的莫斯(Moss),Moss是电影《流浪地球》中领航员号空间站的人工智能机器人-负责管理空间站所有事务以及流浪地球的计划，而Moss跟Boos一样，是所有微服务的老板，所有微服务的生命周期将归其统管。\n为什么会出现Moss？因为基于Spring Cloud的微服务体系，缺乏统一的可视化的纳管治理平台。\n Spring Cloud中国社区从2017年11月份，开始规划Spring Cloud Admin的开发和设计，专注于研究这个领域。 代码地址:https://github.com/SpringCloud/Moss\n #### 1.2.1 竞品分析\nMoss的竞品分析对比如下表所示:\n   对比选项 Spring Boot Admin Moss     服务画像 ❌ ✅   服务实例画像 ☑️ ✅   支持单Eureka ☑️ ✅   支持单Nacos ☑️ ✅   支持多Eureka，在线动态增加，删除,切换 ❌️ ✅   前端技术 Vue Ant Design Pro   支持Spring Boot 1.5.X和Spring Boot 2.0.X ☑️ ✅   服务调用拓扑 ❌ ✅   在线查看Jar依赖 ❌ ✅   服务归属(项目，Owner) ❌ ✅   服务和实例支持模糊查询 ❌ ✅   服务闪烁告警 ❌ ✅   服务评分打星 ❌ ✅   服务列表画像 ❌ ✅   服务实例列表画像 ❌ ✅   服务实例内部组件列表，使用哪些Spring Cloud组件 ❌ ✅     其中☑️表示功能相对较弱 ✅表示功能完整强大 ❌表示功能缺失\n 1.2.1 Moss RoadMap Roadmap 时间点：\n✅表示当前稳定可用版本\n   版本 Milestone 主要特性     ✅1.0.0.RELEASE 2019.4.21 稳定可用版本    1.2.2 Moss开发团队    姓名 角色 github地址     SoftwareKing Owner https://github.com/SoftwareKing   iShawnWang 前端开发 https://github.com/iShawnWang    1.3 Moss的功能  Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生产应用可配置多种服务上线通知工具，支持多种注册中心，比如Eureka，Consul，Nacos.支持动态连接注册中心进去切换进行服务治理操作。  1.3.1 服务画像  服务画像:  服务概要信息-包括服务实例数，UP数，DOWN数，OffLine数，服务归属的项目，归属的Owner等。 服务健康指标-展示服务的健康信息 服务请求映射-展示出服务对外提供的所有REST接口 服务调用链-展示服务的依赖调用拓扑 服务API监控-通过http trace和全链路监控对API进行监控 服务内部组件状态-内部组件的依赖，使用版本状态 服务性能指标-对服务进行QPS，性能指标收集打分 服务评级-自动根据评级规则对服务进行跑批评分打星。     PS: Spring Boot Admin服务墙，如上图所示，看完之后谁能告诉我，它的服务画像能画出什么来。 Moss的服务画像列表如下所示，对比显而易见！\n 1.3.2 服务实例画像  服务实例画像\n 实例调用拓扑-对接Skywalking，PinPoint等获取实例调用拓扑  实例Build信息-实例构建信息  实例Git提交信息-最后一次提交人的Git详细信息  Spring Cloud使用功能列表 实例的健康信息 实例的上下线Event信息  服务日志级别-查看应用的日志级别,根据需要调整日志级别打印对应日志级别的信息  环境配置-查看当前应用的环境配置信息 实例JMX信息-分类展示实例的JMX信息  查看JVM-实时展示应用实例的内存使用情况，GC次数，以及CPU和内存使用率  查看日志-增量实时获取应用的info日志或Error日志  查看线程-查看当前实例的线程情况  查看实例内部依赖-查看实例的内部Jar依赖情况，统计分析展示依赖拓扑等  HttpTrace-按时间展示http请求的轨迹信息，包括请求的路径，Response的状态，调用耗时等     支持GC Log日志查看   1.3.3 服务纳管 项目对应多个应用，每个应用由多个实例组成提供具体的服务，服务的生命周期管理需要可控，可追溯，可监控，可规范。 由Spring Cloud体系构建的微服务体系，应用名即服务名。服务纳管分为历史应用纳管和新应用纳管。\n 新应用纳管: 新应用使用Moss-Client，启动时连接Moss对应用名进行统一拦截check，从而规范应用名。 旧应用纳管: 旧应用引入对应的版本的Moss-Client，在Moss平台对其手动接入管理，录入应用名。  1.3.4 多注册中心支持 Moss通过注册中心接管Spring Cloud体系的微服务。支持动态连接注册中心，填注册中心的URL即可，快速接管服务。\n1.3.5 服务报表数据 Moss通过注册中心接管Spring Cloud体系的微服务。然后获取每个服务使用Spring Boot的版本和Spring Cloud的版本，Moss的接入率以报表数据展示。\n1.3.6 事件日志 1.3.7 元数据管理 1.3.9 Spring Cloud组件使用情况 2.Moss的架构设计 2.1 Moss的架构设计 Moss基于Spring Boot Admin 2.1.3版中的spring-boot-admin-server模块二次开发，基于可扩展思想。前端采用Ant Design Pro，采用Spring Boot+shiro+JWT+LDAP实现整个权限认证管理。通过Moss-Cloud-Adapter模块支持多注册中心，应用启动对应用名进行check是否规范。\n 实现细节后续补充\n 2.2 Moss的服务设计 Moss服务端主要自动探测EndPoint，代理EndPoint，对接各种注册中心，提供可视化的管理。\n2.3 Moss的客户端设计 moss客户端主要用于内置预设自研端点和管理配置信息，使接入方无感知接入。 \u0026amp;gt;实现细节后续补充\n2.3.1 Moss-Client Moss客户端支持两种Spring Boot版本，分别是Spring Boot 1.5.X和Spring Boot 2.X，使用只需引入moss-client-starter即可。示例2.x的客户端如下所示。\n1.引入moss-client-starter\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.xujin.moss\u0026amp;lt;/groupId\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/moss/overview/","fuzzywordcount":3300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2d9d19f8650bf36febacb47972512b05","permalink":"/projects/moss/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":7,"relpermalink":"/projects/moss/overview/","summary":"1.什么是Moss 1.1 什么是服务治理 服务治理，我也称之为微服务治理，是指用来管理微服务的整个生命周期。包括应用的创建，服务名的规范，服务的上下","tags":null,"title":"Moss(莫斯) 介绍","type":"projects","url":"/projects/moss/overview/","wordcount":3212},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"本指南将基于 SOFADashboard 的 ARK 管控能力来实现 SOFAArk 提供的合并部署和动态模块推送的功能。","dir":"guides/kc-sofastack-dynamic-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8bfd4a50e21ce9fc867b1cf18a8c9af3","permalink":"/guides/kc-sofastack-dynamic-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-sofastack-dynamic-demo/","summary":"","tags":null,"title":"SOFABoot 动态模块实践","type":"guides","url":"/guides/kc-sofastack-dynamic-demo/","wordcount":0},{"author":null,"categories":null,"content":" 摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-nacos-discovery进行整合使用。\n1. 整合概述 通过搭建一个Spring Boot Admin Server，并将其通过spring-cloud-starter-alibaba-nacos-discovery注册到Nacos Server中即可。 源码工程地址为:https://github.com/SoftwareKing/sba-nacos\n 说明本文使用的Spring Boot Admin的版本为2.1.2，Spring Cloud的版本为Greenwich.RELEASE，Spring Cloud Alibaba的版本为0.2.1.RELEASE。至于其它版本，请读者自行适配处理。\n 2. 创建sba-nacos工程 1.创建sba-nacos工程，添加maven依赖如下所示:\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;project xmlns=\u0026amp;quot;http://maven.apache.org/POM/4.0.0\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;modelVersion\u0026amp;gt;4.0.0\u0026amp;lt;/modelVersion\u0026amp;gt; \u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-parent\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.xujin.moss\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sba-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring.boot.admin.version\u0026amp;gt;2.1.2\u0026amp;lt;/spring.boot.admin.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;Greenwich.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-alibaba-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.2.1.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;de.codecentric\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-admin-starter-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring.boot.admin.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-web\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.jolokia\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;jolokia-core\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;finalName\u0026amp;gt;sba-nacos\u0026amp;lt;/finalName\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;/project\u0026amp;gt;   创 …","date":-62135596800,"description":"本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-nacos-discovery进行整合使用","dir":"guides/sba-nacos/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"bc2998d12b565d711c797ece64e9c57b","permalink":"/guides/sba-nacos/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/guides/sba-nacos/","summary":"摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-","tags":null,"title":"Spring Boot Admin和Nacos集成","type":"guides","url":"/guides/sba-nacos/","wordcount":1075},{"author":null,"categories":null,"content":" 1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服务有两个版本，旧版本V1，新版本v2。在线上灰度的时候，需要通过网关动态实时推送，路由权重信息。比如95%的流量走服务v1版本，5%的流量走服务v2版本。\n issue: The Spring Cloud Gateway issue of Allow Rolling Deployments https://github.com/spring-cloud/spring-cloud-gateway/issues/67\n 1.2 Spring Cloud Gateway权重路由原理 Spring Cloud Gateway中提供了org.springframework.cloud.gateway.handler.predicate.WeightRoutePredicateFactory去实现根据分组设置权重进行路由，因此使用起来相对比较简单，有兴趣的可以debug阅读源码。\npublic class WeightRoutePredicateFactory extends AbstractRoutePredicateFactory\u0026amp;lt;WeightConfig\u0026amp;gt; implements ApplicationEventPublisherAware { private static final Log log = LogFactory.getLog(WeightRoutePredicateFactory.class); public static final String GROUP_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.group\u0026amp;quot;; public static final String WEIGHT_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.weight\u0026amp;quot;; private ApplicationEventPublisher publisher; public WeightRoutePredicateFactory() { super(WeightConfig.class); } @Override public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } @Override public List\u0026amp;lt;String\u0026amp;gt; shortcutFieldOrder() { return Arrays.asList(GROUP_KEY, WEIGHT_KEY); } @Override public String shortcutFieldPrefix() { return WeightConfig.CONFIG_PREFIX; } @Override public void beforeApply(WeightConfig config) { if (publisher != null) { publisher.publishEvent(new WeightDefinedEvent(this, config)); } } @Override public Predicate\u0026amp;lt;ServerWebExchange\u0026amp;gt; apply(WeightConfig config) { return exchange -\u0026amp;gt; { Map\u0026amp;lt;String, String\u0026amp;gt; weights = exchange.getAttributeOrDefault(WEIGHT_ATTR, Collections.emptyMap()); String routeId = exchange.getAttribute(GATEWAY_PREDICATE_ROUTE_ATTR); // all calculations and comparison against random num happened in // WeightCalculatorWebFilter String group = config.getGroup(); if (weights.containsKey(group)) { String chosenRoute = weights.get(group); if (log.isTraceEnabled()) { log.trace(\u0026amp;quot;in group weight: \u0026amp;quot;+ group + \u0026amp;quot;, current route: \u0026amp;quot; + routeId +\u0026amp;quot;, chosen route: \u0026amp;quot; + chosenRoute); } return routeId.equals(chosenRoute); } return false; }; } }  2.Spring Cloud Gateway中的权重路由案例 2.1 案例代码地址 https://github.com/SoftwareKing/sc-gateway/tree/master/ch4\n2.2 Spring Cloud Gateway Server说明 Spring Cloud Gateway will dispatch 95% of the requests to version 1 and 5% of the traffic to version 2 of a specified service, as shown by the following figure.\n我们通过在Spring Cloud Gateway中会配置不同的权重信息到不同URL上，Spring Cloud Gateway会根据我们配置的路由权重信息，将请求分发到不同的源服务组，权重信息如ch4/ch4-gateway中的application.yml所示，主要配置信息如下。\nspring: application: name: ch4-gateway cloud: gateway: routes: - id: service1_v1 uri: http://localhost:8081/v1 predicates: - Path=/test - Weight=service1, 95 - id: service1_v2 uri: http://localhost:8081/v2 predicates: - Path=/test - Weight=service1, 5   Weight=service1, 95，Weight=service1, 5就是路由的权重信息。\n 2.3 源服务 源服务在本案例中源服务如ch4-service-provider所示，主要提提供Gateway Server权重路由对应的后端源服务。因为比较简单因此不做详细说明，主要代码如下所示。 …","date":-62135596800,"description":"Spring Cloud Gateway的权重路由","dir":"guides/sc-gw-01/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"40cf805761911f0efd6ac46a334b019a","permalink":"/guides/sc-gw-01/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/guides/sc-gw-01/","summary":"1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服","tags":null,"title":"Spring Cloud Gateway的权重路由","type":"guides","url":"/guides/sc-gw-01/","wordcount":946},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"使用该指南您可以体验到快速创建 Serveless 应用、根据业务请求秒级 0-1-N 自动伸缩、通过日志查看器快速排错、按时间触发应用等产品新功能。","dir":"guides/kc-serverless-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f355d1b598fed47b730bd74ad25f3683","permalink":"/guides/kc-serverless-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-serverless-demo/","summary":"","tags":null,"title":"基于 Serverless 轻松构建云上应用","type":"guides","url":"/guides/kc-serverless-demo/","wordcount":0},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"","dir":"projects/halo/quick-start/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e44de85a2e3f1a79945627fd3c6c5023","permalink":"/projects/halo/quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/projects/halo/quick-start/","summary":"","tags":null,"title":"快速开始","type":"projects","url":"/projects/halo/quick-start/","wordcount":0}]