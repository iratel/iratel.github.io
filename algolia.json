[{"author":"许进","categories":"Spring Boot Admin","content":" 摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-nacos-discovery进行整合使用。\n1. 整合概述 通过搭建一个Spring Boot Admin Server，并将其通过spring-cloud-starter-alibaba-nacos-discovery注册到Nacos Server中即可。 源码工程地址为:https://github.com/SoftwareKing/sba-nacos\n 说明本文使用的Spring Boot Admin的版本为2.1.2，Spring Cloud的版本为Greenwich.RELEASE，Spring Cloud Alibaba的版本为0.2.1.RELEASE。至于其它版本，请读者自行适配处理。\n 2. 创建sba-nacos工程 1.创建sba-nacos工程，添加maven依赖如下所示:\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;project xmlns=\u0026amp;quot;http://maven.apache.org/POM/4.0.0\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;modelVersion\u0026amp;gt;4.0.0\u0026amp;lt;/modelVersion\u0026amp;gt; \u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-parent\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.xujin.moss\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sba-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring.boot.admin.version\u0026amp;gt;2.1.2\u0026amp;lt;/spring.boot.admin.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;Greenwich.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-alibaba-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.2.1.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;de.codecentric\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-admin-starter-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring.boot.admin.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-web\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.jolokia\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;jolokia-core\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;finalName\u0026amp;gt;sba-nacos\u0026amp;lt;/finalName\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;/project\u0026amp;gt;   创 …","date":1568635200,"description":"本文主要讲解如何将`Spring Boot Admin`与Spring Cloud Alibaba中的`spring-cloud-starter-alibaba-nacos-discovery`进行整合使用","dir":"blog/sba-nacos/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"1fee7fce363eec566663cb4106b047af","permalink":"/blog/sba-nacos/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/sba-nacos/","summary":"摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-","tags":["Spring Boot Admin"],"title":"Spring Boot Admin和Nacos集成","type":"blog","url":"/blog/sba-nacos/","wordcount":1075},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中自定义使用GatewayFilter和GlobalFilter。\n1. Spring Cloud gateway的Filter Spring Cloud gateway中的Filter从接口实现上分为两种一种是GatewayFilter，另外一种是GlobalFilter。\n1.1 GatewayFilter与GlobalFilter的区别 区别用英语可以总结如下: At a high level global filters are applied to all routes, while a gateway filter will be applied to an individual route(s) \u0026amp;gt;在一个高的角度来看，Global filters会被应用到所有的路由上，而Gateway filter将应用到单个路由上或者一个分组的路由上。在下面的案例中将会进行说明。\n1.2 本文代码地址  https://github.com/SoftwareKing/sc-gateway/tree/master/ch2\n 2. GatewayFilter和GlobalFilter 2.1 GatewayFilter 2.1.1 什么是GatewayFilter Contract for interception-style, chained processing of Web requests that may be used to implement cross-cutting, application-agnostic requirements such as security, timeouts, and others. Specific to a Gateway Copied from WebFilter \u0026amp;gt;GatewayFilter是从WebFilter中Copy过来的，相当于一个Filter过滤器，可以对访问的URL过滤横切处理，应用场景比如超时，安全等。\n从Spring Cloud Gateway的源码中如下所示，可以看出GatewayFilter的使用场景:\n/** * Contract for interception-style, chained processing of Web requests that may * be used to implement cross-cutting, application-agnostic requirements such * as security, timeouts, and others. Specific to a Gateway * * Copied from WebFilter * * @author Rossen Stoyanchev * @since 5.0 */ public interface GatewayFilter extends ShortcutConfigurable { String NAME_KEY = \u0026amp;quot;name\u0026amp;quot;; String VALUE_KEY = \u0026amp;quot;value\u0026amp;quot;; /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link GatewayFilterChain}. * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); }   GatewayFilter和GlobalFilter两个接口中定义的方法一样都是Mono filter(ServerWebExchange exchange, GatewayFilterChain chain)，唯一的区别就是GatewayFilter继承了ShortcutConfigurable，GlobalFilter没有任何继承。\n 2.1.2 自定义GatewayFilter(Custom GatewayFilter) 如org.xujin.sc.filter.CustomFilter代码所示，通过自定义GatewayFilter对路由转发的处理时长统计。\npackage org.xujin.sc.filter; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.core.Ordered; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; /** * 统计某个或者某种路由的的处理时长 * @author xujin */ public class CustomFilter implements GatewayFilter, Ordered { private static final Log log = LogFactory.getLog(GatewayFilter.class); private static final String COUNT_Start_TIME = \u0026amp;quot;countStartTime\u0026amp;quot;; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { exchange.getAttributes().put(COUNT_Start_TIME, System.currentTimeMillis()); return chain.filter(exchange).then( Mono.fromRunnable(() -\u0026amp;gt; { Long startTime = …","date":1568635200,"description":"本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中自定义使用GatewayFilter和GlobalFilter","dir":"blog/scg-03/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"bc295a947c11a9a185c090e0014dc4dd","permalink":"/blog/scg-03/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-03/","summary":"摘要:本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway中的GatewayFilter和GlobalFilter","type":"blog","url":"/blog/scg-03/","wordcount":2441},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/* 和 zuul的默认路由规则http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/*差不多。\n1.Spring Gateway概述 1.1 什么是Spring Cloud Gateway Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n1.2 Spring Cloud Gateway的功能 Spring Cloud Gateway 的特征： * 基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0 动态路由 * Predicates 和 Filters 作用于特定路由 * 集成 Hystrix 断路器 * 集成 Spring Cloud DiscoveryClient * 易于编写的 Predicates 和 Filters * 限流 * 路径重写\n2. Spring Cloud Gateway的工程流程 客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。\n2.1 Pre和POST两种类型的过滤器 3.基于服务发现的默认路由规则 3.1 zuul和gateway的默认路由规则 3.1.1 zuul的默认路由规则 说明默认情况下，Zuul会代理所有注册到Eureka Server的微服务，并且Zuul的路由规则如下： http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/** 会被转发到serviceId对应的微服务。 http://localhost:8040/sc-zuul-first-provider/sc/order/2 3.1.2 gateway的默认路由规则 下面的案例中会演示：http://localhost:9000/SC-CONSUMER/hello/xujin \u0026amp;gt;http://Gateway_HOST:Gateway_PORT/大写的serviceId/**，其中微服务应用名默认大写访问。\n3.2 案例示例代码 https://github.com/SoftwareKing/sc-gateway/tree/master/ch1\n   模块 说明 端口     ch1-sc-consumer 服务消费者 8000   ch1-sc-eureka Eureka Server注册中心 8761   ch1-sc-gateway Spring Cloud Gateway Sever 9000   ch1-sc-provider 服务提供者 8001    3.2.1 ch1-sc-gateway工程说明 3.2.1.1 Maven依赖 Spring Cloud Gateway sever主要的maven依赖如下所示\n\u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt;  3.2.1.2 yml文件配置 spring: application: name: sc-gateway-server cloud: gateway: discovery: locator: enabled: true server: port: 9000 eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ logging: level: org.springframework.cloud.gateway: debug  配置说明：\n spring.cloud.gateway.discovery.locator.enabled：是否与服务发现组件进行结合，通过 serviceId 转发到具体的服务实例。默认为false，设为true便开启通过服务中心的自动根据 serviceId 创建路由的功能。\n  修改spring cloud gateway server监听的端口为9000\n  eureka.client.service-url.defaultZone: http://localhost:8761/eureka/,指定注册中心的地址，Spring Cloud Gateway从注册中心获取已经注册的服务列表。\n  logging.level.org.springframework.cloud.gateway: debug,开启spring-Cloud-gateway的日志级别为debug，方便debug调试。\n 3.3 启动测试 3.3.1 错误的路由规则访问 访问Spring Cloud Gateway对应的server，当访问http://localhost:9000/sc-consumer/hello/xujin的时候，报错如下所示，正确的Spring Cloud Gateway的默认路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/**\n2018-05-18 01:10:49.742 DEBUG 6462 --- [ctor-http-nio-5] …","date":1568635200,"description":"本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/* 和 zuul的默认路由规则http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/*差不多。","dir":"blog/scg-05/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"f4e10165d1ff5f623b0311c5575caeb3","permalink":"/blog/scg-05/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-05/","summary":"摘要:本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gat","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway基于服务发现的默认路由规则","type":"blog","url":"/blog/scg-05/","wordcount":2160},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。\n1. Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念: * 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 * 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 * 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。\n2. 什么是Before路由断言 Before路由断言工厂带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之前会成功匹配，否则不能成功匹配。\n3. Before路由断言工厂的案例 3.1 引入pom依赖 pom.xml依赖配置如下所示:\n\u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring-cloud.version\u0026amp;gt;Finchley.M9\u0026amp;lt;/spring-cloud.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring-cloud.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-devtools\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;runtime\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-test\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;test\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Milestones\u0026amp;lt;/name\u0026amp;gt; …","date":1568635200,"description":"在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就`抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway`，欢迎大家`加我微信Software_King`，进入Spring Cloud中国社区微信群交流","dir":"blog/scg-06/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"d0fba303626198b42f1309b342162467","permalink":"/blog/scg-06/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-06/","summary":"摘要:在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的Before路由断言工厂","type":"blog","url":"/blog/scg-06/","wordcount":1255},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。`本篇文章简单介绍如何实现Spring Cloud Gateway的动态路由。\n2. Spring Cloud Gateway简单的动态路由实现 Spring Cloud Gateway的官方文档并没有讲如何动态配置，查看 Spring Cloud Gateway的源码，发现在org.springframework.cloud.gateway.actuate.GatewayControllerEndpoint类中提供了动态配置的Rest接口，但是需要开启Gateway的端点，而且提供的功能不是很强大。通过参考和GatewayControllerEndpoint相关的代码，可以自己编码实际动态路由配置。 下面通过案例的方式去讲解怎么实现Gateway的动态路由配置。案例工程如ch18-7-gateway所示。\n 代码地址:https://github.com/SpringCloud/spring-cloud-code/blob/master/ch18-7/ch18-7-gateway\n 3. 简单动态路由的实现 3.1 新建Maven工程ch18-7-gateway 配置主要的核心依赖如代码清单18-33所示： 代码清单: ch18-7/ch18-7-gateway/pom.xml\n\u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt;  3.2 根据Spring Cloud Gateway的路由模型定义数据传输模型 分别创建GatewayRouteDefinition.java, GatewayPredicateDefinition.java, GatewayFilterDefinition.java这三个类。 (1) 创建路由定义模型如下代码清单18-34所示： 代码清单 18-34: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayRouteDefinition.java\npublic class GatewayRouteDefinition { //路由的Id private String id; //路由断言集合配置 private List\u0026amp;lt;GatewayPredicateDefinition\u0026amp;gt; predicates = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由过滤器集合配置 private List\u0026amp;lt;GatewayFilterDefinition\u0026amp;gt; filters = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由规则转发的目标uri private String uri; //路由执行的顺序 private int order = 0; //此处省略get和set方法 }  (2)创建过滤器定义模型,代码如代码清单18-35所示： 代码清单18-35: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayFilterDefinition.java\npublic class GatewayFilterDefinition { //Filter Name private String name; //对应的路由规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  (3)路由断言定义模型，代码如代码清单18-36所示: 代码清单18-36: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayPredicateDefinition.java\npublic class GatewayPredicateDefinition { //断言对应的Name private String name; //配置的断言规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  3.3 编写动态路由实现类 编写DynamicRouteServiceImpl并实现ApplicationEventPublisherAware接口，代码如代码清单18-37所示: ch18-37/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/route/DynamicRouteServiceImpl.java\n@Service public class DynamicRouteServiceImpl implements ApplicationEventPublisherAware { @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher …","date":1568635200,"description":"本文主要介绍了Spring Cloud Gateway的动态路由的简单实现方式","dir":"blog/scg-dmy-route/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"680d0fc1e514c0358efcb358f76e3aad","permalink":"/blog/scg-dmy-route/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-dmy-route/","summary":"1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的动态路由的简单实现方式","type":"blog","url":"/blog/scg-dmy-route/","wordcount":2175},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服务有两个版本，旧版本V1，新版本v2。在线上灰度的时候，需要通过网关动态实时推送，路由权重信息。比如95%的流量走服务v1版本，5%的流量走服务v2版本。\n issue: The Spring Cloud Gateway issue of Allow Rolling Deployments https://github.com/spring-cloud/spring-cloud-gateway/issues/67\n 1.2 Spring Cloud Gateway权重路由原理 Spring Cloud Gateway中提供了org.springframework.cloud.gateway.handler.predicate.WeightRoutePredicateFactory去实现根据分组设置权重进行路由，因此使用起来相对比较简单，有兴趣的可以debug阅读源码。\npublic class WeightRoutePredicateFactory extends AbstractRoutePredicateFactory\u0026amp;lt;WeightConfig\u0026amp;gt; implements ApplicationEventPublisherAware { private static final Log log = LogFactory.getLog(WeightRoutePredicateFactory.class); public static final String GROUP_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.group\u0026amp;quot;; public static final String WEIGHT_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.weight\u0026amp;quot;; private ApplicationEventPublisher publisher; public WeightRoutePredicateFactory() { super(WeightConfig.class); } @Override public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } @Override public List\u0026amp;lt;String\u0026amp;gt; shortcutFieldOrder() { return Arrays.asList(GROUP_KEY, WEIGHT_KEY); } @Override public String shortcutFieldPrefix() { return WeightConfig.CONFIG_PREFIX; } @Override public void beforeApply(WeightConfig config) { if (publisher != null) { publisher.publishEvent(new WeightDefinedEvent(this, config)); } } @Override public Predicate\u0026amp;lt;ServerWebExchange\u0026amp;gt; apply(WeightConfig config) { return exchange -\u0026amp;gt; { Map\u0026amp;lt;String, String\u0026amp;gt; weights = exchange.getAttributeOrDefault(WEIGHT_ATTR, Collections.emptyMap()); String routeId = exchange.getAttribute(GATEWAY_PREDICATE_ROUTE_ATTR); // all calculations and comparison against random num happened in // WeightCalculatorWebFilter String group = config.getGroup(); if (weights.containsKey(group)) { String chosenRoute = weights.get(group); if (log.isTraceEnabled()) { log.trace(\u0026amp;quot;in group weight: \u0026amp;quot;+ group + \u0026amp;quot;, current route: \u0026amp;quot; + routeId +\u0026amp;quot;, chosen route: \u0026amp;quot; + chosenRoute); } return routeId.equals(chosenRoute); } return false; }; } }  2.Spring Cloud Gateway中的权重路由案例 2.1 案例代码地址 https://github.com/SoftwareKing/sc-gateway/tree/master/ch4\n2.2 Spring Cloud Gateway Server说明 Spring Cloud Gateway will dispatch 95% of the requests to version 1 and 5% of the traffic to version 2 of a specified service, as shown by the following figure.\n我们通过在Spring Cloud Gateway中会配置不同的权重信息到不同URL上，Spring Cloud Gateway会根据我们配置的路由权重信息，将请求分发到不同的源服务组，权重信息如ch4/ch4-gateway中的application.yml所示，主要配置信息如下。\nspring: application: name: ch4-gateway cloud: gateway: routes: - id: service1_v1 uri: http://localhost:8081/v1 predicates: - Path=/test - Weight=service1, 95 - id: service1_v2 uri: http://localhost:8081/v2 predicates: - Path=/test - Weight=service1, 5   Weight=service1, 95，Weight=service1, 5就是路由的权重信息。\n 2.3 源服务 源服务在本案例中源服务如ch4-service-provider所示，主要提提供Gateway Server权重路由对应的后端源服务。因为比较简单因此不做详细说明，主要代码如下所示。 …","date":1568635200,"description":"本文主要通过运用Spring Cloud Gateway的WeightRoutePredicateFactory对URL进行权重路由。","dir":"blog/scg-02/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"871e57eed714194e7f86d5f3d20d9934","permalink":"/blog/scg-02/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":2,"relpermalink":"/blog/scg-02/","summary":"1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的权重路由","type":"blog","url":"/blog/scg-02/","wordcount":946},{"author":"许进","categories":"Spring Cloud","content":" 摘要: 随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring Cloud生态圈中的第二代组件的组合，仅代表个人看法。\n1. Spring Cloud第一代 Spring Cloud自从推出之后，给大家的感觉就是Spring Cloud做它最擅长的事，也就是高度抽象和封装，强强联手整合最优东西为我所用，比如Netflix开源的Eureka，Hystrix，Ribbon等。而且提供多种技术选型，态度中立而选最优。8天前也就是2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态。引发朋友圈的一些思考。\n 虽然Eureka，Hystrix等不再继续开发或维护，但是目前来说不影响使用，不管怎么说感谢开源，向Netflix公司的开源致敬。\n 随着Spring Cloud生态圈的发展与成长，Spring Cloud陆续推出了自己的一些组件，挑选主要组件说明如下表所示:\n   组件 来源 说明     Spring-cloud-openfeign 基于Feign的升级 服务之间调用的必备组件   spring-cloud-zuul 来源于Netflix Zuul 目前还在继续维护，但是已经有自己的Spring Cloud Gateway,不久将来逐渐淘汰   spring-cloud-eureka 集成于Netflix Eureka 目前还在跟随Spring Cloud版本升级维护，最终也会被替代   spring-cloud-config 自研 功能不足，国内使用其它配置中心替代，比如携程的Apollo   全链路监控(sleuth+zikpin或pinpont) sleuth自研，其它第三方 国内目前使用最多的是skywaling等上生产   spring-cloud-ribbon 来源于Netflix集成 ribbon目前还在跟随Spring Cloud版本维护中，目前孵化未来替代品spring-cloud-lb   Spring-cloud-hystrix 来源于Netflix集成 目前还在跟随Spring Cloud版本维护中目前已经孵化spring-cloud-r4j    2. Spring Cloud 第二代 Spring Cloud第一代和第二代的组件组合汇总，如下表所示。\n    Spring Cloud第一代 Spring Cloud第二代     网关 Spring Cloud Zuul Spring Cloud Gateway   注册中心 eureka(不再更新)，Consul,ZK 阿里Nacos，拍拍贷radar等可选   配置中心 spring cloud config 阿里Nacos，携程Apollo，随行付Config Keeper   客户端软负载均衡 Ribbon spring-cloud-loadbalancer   熔断器 Hystrix spring-cloud-r4j(Resilience4J)，阿里Sentinel     由于Zuul性能一般，zuul 2.x(一直跳票，虽最终开源）但是Spring Cloud官方已经推出Spring Cloud gateway,Spring Cloud中国社区很久之前已经证实，Spring Cloud将不会集成zuul 2.x，也就是说在不就未来Zuul将从Spring Cloud生态圈中退出。\n  ribbon由于不支持webFlux的负载均衡，Spring Cloud官方很早就在孵化器项目中孵化spring-cloud-loadbalancer，目前已经将代码合并到spring-cloud-common中，预计在Spring Cloud G版可以使用，预计2018年12月底realese。\n  至于Hystrix，Netflix在2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态，其实在之前Spring Cloud官方就在孵化spring-cloud-r4j.\n 3.开源项目的链接 本文所提到的开源项目链接汇总如下所示：\nhttps://github.com/alibaba/Sentinel\nhttps://github.com/spring-cloud-incubator/spring-cloud-r4j\n阿里Nacos-https://github.com/alibaba/nacos\n随行付Config-keeper-https://github.com/sxfad/config-keeper\nspring-cloud-loadbalancer\nhttps://github.com/ctripcorp/apollo\nhttps://github.com/apache/incubator-skywalking\n","date":1568635200,"description":"随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring Cloud生态圈中的第二代组件的组合，仅代表个人看法","dir":"blog/sc-2/","fuzzywordcount":1500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"02d95b1104da8ff37650da89b3170f26","permalink":"/blog/sc-2/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/sc-2/","summary":"摘要: 随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring","tags":["Spring Cloud"],"title":"Spring Cloud第二代","type":"blog","url":"/blog/sc-2/","wordcount":1472},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。本文是基于Spring Cloud Gateway的动态路由实现 基础之上编写，通过Nacos配置服务下发路由配置实现动态路由。\n2. Spring Cloud Gateway简单的动态路由实现 Spring Cloud Gateway的官方文档并没有讲如何动态配置，查看 Spring Cloud Gateway的源码，发现在org.springframework.cloud.gateway.actuate.GatewayControllerEndpoint类中提供了动态配置的Rest接口，但是需要开启Gateway的端点，而且提供的功能不是很强大。通过参考和GatewayControllerEndpoint相关的代码，可以自己编码实际动态路由配置。 下面通过案例的方式去讲解怎么通Nacos实现Spring Cloud Gateway的动态路由。案例工程如spring-cloud-gateway-nacos所示。\n 代码地址:https://github.com/SpringCloud/spring-cloud-gateway-nacos\n 3. 简单动态路由的实现 3.1 新建Maven工程sc-gateway-server 配置主要的核心依赖如代码清单所示： 代码清单: spring-cloud-gateway-nacos/sc-gateway-server/pom.xml\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.4.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;fastjson\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.2.47\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  3.2 根据Spring Cloud Gateway的路由模型定义数据传输模型 分别创建GatewayRouteDefinition.java, GatewayPredicateDefinition.java, GatewayFilterDefinition.java这三个类。 (1) 创建路由定义模型\npublic class GatewayRouteDefinition { //路由的Id private String id; //路由断言集合配置 private List\u0026amp;lt;GatewayPredicateDefinition\u0026amp;gt; predicates = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由过滤器集合配置 private List\u0026amp;lt;GatewayFilterDefinition\u0026amp;gt; filters = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由规则转发的目标uri private String uri; //路由执行的顺序 private int order = 0; //此处省略get和set方法 }  (2)创建过滤器定义模型\npublic class GatewayFilterDefinition { //Filter Name private String name; //对应的路由规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  (3)创建路由断言定义模型\npublic class GatewayPredicateDefinition { //断言对应的Name private String name; //配置的断言规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  3.3 编写动态路由实现类 编写DynamicRouteServiceImpl并实现ApplicationEventPublisherAware接口，代码如下所示\n@Service public class DynamicRouteServiceImpl implements ApplicationEventPublisherAware { @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher publisher; //增加路由 public String add(RouteDefinition definition) { routeDefinitionWriter.save(Mono.just(definition)).subscribe(); …","date":1568635200,"description":"本文主要介绍通过Nacos下发路由配置实现Spring Cloud Gateway的动态路由","dir":"blog/scg-nacos-01/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"969fce0835ece8dc960882e28fb219e5","permalink":"/blog/scg-nacos-01/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-nacos-01/","summary":"1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，","tags":["Spring Cloud Gateway"],"title":"使用Nacos实现Spring Cloud Gateway的动态路由","type":"blog","url":"/blog/scg-nacos-01/","wordcount":2494},{"author":"许进","categories":"Moss","content":" 摘要: 本文介绍了什么是Moss以及Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生产应用可配置多种服务上线通知工具，支持多种注册中心，比如Eureka，Consul，Nacos.支持动态连接注册中心进去切换进行服务治理操作。\n1.什么是Moss 1.1 什么是服务治理 服务治理，我也称之为微服务治理，是指用来管理微服务的整个生命周期。包括应用的创建，服务名的规范，服务的上下线，服务的迁移，整个服务的生老病死等方方面面的治理。\n1.2 Moss概述 Moss(莫斯)是服务治理平台的代号，取名灵感来自电影《流浪地球》中的莫斯(Moss),Moss是电影《流浪地球》中领航员号空间站的人工智能机器人-负责管理空间站所有事务以及流浪地球的计划，而Moss跟Boos一样，是所有微服务的老板，所有微服务的生命周期将归其统管。\n为什么会出现Moss？因为基于Spring Cloud的微服务体系，缺乏统一的可视化的纳管治理平台。\n Spring Cloud中国社区从2017年11月份，开始规划Spring Cloud Admin的开发和设计，专注于研究这个领域。 代码地址:https://github.com/SpringCloud/Moss\n #### 1.2.1 竞品分析\nMoss的竞品分析对比如下表所示:\n   对比选项 Spring Boot Admin Moss     服务画像 ❌ ✅   服务实例画像 ☑️ ✅   支持单Eureka ☑️ ✅   支持单Nacos ☑️ ✅   支持多Eureka，在线动态增加，删除,切换 ❌️ ✅   前端技术 Vue Ant Design Pro   支持Spring Boot 1.5.X和Spring Boot 2.0.X ☑️ ✅   服务调用拓扑 ❌ ✅   在线查看Jar依赖 ❌ ✅   服务归属(项目，Owner) ❌ ✅   服务和实例支持模糊查询 ❌ ✅   服务闪烁告警 ❌ ✅   服务评分打星 ❌ ✅   服务列表画像 ❌ ✅   服务实例列表画像 ❌ ✅   服务实例内部组件列表，使用哪些Spring Cloud组件 ❌ ✅     其中☑️表示功能相对较弱 ✅表示功能完整强大 ❌表示功能缺失\n 1.2.1 Moss RoadMap Roadmap 时间点：\n✅表示当前稳定可用版本\n   版本 Milestone 主要特性     ✅1.0.0.RELEASE 2019.4.21 稳定可用版本    1.2.2 Moss开发团队    姓名 角色 github地址     SoftwareKing Owner https://github.com/SoftwareKing   iShawnWang 前端开发 https://github.com/iShawnWang    1.3 Moss的功能  Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生产应用可配置多种服务上线通知工具，支持多种注册中心，比如Eureka，Consul，Nacos.支持动态连接注册中心进去切换进行服务治理操作。  1.3.1 服务画像  服务画像:  服务概要信息-包括服务实例数，UP数，DOWN数，OffLine数，服务归属的项目，归属的Owner等。 服务健康指标-展示服务的健康信息 服务请求映射-展示出服务对外提供的所有REST接口 服务调用链-展示服务的依赖调用拓扑 服务API监控-通过http trace和全链路监控对API进行监控 服务内部组件状态-内部组件的依赖，使用版本状态 服务性能指标-对服务进行QPS，性能指标收集打分 服务评级-自动根据评级规则对服务进行跑批评分打星。     PS: Spring Boot Admin服务墙，如上图所示，看完之后谁能告诉我，它的服务画像能画出什么来。 Moss的服务画像列表如下所示，对比显而易见！\n 1.3.2 服务实例画像  服务实例画像\n 实例调用拓扑-对接Skywalking，PinPoint等获取实例调用拓扑  实例Build信息-实例构建信息  实例Git提交信息-最后一次提交人的Git详细信息  Spring Cloud使用功能列表 实例的健康信息 实例的上下线Event信息  服务日志级别-查看应用的日志级别,根据需要调整日志级别打印对应日志级别的信息  环境配置-查看当前应用的环境配置信息 实例JMX信息-分类展示实例的JMX信息  查看JVM-实时展示应用实例的内存使用情况，GC次数，以及CPU和内存使用率  查看日志-增量实时获取应用的info日志或Error日志  查看线程-查看当前实例的线程情况  查看实例内部依赖-查看实例的内部Jar依赖情况，统计分析展示依赖拓扑等  HttpTrace-按时间展示http请求的轨迹信息，包括请求的路径，Response的状态，调用耗时等     支持GC Log日志查看   1.3.3 服务纳管 项目对应多个应用，每个应用由多个实例组成提供具体的服务，服务的生命周期管理需要可控，可追溯，可监控，可规范。 由Spring Cloud体系构建的微服务体系，应用名即服务名。服务纳管分为历史应用纳管和新应用纳管。\n 新应用纳管: 新应用使用Moss-Client，启动时连接Moss对应用名进行统一拦截check，从而规范应用名。 旧应用纳管: 旧应用引入对应的版本的Moss-Client，在Moss平台对其手动接入管理，录入应用名。  1.3.4 多注册中心支持 Moss通过注册中心接管Spring Cloud体系的微服务。支持动态连接注册中心，填注册中心的URL即可，快速接管服务。\n1.3.5 服务报表数据 Moss通过注册中心接管Spring Cloud体系的微服务。然后获取每个服务使用Spring Boot的版本和Spring Cloud的版本，Moss的接入率以报表数据展示。\n1.3.6 事件日志 1.3.7 元数据管理 1.3.9 Spring Cloud组件使用情况 2.Moss的架构设计 2.1 Moss的架构设计 Moss基于Spring Boot Admin 2.1.3版中的spring-boot-admin-server模块二次开发，基于可扩展思想。前端采用Ant Design Pro，采用Spring Boot+shiro+JWT+LDAP实现整个权限认证管理。通过Moss-Cloud-Adapter模块支持多注册中心，应用启动对应用名进行check是否规范。\n 实现细节后续补充\n 2.2 Moss的服务设计 Moss服务端主要自动探测EndPoint，代理EndPoint，对接各种注册中心，提供可视化的管理。\n2.3 Moss的客户端设计 moss客户端主要用于内置预设自研端点和管理配置信息，使接入方无感知接入。 \u0026amp;gt;实现细节后续补充\n2.3.1 Moss-Client Moss客户端支持两种Spring Boot版本，分别是Spring Boot 1.5.X和Spring Boot 2.X，使用只需引 …","date":1551787200,"description":"本文介绍了什么是Moss以及Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生产应用可配置多种服务上线通知工具，支持多种注册中心，比如Eureka，Consul，Nacos.支持动态连接注册中心进去切换进行服务治理操作\"","dir":"blog/moss-01/","fuzzywordcount":3400,"kind":"page","lang":"zh","lastmod":1551787200,"objectID":"d57df3f930018a6b44395a936c98645b","permalink":"/blog/moss-01/","publishdate":"2019-03-05T20:00:00+08:00","readingtime":7,"relpermalink":"/blog/moss-01/","summary":"摘要: 本文介绍了什么是Moss以及Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生","tags":["Moss"],"title":"Moss-让Spring Cloud应用“不再流浪”","type":"blog","url":"/blog/moss-01/","wordcount":3353},{"author":"花肉","categories":"SOFAChannel","content":"  活动主题：SOFAChannel#1——从蚂蚁金服微服务实践谈起 活动时间：1 月 17 日周四晚 7 点 活动形式：线上直播 直播视频回顾 直播回顾文章  介绍 \u0026amp;lt;SOFA:Channel/\u0026amp;gt;，有趣实用的分布式架构频道\n前沿技术、直播 Coding、观点“抬杠”，多种形式\n\u0026amp;lt;SOFA:Channel/\u0026amp;gt; 将作为 SOFA 所有在线内容的承载，包含直播/音视频教程，集中体现 SOFAStack 的能力全景图。\n欢迎加入直播互动钉钉群：23127468（搜索群号加入即可）\n议程   SOFAChannel#1 《从蚂蚁金服微服务实践谈起》\n时间：2019-01-17 地点：浙江省杭州市西湖区线上直播   19:00-20:00   《从蚂蚁金服微服务实践谈起》 章耿 花名余淮（蚂蚁金服高级技术专家。目前在蚂蚁金服中间件服务与框架组负责应用框架及 SOFAStack 相关的工作）  嘉宾 蚂蚁金服 SOFA 团队 余淮\n视频回顾地址 https://tech.antfin.com/community/live/148\n","date":1547720400,"description":"首次 SOFAChannel 线上直播，1 月 17 日晚 7 点等你。","dir":"activities/sofa-channel-1/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1547720400,"objectID":"5c79d2fac126784ef412f107470b2924","permalink":"/activities/sofa-channel-1/","publishdate":"2019-01-17T10:20:00Z","readingtime":1,"relpermalink":"/activities/sofa-channel-1/","summary":"活动主题：SOFAChannel#1——从蚂蚁金服微服务实践谈起 活动时间：1 月 17 日周四晚 7 点 活动形式：线上直播 直播视频回顾 直播回顾文章 介绍 \u0026","tags":["SOFAChannel","SOFARPC"],"title":"SOFAChannel#1——从蚂蚁金服微服务实践谈起","type":"activities","url":"/activities/sofa-channel-1/","wordcount":323},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter。\nzuul的Filter类型 Zuul 的 Filter 是通过filterType()方法来指定，一个 Filter 只能对应一种类型，要么是 “pre” 要么是“post”\nSpring Cloud Gateway的Filter类型 Spring Cloud Gateway 基于 Project Reactor 和 WebFlux，采用响应式编程风格，打开它的 Filter 的接口GatewayFilter你会发现它只有一个方法filter\nPre类型的Filter 在Spring Cloud Gateway源码中定义了一个Pre类型的Filter，code将会在chain.filter() 之前被执行,代码:AddRequestHeader\npackage org.springframework.cloud.gateway.filter.factory; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.http.server.reactive.ServerHttpRequest; /** * @author Spencer Gibb */ public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory { @Override public GatewayFilter apply(NameValueConfig config) { return (exchange, chain) -\u0026amp;gt; { ServerHttpRequest request = exchange.getRequest().mutate() .header(config.getName(), config.getValue()) .build(); return chain.filter(exchange.mutate().request(request).build()); }; } }  Post类型的Filter 对于Post类型的Filter，SetStatus 代码将会在chain.filter(exchange).then()里面的代码运行。\npublic class SetStatusGatewayFilterFactory extends AbstractGatewayFilterFactory\u0026amp;lt;SetStatusGatewayFilterFactory.Config\u0026amp;gt; { @Override public GatewayFilter apply(Config config) { final HttpStatus status = ServerWebExchangeUtils.parse(config.status); return (exchange, chain) -\u0026amp;gt; { return chain.filter(exchange).then(Mono.fromRunnable(() -\u0026amp;gt; { // check not really needed, since it is guarded in setStatusCode, // but it\u0026#39;s a good example if (!exchange.getResponse().isCommitted()) { setResponseStatus(exchange, status); } })); }; } }  ","date":1526904000,"description":"Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter","dir":"blog/scg-04/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1526904000,"objectID":"51ce631c9eb7e07fa908f9e83bcdebf9","permalink":"/blog/scg-04/","publishdate":"2018-05-21T20:00:00+08:00","readingtime":1,"relpermalink":"/blog/scg-04/","summary":"摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Fi","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway只有Pre和POST两种类型的Filter","type":"blog","url":"/blog/scg-04/","wordcount":491},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。\n1.Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念:\n 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。  2.什么是After路由断言 After Route Predicate Factory带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之后会成功匹配，否则不能成功匹配。\n3.After路由断言工厂的案例 3.1 引入pom依赖 pom.xml依赖配置如下所示:\n\u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring-cloud.version\u0026amp;gt;Finchley.M9\u0026amp;lt;/spring-cloud.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring-cloud.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-devtools\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;runtime\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-test\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;test\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Milestones\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/milestone\u0026amp;lt;/url\u0026amp;gt; …","date":1521979200,"description":"本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就`抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway`，欢迎大家`加我微信Software_King`，进入Spring Cloud中国社区微信群交流","dir":"blog/scg-07/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1521979200,"objectID":"e49c0b6cd3d0db865ccfa6efa135b616","permalink":"/blog/scg-07/","publishdate":"2018-03-25T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-07/","summary":"摘要:本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Sprin","tags":["Spring Cloud Gateway"],"title":" Spring Cloud Gateway的After路由断言工厂","type":"blog","url":"/blog/scg-07/","wordcount":1200},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.Spring Gateway概述 Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n2. Spring Cloud gateway请求入口分析 不管是Zuul，还是Spring Cloud Gateway还是基于Netty的自研网关，都会把请求进来的Request，或者返回的Response进行包装，转换提取为网关运行的上下文信息，而在Spring Cloud gateway中网关的上下文为ServerWebExchange。\n2.1 入口HttpServerRequest和HttpServerResponse转换 Spring Cloud Gateway的请求入口，org.springframework.http.server.reactive.ReactorHttpHandlerAdapter#apply方法\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; apply(HttpServerRequest request, HttpServerResponse response) { NettyDataBufferFactory bufferFactory = new NettyDataBufferFactory(response.alloc()); ServerHttpRequest adaptedRequest; ServerHttpResponse adaptedResponse; try { adaptedRequest = new ReactorServerHttpRequest(request, bufferFactory); adaptedResponse = new ReactorServerHttpResponse(response, bufferFactory); } catch (URISyntaxException ex) { logger.error(\u0026amp;quot;Invalid URL \u0026amp;quot; + ex.getMessage(), ex); response.status(HttpResponseStatus.BAD_REQUEST); return Mono.empty(); } if (adaptedRequest.getMethod() == HttpMethod.HEAD) { adaptedResponse = new HttpHeadResponseDecorator(adaptedResponse); } return this.httpHandler.handle(adaptedRequest, adaptedResponse) .doOnError(ex -\u0026amp;gt; logger.error(\u0026amp;quot;Handling completed with error\u0026amp;quot;, ex)) .doOnSuccess(aVoid -\u0026amp;gt; logger.debug(\u0026amp;quot;Handling completed with success\u0026amp;quot;)); }   PS，代码来源于spring-web-5.0.4.RELEASE.jar 此方法为Spring Cloud Gateway的请求入口方法，该方法的作用就是把接收到的HttpServerRequest或者最终需要返回的HttpServerResponse，包装转换为ReactorServerHttpRequest和ReactorServerHttpResponse。\n 2.2 构造Spring Cloud gateway的上下文ServerWebExchange 在org.springframework.web.server.adapter.HttpWebHandlerAdapter的182行，代码如下所示:\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; handle(ServerHttpRequest request, ServerHttpResponse response) { ServerWebExchange exchange = createExchange(request, response); return getDelegate().handle(exchange) .onErrorResume(ex -\u0026amp;gt; handleFailure(request, response, ex)) .then(Mono.defer(response::setComplete)); }   createExchange()将ServerHttpRequest ServerHttpResponse构建网关上下文ServerWebExchange。\n  PS:其中org.springframework.web.server.handler.WebHandlerDecorator.getDelegate()通过委托的方式获取一系列需要处理的WebHandler.\n 2.3 进入Filter链 org.springframework.cloud.gateway.handler.FilteringWebHandler#handle方法，即77行，代码如下所示\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; handle(ServerWebExchange exchange) { Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR); List\u0026amp;lt;GatewayFilter\u0026amp;gt; gatewayFilters = route.getFilters(); List\u0026amp;lt;GatewayFilter\u0026amp;gt; combined = new ArrayList\u0026amp;lt;\u0026amp;gt;(this.globalFilters); combined.addAll(gatewayFilters); //TODO: needed or cached? AnnotationAwareOrderComparator.sort(combined); logger.debug(\u0026amp;quot;Sorted gatewayFilterFactories: \u0026amp;quot;+ combined); return new DefaultGatewayFilterChain(combined).filter(exchange); }  2.4 执行Filter链 private static class DefaultGatewayFilterChain …","date":1521288000,"description":"本篇文章主要从源码的角度揭秘Spring Cloud Gateway的怎么处理请求流程。","dir":"blog/scg-08/","fuzzywordcount":1400,"kind":"page","lang":"zh","lastmod":1521288000,"objectID":"e4fe27d91a1a644302436dd065d99463","permalink":"/blog/scg-08/","publishdate":"2018-03-17T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-08/","summary":"1.Spring Gateway概述 Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway揭秘之处理请求流程","type":"blog","url":"/blog/scg-08/","wordcount":1382},{"author":null,"categories":null,"content":" 简介 本小节将介绍 Ark Biz 目录结构，以及如何使用官方插件 sofa-ark-maven-plugin 打包并发布 Ark Biz。\nArk Biz 包和 Ark 包 都是使用 Maven 插件 sofa-ark-maven-plugin 打包生成；工程应用在配置该插件时，默认情况下只会打包发布 Ark 包， 只有在配置参数 attach 为 true 时，才会打包发布 Ark Biz：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;/excution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;attach\u0026amp;gt;false\u0026amp;lt;/attach\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  那 Ark Biz 和 Ark 包 有什么区别呢？ 简单来说，Ark Biz 是工程应用所有资源的组织单元，它包含了应用启动所需的所有资源，详细可参考下文描述的 Ark Biz 目录格式；而工程应用打出来的 Ark 包，是一个通过 java -jar 启动，运行在 SOFAArk 容器的 Fat Jar，不仅包含应用工程对应的 Ark Biz，也包含 Ark Container，以及应用依赖的 Ark Plugin；\n通常情况，只需要发布 Ark 包 即可，但是 SOFAArk 是支持运行多个 Ark Biz的，因此如果开发者希望自己应用的 Ark Biz 包能够被其他应用直接当成 Jar 包依赖，进而运行在同一个 SOFAArk 容器之上，那么就需要打包发布 Ark Biz 包；\nArk-Biz 典型目录结构 . ├── META-INF │ ├── MANIFEST.MF │ ├── maven │ │ └── me.qlong.tech │ │ └── sofa-boot-demo3-web │ │ ├── pom.properties │ │ └── pom.xml │ └── sofa-boot-demo3 │ └── sofa-boot-demo3-web.xml ├── com │ └── alipay │ └── sofa │ └── ark │ └── biz │ └── mark ├── config │ ├── application-dev.properties │ ├── application-test.properties │ └── application.properties ├── lib │ ├── spring-beans-4.3.4.RELEASE.jar │ ├── spring-boot-1.4.2.RELEASE.jar │ ├── spring-boot-autoconfigure-1.4.2.RELEASE.jar │ ├── spring-boot-devtools-1.4.2.RELEASE.jar │ ├── spring-boot-starter-1.4.2.RELEASE.jar │ ├── spring-boot-starter-logging-1.4.2.RELEASE.jar │ ├── spring-boot-starter-tomcat-1.4.2.RELEASE.jar │ ├── spring-boot-starter-web-1.4.2.RELEASE.jar │ ├── spring-context-4.3.4.RELEASE.jar │ ├── spring-core-4.3.4.RELEASE.jar │ ├── spring-expression-4.3.4.RELEASE.jar │ ├── spring-web-4.3.4.RELEASE.jar │ ├── ... │ ├── ... │ ├── ... │ └── velocity-1.7.jar ├── logback-spring.xml ├── me │ └── qlong │ └── tech │ └── SOFABootWebSpringApplication.class └── static └── index.html  上述目录结构相关文件和目录说明如下：\n普通的 Java 工程或者 Spring Boot Core/Web 工程都可以打包成 Ark Biz；Ark Biz 没有固定的目录格式，它只是在原来 Jar 包结构基础上新增两个目录文件：\n com/alipay/sofa/ark/biz/mark : 标记文件，标记该 Jar 包是 sofa-ark-maven-plugin 打包生成的 Ark Biz 文件；\n lib/ : lib 目录存放工程应用的三方依赖，\n  ","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-biz/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"83b01b05c580a3f98f21a2145dae8c89","permalink":"/projects/moss/sofa-ark-ark-biz/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/sofa-ark-ark-biz/","summary":"简介 本小节将介绍 Ark Biz 目录结构，以及如何使用官方插件 sofa-ark-maven-plugin 打包并发布 Ark Biz。 Ark Biz 包和 Ark 包 都是使用 Maven 插件 sofa-ark-maven-plugin 打包生成；工程应用在配置该插件时，默认情","tags":null,"title":"Ark Biz","type":"projects","url":"/projects/moss/sofa-ark-ark-biz/","wordcount":700},{"author":null,"categories":null,"content":" 简介 本小节将介绍 Ark Biz 目录结构，以及如何使用官方插件 sofa-ark-maven-plugin 打包并发布 Ark Biz。\nArk Biz 包和 Ark 包 都是使用 Maven 插件 sofa-ark-maven-plugin 打包生成；工程应用在配置该插件时，默认情况下只会打包发布 Ark 包， 只有在配置参数 attach 为 true 时，才会打包发布 Ark Biz：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;/excution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;attach\u0026amp;gt;false\u0026amp;lt;/attach\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  那 Ark Biz 和 Ark 包 有什么区别呢？ 简单来说，Ark Biz 是工程应用所有资源的组织单元，它包含了应用启动所需的所有资源，详细可参考下文描述的 Ark Biz 目录格式；而工程应用打出来的 Ark 包，是一个通过 java -jar 启动，运行在 SOFAArk 容器的 Fat Jar，不仅包含应用工程对应的 Ark Biz，也包含 Ark Container，以及应用依赖的 Ark Plugin；\n通常情况，只需要发布 Ark 包 即可，但是 SOFAArk 是支持运行多个 Ark Biz的，因此如果开发者希望自己应用的 Ark Biz 包能够被其他应用直接当成 Jar 包依赖，进而运行在同一个 SOFAArk 容器之上，那么就需要打包发布 Ark Biz 包；\nArk-Biz 典型目录结构 . ├── META-INF │ ├── MANIFEST.MF │ ├── maven │ │ └── me.qlong.tech │ │ └── sofa-boot-demo3-web │ │ ├── pom.properties │ │ └── pom.xml │ └── sofa-boot-demo3 │ └── sofa-boot-demo3-web.xml ├── com │ └── alipay │ └── sofa │ └── ark │ └── biz │ └── mark ├── config │ ├── application-dev.properties │ ├── application-test.properties │ └── application.properties ├── lib │ ├── spring-beans-4.3.4.RELEASE.jar │ ├── spring-boot-1.4.2.RELEASE.jar │ ├── spring-boot-autoconfigure-1.4.2.RELEASE.jar │ ├── spring-boot-devtools-1.4.2.RELEASE.jar │ ├── spring-boot-starter-1.4.2.RELEASE.jar │ ├── spring-boot-starter-logging-1.4.2.RELEASE.jar │ ├── spring-boot-starter-tomcat-1.4.2.RELEASE.jar │ ├── spring-boot-starter-web-1.4.2.RELEASE.jar │ ├── spring-context-4.3.4.RELEASE.jar │ ├── spring-core-4.3.4.RELEASE.jar │ ├── spring-expression-4.3.4.RELEASE.jar │ ├── spring-web-4.3.4.RELEASE.jar │ ├── ... │ ├── ... │ ├── ... │ └── velocity-1.7.jar ├── logback-spring.xml ├── me │ └── qlong │ └── tech │ └── SOFABootWebSpringApplication.class └── static └── index.html  上述目录结构相关文件和目录说明如下：\n普通的 Java 工程或者 Spring Boot Core/Web 工程都可以打包成 Ark Biz；Ark Biz 没有固定的目录格式，它只是在原来 Jar 包结构基础上新增两个目录文件：\n com/alipay/sofa/ark/biz/mark : 标记文件，标记该 Jar 包是 sofa-ark-maven-plugin 打包生成的 Ark Biz 文件；\n lib/ : lib 目录存放工程应用的三方依赖，\n  ","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-biz/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d7f80ce6a00d914546e642c887d23a01","permalink":"/projects/sofa-boot/sofa-ark-ark-biz/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-biz/","summary":"简介 本小节将介绍 Ark Biz 目录结构，以及如何使用官方插件 sofa-ark-maven-plugin 打包并发布 Ark Biz。 Ark Biz 包和 Ark 包 都是使用 Maven 插件 sofa-ark-maven-plugin 打包生成；工程应用在配置该插件时，默认情","tags":null,"title":"Ark Biz","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-biz/","wordcount":700},{"author":null,"categories":null,"content":" SOFAArk 合并部署时，除了宿主应用，其他 Biz 允许运行时动态部署和卸载。Biz 的状态如下：\n unresolved: 未注册，此时 Biz 包未被运行时解析 resolved: Biz 包解析完成，且已注册，此时 Biz 包还没有安装或者安装中 activated: Biz 包启动完成，且处于激活状态，可以对外提供服务 deactivated: Biz 包启动完成，但出于未激活状态，模块多个版本时，只有一个版本出于激活状态(注意这个状态只对 JVM 服务生效，对 RPC 等其他中间件无效) broken: Biz 包启动失败后状态  目前 SOFAArk 提供了三种方式操作 Biz:\n 编程 API Zookeeper 动态配置 Telnet 指令  本质上，后两种都是通过编程 API 操作 Biz，所以在这里详细描述通过编程 API 控制 Biz 的生命周期。SOFAArk 提供客户端 ArkClient 操作 Biz, 主要包含三条指令：\n install: 安装 Biz，虽然有多个重载方法，本质是接受 bizFile 文件作为入参 uninstall: 卸载 Biz，运行时 Biz 是由 bizName 和 bizVersion 唯一确定的，因此需要这两个入参 switch: 激活 Biz，SOFAArk 运行部署多个相同名称不同版本的 Biz，但是运行时只有一个 Biz 被激活（JVM 服务对外可用）；当使用 switch 指令激活其他版本时，当前处于激活状态的 Biz 将切换到钝化，同样也需要 bizName 和 bizVersion 作为入参  注意：部署相同名称不同版本 Biz 时，如果已有激活的版本，后续部署的其他版本 Biz 将自动处于钝化状态\n安装 Biz 以 Spring Boot/SOFABoot 为例，应用(模块)安装包含以下流程：\n 解析模块 \u0026amp;gt; SOFAArk 容器会解析文件流，读取 Biz 配置，创建 BizClassLoader 等，生成 Biz 运行时模型\n 注册模块 \u0026amp;gt; 注册解析后的 Biz 模型，设置状态为 resolved\n 启动模块 \u0026amp;gt; 执行 Biz 的入口方法，完成上下文的刷新，如果报错则对外抛出异常\n 健康检查 \u0026amp;gt; 启动完成，此时 Biz 还没有切换至下一个状态，将会执行应用健康检查，健康检查参考 SOFABoot 文档，健康检查失败则抛出异常，如果应用没有引入 SOFABoot 健康检查依赖，则跳过\n 切换状态 \u0026amp;gt; 健康检查成功，会切换 Biz 状态；如果不存在其他版本 Biz 处于激活状态，则切换状态至 Activated，否则切换状态至 DeActivated\n  注意：启动模块时抛出异常，均导致 Biz 启动失败，可以查看 sofa-ark/common-error.log 日志\n卸载 Biz 应用（模块）卸载包含以下流程：\n 切换 Biz 状态至少 deactivated \u0026amp;gt; 钝化 Biz, 防止流量进入正在卸载的 Biz\n 关闭 ApplicationContext \u0026amp;gt; 关闭 Biz 的 Spring 上下文，如果用户需要自定义卸载操作，可以监听 ContextClosedEvent 事件\n 注销 JVM 服务 \u0026amp;gt; SOFAArk 运行时注销 Biz 发布的 JVM 服务\n 发送卸载事件 \u0026amp;gt; 通知所有 Ark Plugin 和 Ark Biz，正在卸载某个 Biz\n 清楚缓存 \u0026amp;gt; SOFAArk 运行时注销所有和该 Biz 相关的缓存\n 切换 Biz 状态为 unresolved \u0026amp;gt; Biz 执行完所有卸载操作时，将状态置为 unresolved\n  卸载面临的挑战 卸载 Biz 最大的挑战在于 ClassLoader 的卸载，如果 ClassLoader 没有卸载干净，极有可能会导致 metaspace OOM. JDK 对 Class 的回收条件非常苛刻，包含：\n 该类所有实例都已经回收 加载该类的 ClassLoader 已经回收 该类对应的 java.lang.Class 对象已经没有在任何地方被引用，无法在任何地方通过反射访问该类的方法  每个 Biz 都由独立的 BizClassLoader 加载，只要该 Biz 的加载的类或对象或 ClassLoader 被其他 Biz 或 Plugin 引用，则会导致 Biz 无法卸载成功\n激活 Biz 激活指令用于设置 Biz 状态为 Activated，如果此时已有其他版本 Biz 处于激活状态，则先设置其为 Deactivated，再激活指定的 Biz 为 Activated. 激活状态是相对 JVM 服务而言，只有被激活的 Biz，其发布的 JVM 服务才能被其他 Biz 引用\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-biz-lifecycle/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c90cf3ce7b28d5a563739cffa27f455f","permalink":"/projects/moss/sofa-ark-biz-lifecycle/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-biz-lifecycle/","summary":"SOFAArk 合并部署时，除了宿主应用，其他 Biz 允许运行时动态部署和卸载。Biz 的状态如下： unresolved: 未注册，此时 Biz 包未被运行时解析 resolved: Biz 包解析完成，且已注册，此时","tags":null,"title":"Ark Biz 生命周期","type":"projects","url":"/projects/moss/sofa-ark-biz-lifecycle/","wordcount":1195},{"author":null,"categories":null,"content":" SOFAArk 合并部署时，除了宿主应用，其他 Biz 允许运行时动态部署和卸载。Biz 的状态如下：\n unresolved: 未注册，此时 Biz 包未被运行时解析 resolved: Biz 包解析完成，且已注册，此时 Biz 包还没有安装或者安装中 activated: Biz 包启动完成，且处于激活状态，可以对外提供服务 deactivated: Biz 包启动完成，但出于未激活状态，模块多个版本时，只有一个版本出于激活状态(注意这个状态只对 JVM 服务生效，对 RPC 等其他中间件无效) broken: Biz 包启动失败后状态  目前 SOFAArk 提供了三种方式操作 Biz:\n 编程 API Zookeeper 动态配置 Telnet 指令  本质上，后两种都是通过编程 API 操作 Biz，所以在这里详细描述通过编程 API 控制 Biz 的生命周期。SOFAArk 提供客户端 ArkClient 操作 Biz, 主要包含三条指令：\n install: 安装 Biz，虽然有多个重载方法，本质是接受 bizFile 文件作为入参 uninstall: 卸载 Biz，运行时 Biz 是由 bizName 和 bizVersion 唯一确定的，因此需要这两个入参 switch: 激活 Biz，SOFAArk 运行部署多个相同名称不同版本的 Biz，但是运行时只有一个 Biz 被激活（JVM 服务对外可用）；当使用 switch 指令激活其他版本时，当前处于激活状态的 Biz 将切换到钝化，同样也需要 bizName 和 bizVersion 作为入参  注意：部署相同名称不同版本 Biz 时，如果已有激活的版本，后续部署的其他版本 Biz 将自动处于钝化状态\n安装 Biz 以 Spring Boot/SOFABoot 为例，应用(模块)安装包含以下流程：\n 解析模块 \u0026amp;gt; SOFAArk 容器会解析文件流，读取 Biz 配置，创建 BizClassLoader 等，生成 Biz 运行时模型\n 注册模块 \u0026amp;gt; 注册解析后的 Biz 模型，设置状态为 resolved\n 启动模块 \u0026amp;gt; 执行 Biz 的入口方法，完成上下文的刷新，如果报错则对外抛出异常\n 健康检查 \u0026amp;gt; 启动完成，此时 Biz 还没有切换至下一个状态，将会执行应用健康检查，健康检查参考 SOFABoot 文档，健康检查失败则抛出异常，如果应用没有引入 SOFABoot 健康检查依赖，则跳过\n 切换状态 \u0026amp;gt; 健康检查成功，会切换 Biz 状态；如果不存在其他版本 Biz 处于激活状态，则切换状态至 Activated，否则切换状态至 DeActivated\n  注意：启动模块时抛出异常，均导致 Biz 启动失败，可以查看 sofa-ark/common-error.log 日志\n卸载 Biz 应用（模块）卸载包含以下流程：\n 切换 Biz 状态至少 deactivated \u0026amp;gt; 钝化 Biz, 防止流量进入正在卸载的 Biz\n 关闭 ApplicationContext \u0026amp;gt; 关闭 Biz 的 Spring 上下文，如果用户需要自定义卸载操作，可以监听 ContextClosedEvent 事件\n 注销 JVM 服务 \u0026amp;gt; SOFAArk 运行时注销 Biz 发布的 JVM 服务\n 发送卸载事件 \u0026amp;gt; 通知所有 Ark Plugin 和 Ark Biz，正在卸载某个 Biz\n 清楚缓存 \u0026amp;gt; SOFAArk 运行时注销所有和该 Biz 相关的缓存\n 切换 Biz 状态为 unresolved \u0026amp;gt; Biz 执行完所有卸载操作时，将状态置为 unresolved\n  卸载面临的挑战 卸载 Biz 最大的挑战在于 ClassLoader 的卸载，如果 ClassLoader 没有卸载干净，极有可能会导致 metaspace OOM. JDK 对 Class 的回收条件非常苛刻，包含：\n 该类所有实例都已经回收 加载该类的 ClassLoader 已经回收 该类对应的 java.lang.Class 对象已经没有在任何地方被引用，无法在任何地方通过反射访问该类的方法  每个 Biz 都由独立的 BizClassLoader 加载，只要该 Biz 的加载的类或对象或 ClassLoader 被其他 Biz 或 Plugin 引用，则会导致 Biz 无法卸载成功\n激活 Biz 激活指令用于设置 Biz 状态为 Activated，如果此时已有其他版本 Biz 处于激活状态，则先设置其为 Deactivated，再激活指定的 Biz 为 Activated. 激活状态是相对 JVM 服务而言，只有被激活的 Biz，其发布的 JVM 服务才能被其他 Biz 引用\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-biz-lifecycle/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"090ee6596c6808339fa3233139903040","permalink":"/projects/sofa-boot/sofa-ark-biz-lifecycle/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-biz-lifecycle/","summary":"SOFAArk 合并部署时，除了宿主应用，其他 Biz 允许运行时动态部署和卸载。Biz 的状态如下： unresolved: 未注册，此时 Biz 包未被运行时解析 resolved: Biz 包解析完成，且已注册，此时","tags":null,"title":"Ark Biz 生命周期","type":"projects","url":"/projects/sofa-boot/sofa-ark-biz-lifecycle/","wordcount":1195},{"author":null,"categories":null,"content":" 本小节将介绍 Ark Plugin 的标准规范和目录结构，以及如何使用官方插件 sofa-ark-plugin-maven-plugin 打包发布 Ark Plugin。\n插件规范 标准的 Ark Plugin 需要满足以下规范：\n 插件必须配置插件名，默认为 ${artifactId} ；运行时，不允许存在同名的插件，可以认为它是 Ark Plugin 的唯一 ID;\n 插件必须配置优先级，默认为1000，数字越低表示优先级越高；\n 插件最多配置一个入口类 activator ，它是容器启动插件的入口，统一实现 com.alipay.sofa.ark.spi.service.PluginActivator 接口类；优先级高的插件优先启动；\n 导入类支持 package 和 class 两个级别；导入类优先从其他的插件加载；\n 导出类支持 package 和 class 两个级别；优先级高的插件优先导出；\n 支持导入 classpath 中资源，不支持通配符；优先从其他插件中查找指定资源；\n 支持导出 classpath 中资源，不支持通配符；优先级高的插件优先导出；\n  Maven 插件 官方提供 Maven 插件 sofa-ark-plugin-maven-plugin 可以将工程打包成标准格式的 Ark Plugin ； Maven 插件坐标为：\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${demo.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;  Goals sofa-ark-plugin-maven-plugin 插件提供 goal: ark-plugin，可以将工程打包成标准格式的 Ark Plugin, 如下配置：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;ark-plugin\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;/excution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!-- 配置信息 --\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  完整配置模板 完整的 sofa-ark-plugin-maven-plugin 插件配置模板如下：\n\u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;ark-plugin\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!-- 指定打包的 ${pluginName}.ark.plugin 存放目录; 默认放在 ${project.build.directory} --\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;./\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!-- 是否把 ark plugin 安装、发布到仓库，默认为true --\u0026amp;gt; \u0026amp;lt;attach\u0026amp;gt;true\u0026amp;lt;/attach\u0026amp;gt; \u0026amp;lt;!-- ark plugin 最多仅能指定一个 com.alipay.sofa.ark.spi.service.PluginActivator 接口实现类 --\u0026amp;gt; \u0026amp;lt;activator\u0026amp;gt;com.alipay.sofa.ark.service.impl.SampleActivator\u0026amp;lt;/activator\u0026amp;gt; \u0026amp;lt;!-- 配置优先级，数字越小，优先级越高，优先启动，优先导出类，默认1000 --\u0026amp;gt; \u0026amp;lt;priority\u0026amp;gt;2000\u0026amp;lt;/priority\u0026amp;gt; \u0026amp;lt;!-- 配置插件的名字，务必配置对，运行时，是插件的唯一标识 ID。比如 sofa-rpc 插件，可以配置为 sofa-rpc; 默认为 ${artifactId} --\u0026amp;gt; \u0026amp;lt;pluginName\u0026amp;gt;${ark.plugin.name}\u0026amp;lt;/pluginName\u0026amp;gt; \u0026amp;lt;!--设置 ark plugin 的 classifier, 默认为空, 如非必要，建议不用设置--\u0026amp;gt; \u0026amp;lt;classifier\u0026amp;gt;ark-plugin\u0026amp;lt;/classifier\u0026amp;gt; \u0026amp;lt;!-- 配置导入类、资源 --\u0026amp;gt; \u0026amp;lt;imported\u0026amp;gt; \u0026amp;lt;!-- 配置需要优先从其他 ark plugin 加载的 package --\u0026amp;gt; \u0026amp;lt;packages\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;javax.servlet\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;org.springframework.*\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;/packages\u0026amp;gt; \u0026amp;lt;!-- 配置需要优先从其他 ark plugin 加载的 class --\u0026amp;gt; \u0026amp;lt;classes\u0026amp;gt; \u0026amp;lt;class\u0026amp;gt;com.alipay.sofa.rpc.config.ProviderConfig\u0026amp;lt;/class\u0026amp;gt; \u0026amp;lt;/classes\u0026amp;gt; \u0026amp;lt;!-- 配置需要优先从其他 ark plugin 加载的资源 --\u0026amp;gt; \u0026amp;lt;resources\u0026amp;gt; \u0026amp;lt;resource\u0026amp;gt;META-INF/spring/bean.xml\u0026amp;lt;/resource\u0026amp;gt;\u0026amp;gt; \u0026amp;lt;/resources\u0026amp;gt; \u0026amp;lt;/imported\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-plugin/","fuzzywordcount":2000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2b951faac12ab31a773845d510dcfaf0","permalink":"/projects/moss/sofa-ark-ark-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/moss/sofa-ark-ark-plugin/","summary":"本小节将介绍 Ark Plugin 的标准规范和目录结构，以及如何使用官方插件 sofa-ark-plugin-maven-plugin 打包发布 Ark Plugin。 插件规范 标准的 Ark Plugin 需要满足以下规范： 插件必须配置插件名，","tags":null,"title":"Ark Plugin","type":"projects","url":"/projects/moss/sofa-ark-ark-plugin/","wordcount":1937},{"author":null,"categories":null,"content":" 本小节将介绍 Ark Plugin 的标准规范和目录结构，以及如何使用官方插件 sofa-ark-plugin-maven-plugin 打包发布 Ark Plugin。\n插件规范 标准的 Ark Plugin 需要满足以下规范：\n 插件必须配置插件名，默认为 ${artifactId} ；运行时，不允许存在同名的插件，可以认为它是 Ark Plugin 的唯一 ID;\n 插件必须配置优先级，默认为1000，数字越低表示优先级越高；\n 插件最多配置一个入口类 activator ，它是容器启动插件的入口，统一实现 com.alipay.sofa.ark.spi.service.PluginActivator 接口类；优先级高的插件优先启动；\n 导入类支持 package 和 class 两个级别；导入类优先从其他的插件加载；\n 导出类支持 package 和 class 两个级别；优先级高的插件优先导出；\n 支持导入 classpath 中资源，不支持通配符；优先从其他插件中查找指定资源；\n 支持导出 classpath 中资源，不支持通配符；优先级高的插件优先导出；\n  Maven 插件 官方提供 Maven 插件 sofa-ark-plugin-maven-plugin 可以将工程打包成标准格式的 Ark Plugin ； Maven 插件坐标为：\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${demo.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;  Goals sofa-ark-plugin-maven-plugin 插件提供 goal: ark-plugin，可以将工程打包成标准格式的 Ark Plugin, 如下配置：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;ark-plugin\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;/excution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!-- 配置信息 --\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  完整配置模板 完整的 sofa-ark-plugin-maven-plugin 插件配置模板如下：\n\u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;ark-plugin\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!-- 指定打包的 ${pluginName}.ark.plugin 存放目录; 默认放在 ${project.build.directory} --\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;./\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!-- 是否把 ark plugin 安装、发布到仓库，默认为true --\u0026amp;gt; \u0026amp;lt;attach\u0026amp;gt;true\u0026amp;lt;/attach\u0026amp;gt; \u0026amp;lt;!-- ark plugin 最多仅能指定一个 com.alipay.sofa.ark.spi.service.PluginActivator 接口实现类 --\u0026amp;gt; \u0026amp;lt;activator\u0026amp;gt;com.alipay.sofa.ark.service.impl.SampleActivator\u0026amp;lt;/activator\u0026amp;gt; \u0026amp;lt;!-- 配置优先级，数字越小，优先级越高，优先启动，优先导出类，默认1000 --\u0026amp;gt; \u0026amp;lt;priority\u0026amp;gt;2000\u0026amp;lt;/priority\u0026amp;gt; \u0026amp;lt;!-- 配置插件的名字，务必配置对，运行时，是插件的唯一标识 ID。比如 sofa-rpc 插件，可以配置为 sofa-rpc; 默认为 ${artifactId} --\u0026amp;gt; \u0026amp;lt;pluginName\u0026amp;gt;${ark.plugin.name}\u0026amp;lt;/pluginName\u0026amp;gt; \u0026amp;lt;!--设置 ark plugin 的 classifier, 默认为空, 如非必要，建议不用设置--\u0026amp;gt; \u0026amp;lt;classifier\u0026amp;gt;ark-plugin\u0026amp;lt;/classifier\u0026amp;gt; \u0026amp;lt;!-- 配置导入类、资源 --\u0026amp;gt; \u0026amp;lt;imported\u0026amp;gt; \u0026amp;lt;!-- 配置需要优先从其他 ark plugin 加载的 package --\u0026amp;gt; \u0026amp;lt;packages\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;javax.servlet\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;org.springframework.*\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;/packages\u0026amp;gt; \u0026amp;lt;!-- 配置需要优先从其他 ark plugin 加载的 class --\u0026amp;gt; \u0026amp;lt;classes\u0026amp;gt; \u0026amp;lt;class\u0026amp;gt;com.alipay.sofa.rpc.config.ProviderConfig\u0026amp;lt;/class\u0026amp;gt; \u0026amp;lt;/classes\u0026amp;gt; \u0026amp;lt;!-- 配置需要优先从其他 ark plugin 加载的资源 --\u0026amp;gt; \u0026amp;lt;resources\u0026amp;gt; \u0026amp;lt;resource\u0026amp;gt;META-INF/spring/bean.xml\u0026amp;lt;/resource\u0026amp;gt;\u0026amp;gt; \u0026amp;lt;/resources\u0026amp;gt; \u0026amp;lt;/imported\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-plugin/","fuzzywordcount":2000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"684dc1caa0f834eec498905f95913f83","permalink":"/projects/sofa-boot/sofa-ark-ark-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-plugin/","summary":"本小节将介绍 Ark Plugin 的标准规范和目录结构，以及如何使用官方插件 sofa-ark-plugin-maven-plugin 打包发布 Ark Plugin。 插件规范 标准的 Ark Plugin 需要满足以下规范： 插件必须配置插件名，","tags":null,"title":"Ark Plugin","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-plugin/","wordcount":1937},{"author":null,"categories":null,"content":" SOFAArk 提供了简单的事件总线，Plugin 和 Biz 可以使用事件总线服务 EventAdminService 注册事件监听器并发布和监听事件：\npublic interface EventAdminService { /** * Initiate synchronous delivery of an event. This method does not return to * the caller until delivery of the event is completed. * * @param event The event to send to all listeners which subscribe to the * topic of the event. */ void sendEvent(ArkEvent event); /** * Register an event handler * * @param eventHandler */ void register(EventHandler eventHandler); /** * un-register an event handler * @param eventHandler */ void unRegister(EventHandler eventHandler); /** * un-register event handler whose classLoader matches the specified param. * @param classLoader */ void unRegister(ClassLoader classLoader); }  EventAdminSerivce 接口定义四个方法，通过这四个方法，Plugin 和 Biz 可以方便地注册事件监听器以及发送事件，目前只支持同步事件。\n事件 实现统一的事件接口类型：\npublic interface ArkEvent { /** * Returns the topic of event * * @return String return event topic */ String getTopic(); }  调用 EventAdminService.sendEvent 方法广播事件，通知所有的监听器 EventHandler\n事件监听器 实现统一的事件监听器接口：\npublic interface EventHandler extends PriorityOrdered { /** * Called by the {@link EventAdminService} service to notify the listener of an * event. * * @param event The event that occurred. */ void handleEvent(ArkEvent event); }  调用 EventAdminService.register 方法注册监听器，即可接受广播事件。\n注意事项 Plugin 内部只能手动注册事件监听器，如果 Biz 是 Spring Boot/SOFABoot 应用，所有实现接口 EventHandler 的 Bean 都会默认被注册，这也是在 Biz 中推荐的用法，在应用卸载时，也会自动注销监听器\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-event/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"29b59d7f9ddecfccecb64798dbdf5079","permalink":"/projects/moss/sofa-ark-ark-event/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/moss/sofa-ark-ark-event/","summary":"SOFAArk 提供了简单的事件总线，Plugin 和 Biz 可以使用事件总线服务 EventAdminService 注册事件监听器并发布和监听事件： public interface EventAdminService { /** * Initiate synchronous delivery of an event. This method does not return to * the caller until delivery","tags":null,"title":"Ark 事件机制","type":"projects","url":"/projects/moss/sofa-ark-ark-event/","wordcount":401},{"author":null,"categories":null,"content":" SOFAArk 提供了简单的事件总线，Plugin 和 Biz 可以使用事件总线服务 EventAdminService 注册事件监听器并发布和监听事件：\npublic interface EventAdminService { /** * Initiate synchronous delivery of an event. This method does not return to * the caller until delivery of the event is completed. * * @param event The event to send to all listeners which subscribe to the * topic of the event. */ void sendEvent(ArkEvent event); /** * Register an event handler * * @param eventHandler */ void register(EventHandler eventHandler); /** * un-register an event handler * @param eventHandler */ void unRegister(EventHandler eventHandler); /** * un-register event handler whose classLoader matches the specified param. * @param classLoader */ void unRegister(ClassLoader classLoader); }  EventAdminSerivce 接口定义四个方法，通过这四个方法，Plugin 和 Biz 可以方便地注册事件监听器以及发送事件，目前只支持同步事件。\n事件 实现统一的事件接口类型：\npublic interface ArkEvent { /** * Returns the topic of event * * @return String return event topic */ String getTopic(); }  调用 EventAdminService.sendEvent 方法广播事件，通知所有的监听器 EventHandler\n事件监听器 实现统一的事件监听器接口：\npublic interface EventHandler extends PriorityOrdered { /** * Called by the {@link EventAdminService} service to notify the listener of an * event. * * @param event The event that occurred. */ void handleEvent(ArkEvent event); }  调用 EventAdminService.register 方法注册监听器，即可接受广播事件。\n注意事项 Plugin 内部只能手动注册事件监听器，如果 Biz 是 Spring Boot/SOFABoot 应用，所有实现接口 EventHandler 的 Bean 都会默认被注册，这也是在 Biz 中推荐的用法，在应用卸载时，也会自动注销监听器\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-event/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b0f233742572536edc8a517cf7547269","permalink":"/projects/sofa-boot/sofa-ark-ark-event/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-event/","summary":"SOFAArk 提供了简单的事件总线，Plugin 和 Biz 可以使用事件总线服务 EventAdminService 注册事件监听器并发布和监听事件： public interface EventAdminService { /** * Initiate synchronous delivery of an event. This method does not return to * the caller until delivery","tags":null,"title":"Ark 事件机制","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-event/","wordcount":401},{"author":null,"categories":null,"content":" 本小节将介绍标准 Ark 包 的目录结构，以及如何使用官方插件 sofa-ark-maven-plugin 打包并发布 Ark 包。\nMaven 插件 官方提供 Maven 插件 sofa-ark-maven-plugin 可以将普通 Java 工程或者 Spring Boot 工程打包成标准格式 Ark 包 ；基于 Fat Jar 技术，使用 java -jar 命令可以直接启动 Ark 包 。 Maven 插件坐标为：\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;  Goals sofa-ark-maven-plugin 插件提供 goal: repackage， 可以将工程打包成可执行的 Ark 包，如下配置：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;/excution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!-- 配置信息 --\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  完整配置模板 完整的 sofa-ark-maven-plguin 插件配置模板如下：\n\u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--ark 包和 ark biz 的打包存放目录，默认为工程 build 目录--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;./target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!--设置应用的根目录，用于读取 ${base.dir}/conf/ark/bootstrap.application 配置文件，默认为 ${project.basedir}--\u0026amp;gt; \u0026amp;lt;baseDir\u0026amp;gt;./\u0026amp;lt;/baseDir\u0026amp;gt; \u0026amp;lt;!--生成 ark 包文件名称，默认为 ${artifactId}--\u0026amp;gt; \u0026amp;lt;finalName\u0026amp;gt;demo-ark\u0026amp;lt;/finalName\u0026amp;gt; \u0026amp;lt;!--是否跳过执行 goal:repackage，默认为false--\u0026amp;gt; \u0026amp;lt;skip\u0026amp;gt;false\u0026amp;lt;/skip\u0026amp;gt; \u0026amp;lt;!--是否打包、安装和发布 ark biz，详细参考 Ark Biz 文档，默认为false--\u0026amp;gt; \u0026amp;lt;attach\u0026amp;gt;true\u0026amp;lt;/attach\u0026amp;gt; \u0026amp;lt;!--设置 ark 包的 classifier，默认为空--\u0026amp;gt; \u0026amp;lt;arkClassifier\u0026amp;gt;ark\u0026amp;lt;/arkClassifier\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的 classifier，默认为 ark-biz--\u0026amp;gt; \u0026amp;lt;bizClassifier\u0026amp;gt;ark-biz\u0026amp;lt;/bizClassifier\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的 biz name，默认为 ${artifactId}--\u0026amp;gt; \u0026amp;lt;bizName\u0026amp;gt;demo-ark\u0026amp;lt;/bizName\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的 biz version，默认为 ${artifactId}--\u0026amp;gt; \u0026amp;lt;bizVersion\u0026amp;gt;0.0.1\u0026amp;lt;/bizVersion\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的 启动优先级，值越小优先级越高，${artifactId}--\u0026amp;gt; \u0026amp;lt;priority\u0026amp;gt;100\u0026amp;lt;/priority\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的启动入口，默认会搜索被打 org.springframework.boot.autoconfigure.SpringBootApplication 注解且含有 main 方法的入口类--\u0026amp;gt; \u0026amp;lt;mainClass\u0026amp;gt;com.alipay.sofa.xx.xx.MainEntry\u0026amp;lt;/mainClass\u0026amp;gt; \u0026amp;lt;!--设置是否将 scope=provided 的依赖打包，默认为 false--\u0026amp;gt; \u0026amp;lt;packageProvided\u0026amp;gt;false\u0026amp;lt;/packageProvided\u0026amp;gt; \u0026amp;lt;!--设置是否生成 Biz 包，默认为true--\u0026amp;gt; \u0026amp;lt;keepArkBizJar\u0026amp;gt;true\u0026amp;lt;/keepArkBizJar\u0026amp;gt; \u0026amp;lt;!--针对 Web 应用，设置 context path，默认为 /--\u0026amp;gt; \u0026amp;lt;webContextPath\u0026amp;gt;/\u0026amp;lt;/webContextPath\u0026amp;gt; \u0026amp;lt;!--打包 ark biz 时，排除指定的包依赖；格式为: ${groupId:artifactId} 或者 ${groupId:artifactId:classifier}--\u0026amp;gt; \u0026amp;lt;excludes\u0026amp;gt; \u0026amp;lt;exclude\u0026amp;gt;org.apache.commons:commons-lang3\u0026amp;lt;/exclude\u0026amp;gt; \u0026amp;lt;/excludes\u0026amp;gt; \u0026amp;lt;!--打包 ark biz 时，排除和指定 groupId 相同的包依赖--\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-jar/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c9a6a95fbb7a89ee44f0580f4fbd6fbc","permalink":"/projects/moss/sofa-ark-ark-jar/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/moss/sofa-ark-ark-jar/","summary":"本小节将介绍标准 Ark 包 的目录结构，以及如何使用官方插件 sofa-ark-maven-plugin 打包并发布 Ark 包。 Maven 插件 官方提供 Maven 插件 sofa-ark-maven-plugin 可以将普通 Java 工程或者 Spring Boot 工程打包成标准格式 Ark 包 ；","tags":null,"title":"Ark 包","type":"projects","url":"/projects/moss/sofa-ark-ark-jar/","wordcount":1626},{"author":null,"categories":null,"content":" 本小节将介绍标准 Ark 包 的目录结构，以及如何使用官方插件 sofa-ark-maven-plugin 打包并发布 Ark 包。\nMaven 插件 官方提供 Maven 插件 sofa-ark-maven-plugin 可以将普通 Java 工程或者 Spring Boot 工程打包成标准格式 Ark 包 ；基于 Fat Jar 技术，使用 java -jar 命令可以直接启动 Ark 包 。 Maven 插件坐标为：\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;  Goals sofa-ark-maven-plugin 插件提供 goal: repackage， 可以将工程打包成可执行的 Ark 包，如下配置：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;/excution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!-- 配置信息 --\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  完整配置模板 完整的 sofa-ark-maven-plguin 插件配置模板如下：\n\u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--ark 包和 ark biz 的打包存放目录，默认为工程 build 目录--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;./target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!--设置应用的根目录，用于读取 ${base.dir}/conf/ark/bootstrap.application 配置文件，默认为 ${project.basedir}--\u0026amp;gt; \u0026amp;lt;baseDir\u0026amp;gt;./\u0026amp;lt;/baseDir\u0026amp;gt; \u0026amp;lt;!--生成 ark 包文件名称，默认为 ${artifactId}--\u0026amp;gt; \u0026amp;lt;finalName\u0026amp;gt;demo-ark\u0026amp;lt;/finalName\u0026amp;gt; \u0026amp;lt;!--是否跳过执行 goal:repackage，默认为false--\u0026amp;gt; \u0026amp;lt;skip\u0026amp;gt;false\u0026amp;lt;/skip\u0026amp;gt; \u0026amp;lt;!--是否打包、安装和发布 ark biz，详细参考 Ark Biz 文档，默认为false--\u0026amp;gt; \u0026amp;lt;attach\u0026amp;gt;true\u0026amp;lt;/attach\u0026amp;gt; \u0026amp;lt;!--设置 ark 包的 classifier，默认为空--\u0026amp;gt; \u0026amp;lt;arkClassifier\u0026amp;gt;ark\u0026amp;lt;/arkClassifier\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的 classifier，默认为 ark-biz--\u0026amp;gt; \u0026amp;lt;bizClassifier\u0026amp;gt;ark-biz\u0026amp;lt;/bizClassifier\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的 biz name，默认为 ${artifactId}--\u0026amp;gt; \u0026amp;lt;bizName\u0026amp;gt;demo-ark\u0026amp;lt;/bizName\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的 biz version，默认为 ${artifactId}--\u0026amp;gt; \u0026amp;lt;bizVersion\u0026amp;gt;0.0.1\u0026amp;lt;/bizVersion\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的 启动优先级，值越小优先级越高，${artifactId}--\u0026amp;gt; \u0026amp;lt;priority\u0026amp;gt;100\u0026amp;lt;/priority\u0026amp;gt; \u0026amp;lt;!--设置 ark biz 的启动入口，默认会搜索被打 org.springframework.boot.autoconfigure.SpringBootApplication 注解且含有 main 方法的入口类--\u0026amp;gt; \u0026amp;lt;mainClass\u0026amp;gt;com.alipay.sofa.xx.xx.MainEntry\u0026amp;lt;/mainClass\u0026amp;gt; \u0026amp;lt;!--设置是否将 scope=provided 的依赖打包，默认为 false--\u0026amp;gt; \u0026amp;lt;packageProvided\u0026amp;gt;false\u0026amp;lt;/packageProvided\u0026amp;gt; \u0026amp;lt;!--设置是否生成 Biz 包，默认为true--\u0026amp;gt; \u0026amp;lt;keepArkBizJar\u0026amp;gt;true\u0026amp;lt;/keepArkBizJar\u0026amp;gt; \u0026amp;lt;!--针对 Web 应用，设置 context path，默认为 /--\u0026amp;gt; \u0026amp;lt;webContextPath\u0026amp;gt;/\u0026amp;lt;/webContextPath\u0026amp;gt; \u0026amp;lt;!--打包 ark biz 时，排除指定的包依赖；格式为: ${groupId:artifactId} 或者 ${groupId:artifactId:classifier}--\u0026amp;gt; \u0026amp;lt;excludes\u0026amp;gt; \u0026amp;lt;exclude\u0026amp;gt;org.apache.commons:commons-lang3\u0026amp;lt;/exclude\u0026amp;gt; \u0026amp;lt;/excludes\u0026amp;gt; \u0026amp;lt;!--打包 ark biz 时，排除和指定 groupId 相同的包依赖--\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-jar/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c2a9b8ad142f15b9ee82d7d9d8237850","permalink":"/projects/sofa-boot/sofa-ark-ark-jar/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-jar/","summary":"本小节将介绍标准 Ark 包 的目录结构，以及如何使用官方插件 sofa-ark-maven-plugin 打包并发布 Ark 包。 Maven 插件 官方提供 Maven 插件 sofa-ark-maven-plugin 可以将普通 Java 工程或者 Spring Boot 工程打包成标准格式 Ark 包 ；","tags":null,"title":"Ark 包","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-jar/","wordcount":1626},{"author":null,"categories":null,"content":" Ark 应用的整体启动流程如下图所述：\n当用 java -jar 启动 Ark 包 或者 在 IDE 中通过 SofaArkBootstrap.launch 启动 Ark 应用时，相应 Launcher 入口会负责启动应用，其中会反射调用 ArkContainer 的入口，初始化 ArkService ，然后依次执行 pipeline，来完成整个 Ark 应用的启动。\nArkService Ark Serivce 是 Ark 容器中的服务，底层使用 Guice 对服务进行管理。同时针对服务，提供了生命周期接口 com.alipay.sofa.ark.spi.service.ArkService\npublic interface ArkService { /** * Ark Service init * @throws ArkException */ void init() throws ArkException; /** * Ark Service dispose * @throws ArkException */ void dispose() throws ArkException; }  当服务实现了上述接口时，在 Ark Serivce 容器启动时和停止时会调用相应的生命周期接口\nPipeline 服务 Pipeline 也是注册在 Ark Service 容器中的一个服务，服务本身是没有顺序和优先级的，在 Pipeline 中会对服务进行一些组装，同时完成整个 Ark 容器的启动\nArchive 解析 在 Pipeline 的最开始，会将运行的 fatjar 进行解析，解析成运行时需要的模型，主要包括 Ark 插件模型和 Ark 业务模型，并将这些模型注册到 Ark Service 中的 PluginManagerService 以及 BizManagerService 中\n初始化环境 设置一些运行时需要的默认参数，比如设置 log4j.ignoreTCL 为 true 让 log4j/log4j2 初始化是日志不要从 ThreadContextClassloader 中寻找配置文件(背景)\n注册容器服务 在 Ark 容器中会发布一些服务供其它的插件来使用，比如 BizDeployer 来让 SOFAArk 官方插件 sofa-jarslink 来完成 biz 的动态加载/卸载等\n部署 Ark 插件 从 PluginManagerService 中获取到所有的 Ark 插件，并按照插件优先级顺序： * ClassloaderService 准备插件 export 类的 map 映射 * PluginDeployService 启动插件的 com.alipay.sofa.ark.spi.service.PluginActivator\n启动 Ark 业务 从 BizManagerService 中获取到所有的 Ark 业务，并执行业务配置在 MANIFEST.MF 属性 Main-Class 中提供的入口 main 函数\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-startup/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a0bd4d0397023e2795bbb628cd15c443","permalink":"/projects/moss/sofa-ark-startup/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/sofa-ark-startup/","summary":"Ark 应用的整体启动流程如下图所述： 当用 java -jar 启动 Ark 包 或者 在 IDE 中通过 SofaArkBootstrap.launch 启动 Ark 应用时，相应 Launcher 入口会负责启动应用，其中会反射调用 ArkContainer 的入口，初始化 ArkService ，然","tags":null,"title":"Ark 容器启动流程","type":"projects","url":"/projects/moss/sofa-ark-startup/","wordcount":523},{"author":null,"categories":null,"content":" Ark 应用的整体启动流程如下图所述：\n当用 java -jar 启动 Ark 包 或者 在 IDE 中通过 SofaArkBootstrap.launch 启动 Ark 应用时，相应 Launcher 入口会负责启动应用，其中会反射调用 ArkContainer 的入口，初始化 ArkService ，然后依次执行 pipeline，来完成整个 Ark 应用的启动。\nArkService Ark Serivce 是 Ark 容器中的服务，底层使用 Guice 对服务进行管理。同时针对服务，提供了生命周期接口 com.alipay.sofa.ark.spi.service.ArkService\npublic interface ArkService { /** * Ark Service init * @throws ArkException */ void init() throws ArkException; /** * Ark Service dispose * @throws ArkException */ void dispose() throws ArkException; }  当服务实现了上述接口时，在 Ark Serivce 容器启动时和停止时会调用相应的生命周期接口\nPipeline 服务 Pipeline 也是注册在 Ark Service 容器中的一个服务，服务本身是没有顺序和优先级的，在 Pipeline 中会对服务进行一些组装，同时完成整个 Ark 容器的启动\nArchive 解析 在 Pipeline 的最开始，会将运行的 fatjar 进行解析，解析成运行时需要的模型，主要包括 Ark 插件模型和 Ark 业务模型，并将这些模型注册到 Ark Service 中的 PluginManagerService 以及 BizManagerService 中\n初始化环境 设置一些运行时需要的默认参数，比如设置 log4j.ignoreTCL 为 true 让 log4j/log4j2 初始化是日志不要从 ThreadContextClassloader 中寻找配置文件(背景)\n注册容器服务 在 Ark 容器中会发布一些服务供其它的插件来使用，比如 BizDeployer 来让 SOFAArk 官方插件 sofa-jarslink 来完成 biz 的动态加载/卸载等\n部署 Ark 插件 从 PluginManagerService 中获取到所有的 Ark 插件，并按照插件优先级顺序： * ClassloaderService 准备插件 export 类的 map 映射 * PluginDeployService 启动插件的 com.alipay.sofa.ark.spi.service.PluginActivator\n启动 Ark 业务 从 BizManagerService 中获取到所有的 Ark 业务，并执行业务配置在 MANIFEST.MF 属性 Main-Class 中提供的入口 main 函数\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-startup/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ad60e803febd20607686a1b4ea98efc3","permalink":"/projects/sofa-boot/sofa-ark-startup/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/sofa-ark-startup/","summary":"Ark 应用的整体启动流程如下图所述： 当用 java -jar 启动 Ark 包 或者 在 IDE 中通过 SofaArkBootstrap.launch 启动 Ark 应用时，相应 Launcher 入口会负责启动应用，其中会反射调用 ArkContainer 的入口，初始化 ArkService ，然","tags":null,"title":"Ark 容器启动流程","type":"projects","url":"/projects/sofa-boot/sofa-ark-startup/","wordcount":523},{"author":null,"categories":null,"content":" Ark 插件启动 Ark 中提供了插件启动的接口 com.alipay.sofa.ark.spi.service.PluginActivator ，其定义如下：\npublic interface PluginActivator { /** * Start Plugin * @param context plugin context * @throws ArkException */ void start(PluginContext context) throws ArkException; /** * Stop Plugin * @param context * @throws ArkException */ void stop(PluginContext context) throws ArkException; }  插件只需要实现此接口，并在 MANIFEST.MF 中配置 activator 属性，就会在启动时执行 start 方法，停止时执行 stop 方法\nArk 插件通信 Ark 之间的通信是通过服务来完成的， 在上述启动接口方法的入参类型 com.alipay.sofa.ark.spi.model.PluginContext 中提供了发布服务和引用服务的接口\n/** * Publish Plugin Service * @param ifClass service interface * @param implObject service implement object * @param \u0026amp;lt;T\u0026amp;gt; * @return */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; publishService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, T implObject); /** * Get Service publish by plugin, when there are multiple services, return the highest priority plugin service * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @return service reference */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; referenceService(Class\u0026amp;lt;T\u0026amp;gt; ifClass); /** * Get Service publish by one specific plugin * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @param pluginName the name of the plugin which publish the service * @return service reference */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; referenceService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, String pluginName); /** * Get Service List publish by plugin * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @return */ \u0026amp;lt;T\u0026amp;gt; List\u0026amp;lt;ServiceReference\u0026amp;lt;T\u0026amp;gt;\u0026amp;gt; referenceServices(Class\u0026amp;lt;T\u0026amp;gt; ifClass);  插件服务是以接口为粒度的，针对同一个接口： * 每一个插件只允许发布一个服务，重复发布则会直接返回已经发布服务的引用 * 当多有个插件发布服务时，若通过 referenceService 引用单个服务 * 当不指定 pluginName 时，则返回优先级最高的服务 * 当指定 pluginName 时，则返回该插件发布的服务\n返回的服务引用 ServiceReference 定义如下:\npublic interface ServiceReference\u0026amp;lt;T\u0026amp;gt; { /** * get Service Object * @return service */ T getService(); /** * get Service Metadata * @return */ ServiceMetadata getServiceMetadata(); } public interface ServiceMetadata { /** * get Service Unique Name * @return service name */ String getServiceName(); /** * get Service Interface Class * @return interface class */ Class\u0026amp;lt;?\u0026amp;gt; getInterfaceClass(); /** * get ServiceProvider * @return */ ServiceProvider getServiceProvider(); }  其中通过 * getService() 可以获取到服务的实体 (也即发布服务时的 implObject) * getServiceMetadata() 可以获取到服务的元数据信息，包括 * 服务名：即服务的接口名 * 服务接口 * 服务的提供方：包括提供方名字(插件名等)、提供方优先级(插件优先级)\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-plugin/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4a594a53d024adf4c8f8d24fe6338463","permalink":"/projects/moss/sofa-ark-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/sofa-ark-plugin/","summary":"Ark 插件启动 Ark 中提供了插件启动的接口 com.alipay.sofa.ark.spi.service.PluginActivator ，其定义如下： public interface PluginActivator { /** * Start Plugin * @param context plugin context * @throws ArkException */ void start(PluginContext context) throws ArkException; /** * Stop Plugin * @param context * @throws ArkException */ void stop(PluginContext context) throws ArkException; } 插件只需要实","tags":null,"title":"Ark 容器插件机制","type":"projects","url":"/projects/moss/sofa-ark-plugin/","wordcount":574},{"author":null,"categories":null,"content":" Ark 插件启动 Ark 中提供了插件启动的接口 com.alipay.sofa.ark.spi.service.PluginActivator ，其定义如下：\npublic interface PluginActivator { /** * Start Plugin * @param context plugin context * @throws ArkException */ void start(PluginContext context) throws ArkException; /** * Stop Plugin * @param context * @throws ArkException */ void stop(PluginContext context) throws ArkException; }  插件只需要实现此接口，并在 MANIFEST.MF 中配置 activator 属性，就会在启动时执行 start 方法，停止时执行 stop 方法\nArk 插件通信 Ark 之间的通信是通过服务来完成的， 在上述启动接口方法的入参类型 com.alipay.sofa.ark.spi.model.PluginContext 中提供了发布服务和引用服务的接口\n/** * Publish Plugin Service * @param ifClass service interface * @param implObject service implement object * @param \u0026amp;lt;T\u0026amp;gt; * @return */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; publishService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, T implObject); /** * Get Service publish by plugin, when there are multiple services, return the highest priority plugin service * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @return service reference */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; referenceService(Class\u0026amp;lt;T\u0026amp;gt; ifClass); /** * Get Service publish by one specific plugin * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @param pluginName the name of the plugin which publish the service * @return service reference */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; referenceService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, String pluginName); /** * Get Service List publish by plugin * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @return */ \u0026amp;lt;T\u0026amp;gt; List\u0026amp;lt;ServiceReference\u0026amp;lt;T\u0026amp;gt;\u0026amp;gt; referenceServices(Class\u0026amp;lt;T\u0026amp;gt; ifClass);  插件服务是以接口为粒度的，针对同一个接口： * 每一个插件只允许发布一个服务，重复发布则会直接返回已经发布服务的引用 * 当多有个插件发布服务时，若通过 referenceService 引用单个服务 * 当不指定 pluginName 时，则返回优先级最高的服务 * 当指定 pluginName 时，则返回该插件发布的服务\n返回的服务引用 ServiceReference 定义如下:\npublic interface ServiceReference\u0026amp;lt;T\u0026amp;gt; { /** * get Service Object * @return service */ T getService(); /** * get Service Metadata * @return */ ServiceMetadata getServiceMetadata(); } public interface ServiceMetadata { /** * get Service Unique Name * @return service name */ String getServiceName(); /** * get Service Interface Class * @return interface class */ Class\u0026amp;lt;?\u0026amp;gt; getInterfaceClass(); /** * get ServiceProvider * @return */ ServiceProvider getServiceProvider(); }  其中通过 * getService() 可以获取到服务的实体 (也即发布服务时的 implObject) * getServiceMetadata() 可以获取到服务的元数据信息，包括 * 服务名：即服务的接口名 * 服务接口 * 服务的提供方：包括提供方名字(插件名等)、提供方优先级(插件优先级)\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-plugin/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b552fc51eb84cc0fa4c26860bd316490","permalink":"/projects/sofa-boot/sofa-ark-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/sofa-ark-plugin/","summary":"Ark 插件启动 Ark 中提供了插件启动的接口 com.alipay.sofa.ark.spi.service.PluginActivator ，其定义如下： public interface PluginActivator { /** * Start Plugin * @param context plugin context * @throws ArkException */ void start(PluginContext context) throws ArkException; /** * Stop Plugin * @param context * @throws ArkException */ void stop(PluginContext context) throws ArkException; } 插件只需要实","tags":null,"title":"Ark 容器插件机制","type":"projects","url":"/projects/sofa-boot/sofa-ark-plugin/","wordcount":574},{"author":null,"categories":null,"content":" Ark 容器类加载机制 Ark 容器中会管理插件和业务，整体的类加载机制可见如下图描述：\nArk 插件类加载机制 每个 Ark 插件都拥有一个独立的类加载器，其类加载的顺序如下：\n 如果是加载反射生成的字节码，那么会直接抛出 ClassNotFoundException，终止类加载。这一部分主要是来源于我们的工程实践，避免一定找不到的类查找路径过长 查找已经被加载过的类 查找 JDK 中的类，这一块主要包含两部分：第一部分是 ExtClassloader 负责加载的类；第二部分是 JDK 提供的类但从 ExtClassloader 中加载不到，但在本地运行时会被加入到 SystemClassloader 的 classpath 中，同时这些类可能会被放到一些三方工具包中，典型的如 tool.jar 中 sun.tools.attach.BsdVirtualMachine,这一部分也主要来源于我们的工程实践，避免类被加载超过一次，从而引发报错 看类是否是由 Sofa Ark 提供的接口类，典型的如: com.alipay.sofa.ark.spi.service.PluginActivator, 如果是，则类会委托给 Ark 容器的类加载器加载 看是否在插件的 import 中(包括 import-classes 和 import-package)， 如果在，则会委托给导出该类的插件类加载器加载 在插件自身的 classpath 中加载 如果上述都失败了，则会尝试在 SymtemClassloader 中加载，这一步主要是为了解决使用 agent 时的情形  如果上述的步骤都加载失败了，则抛出 ClassNotFoundException\nArk 业务类加载机制 每个 Ark 业务都拥有一个独立的类加载器， Ark 业务类加载机制基本上与 Ark 插件保持一致，在上述的7步中，主要是第5步不一样：\n对于 Ark 业务而言，并没有提供 import 的配置，而是认为默认 import 所有插件 export 出来的类；但为了一些特殊的业务场景，我们提供了 Deny-import 的配置让业务可以排除掉某些插件导出的类\nArk 插件资源加载机制 Ark 插件支持导入导出资源，需要在 sofa-ark-plugin-maven-plugin 配置相关的导入导出配置；在使用 ClassLoader 加载资源时，存在两种方式查找资源，ClassLoader.getResource(String) 和 ClassLoader.getResources(String)；\n ClassLoader.getResource(String): Ark Plugin 在查找单个资源时，会优先委托导出该资源的 Ark Plugin 加载，如果有多个插件同时导出，则优先级高的插件优先导出；如果加载失败或者没有其他 Ark Plugin 导出，则尝试在本 Ark Plugin 查找加载；\n ClassLoader.getResources(String): Ark Plugin 在查找多个资源时，会从所有导出该资源的 Ark Plugin 加载，同时也会从本 Ark Plugin 加载资源；\n  Ark 业务资源加载机制 默认情况下，Ark Biz 会优先加载 Ark Plugin 导出的资源；如果开发者希望只在工程应用内部查找，则可以通过 sofa-ark-maven-plugin 配置 denyImportResources；如此，Ark Biz 不会从 Ark Plugin 查找该资源，只会在 Ark Biz 内部查找。\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-classloader/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6cb0e1880d8dc1c571340a510c914d63","permalink":"/projects/moss/sofa-ark-classloader/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/sofa-ark-classloader/","summary":"Ark 容器类加载机制 Ark 容器中会管理插件和业务，整体的类加载机制可见如下图描述： Ark 插件类加载机制 每个 Ark 插件都拥有一个独立的类加载器，其类加载的顺序","tags":null,"title":"Ark 容器类加载机制","type":"projects","url":"/projects/moss/sofa-ark-classloader/","wordcount":974},{"author":null,"categories":null,"content":" Ark 容器类加载机制 Ark 容器中会管理插件和业务，整体的类加载机制可见如下图描述：\nArk 插件类加载机制 每个 Ark 插件都拥有一个独立的类加载器，其类加载的顺序如下：\n 如果是加载反射生成的字节码，那么会直接抛出 ClassNotFoundException，终止类加载。这一部分主要是来源于我们的工程实践，避免一定找不到的类查找路径过长 查找已经被加载过的类 查找 JDK 中的类，这一块主要包含两部分：第一部分是 ExtClassloader 负责加载的类；第二部分是 JDK 提供的类但从 ExtClassloader 中加载不到，但在本地运行时会被加入到 SystemClassloader 的 classpath 中，同时这些类可能会被放到一些三方工具包中，典型的如 tool.jar 中 sun.tools.attach.BsdVirtualMachine,这一部分也主要来源于我们的工程实践，避免类被加载超过一次，从而引发报错 看类是否是由 Sofa Ark 提供的接口类，典型的如: com.alipay.sofa.ark.spi.service.PluginActivator, 如果是，则类会委托给 Ark 容器的类加载器加载 看是否在插件的 import 中(包括 import-classes 和 import-package)， 如果在，则会委托给导出该类的插件类加载器加载 在插件自身的 classpath 中加载 如果上述都失败了，则会尝试在 SymtemClassloader 中加载，这一步主要是为了解决使用 agent 时的情形  如果上述的步骤都加载失败了，则抛出 ClassNotFoundException\nArk 业务类加载机制 每个 Ark 业务都拥有一个独立的类加载器， Ark 业务类加载机制基本上与 Ark 插件保持一致，在上述的7步中，主要是第5步不一样：\n对于 Ark 业务而言，并没有提供 import 的配置，而是认为默认 import 所有插件 export 出来的类；但为了一些特殊的业务场景，我们提供了 Deny-import 的配置让业务可以排除掉某些插件导出的类\nArk 插件资源加载机制 Ark 插件支持导入导出资源，需要在 sofa-ark-plugin-maven-plugin 配置相关的导入导出配置；在使用 ClassLoader 加载资源时，存在两种方式查找资源，ClassLoader.getResource(String) 和 ClassLoader.getResources(String)；\n ClassLoader.getResource(String): Ark Plugin 在查找单个资源时，会优先委托导出该资源的 Ark Plugin 加载，如果有多个插件同时导出，则优先级高的插件优先导出；如果加载失败或者没有其他 Ark Plugin 导出，则尝试在本 Ark Plugin 查找加载；\n ClassLoader.getResources(String): Ark Plugin 在查找多个资源时，会从所有导出该资源的 Ark Plugin 加载，同时也会从本 Ark Plugin 加载资源；\n  Ark 业务资源加载机制 默认情况下，Ark Biz 会优先加载 Ark Plugin 导出的资源；如果开发者希望只在工程应用内部查找，则可以通过 sofa-ark-maven-plugin 配置 denyImportResources；如此，Ark Biz 不会从 Ark Plugin 查找该资源，只会在 Ark Biz 内部查找。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-classloader/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5803b870aae47885c37e4bbb02cb0a06","permalink":"/projects/sofa-boot/sofa-ark-classloader/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/sofa-ark-classloader/","summary":"Ark 容器类加载机制 Ark 容器中会管理插件和业务，整体的类加载机制可见如下图描述： Ark 插件类加载机制 每个 Ark 插件都拥有一个独立的类加载器，其类加载的顺序","tags":null,"title":"Ark 容器类加载机制","type":"projects","url":"/projects/sofa-boot/sofa-ark-classloader/","wordcount":974},{"author":null,"categories":null,"content":" Ark 容器和 Ark Plugin 在运行时由不同的类加载器加载，不能使用常规的 ServiceLoader 提供 SPI 扩展，SOFAArk 自定义扩展点 SPI 机制， Ark Plugin 实现 SPI 机制，考虑到 Biz 卸载问题，Ark Biz 暂时不支持该 SPI 机制，只适用于 Ark Plugin 之间。\n声明扩展接口 使用注解 @Extensible 声明扩展接口，注解定义如下：\n@Target({ ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Extensible { /** * return specify extensible file name, default value is the * full name of interface. */ String file() default \u0026amp;quot;\u0026amp;quot;; /** * return whether this a singleton, with a single, shared instance * returned on all calls, default value is true. */ boolean singleton() default true; }   file 用于声明 SPI 扩展文件名，默认为接口全类名 singleton 用于声明加载扩展类是否为单例模式  声明扩展实现 使用注解 @Extension 声明扩展实现，注解定义如下：\n@Target({ ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Extension { /** * extension name */ String value(); /** * extension order, Higher values are interpreted as lower priority. * As a consequence, the object with the lowest value has the highest * priority. */ int order() default 100; }   value 用于定义扩展实现名称，例如不同的插件扩展同一个接口，可能会取不同的名字。 order 用于决定具体扩展实现的生效顺序  运行时，对于同一个接口的扩展实现生效规则如下： + 规则一：名称相同的扩展实现，只会返回优先级高的扩展实现类，order 数字越小，优先级越高 + 规则二：名称不相同的扩展实现，则返回一个对应的 List 列表，每个名称返回优先级最高的扩展实现\n加载 SPI 实现类 正常情况下，我们使用 ServiceLoader 加载 SPI 接口实现；SOFAArk 提供了工具类 ArkServiceLoader 用于加载扩展实现，工具类定义了两个简单的方法：\npublic class ArkServiceLoader { private static ExtensionLoaderService extensionLoaderService; // 方法一 public static \u0026amp;lt;T\u0026amp;gt; T loadExtension(Class\u0026amp;lt;T\u0026amp;gt; interfaceType, String extensionName) { return extensionLoaderService.getExtensionContributor(interfaceType, extensionName); } // 方法二 public static \u0026amp;lt;T\u0026amp;gt; List\u0026amp;lt;T\u0026amp;gt; loadExtension(Class\u0026amp;lt;T\u0026amp;gt; interfaceType) { return extensionLoaderService.getExtensionContributor(interfaceType); } }   方法一：用于加载指定接口和名称的扩展实现，返回单个结果。参考上述规则一 方法二：用于加载指定接口的扩展实现，返回列表结果。参考上述规则二  需要注意下，定义 SPI 接口的插件需要导出该接口，负责实现 SPI 接口的插件需要导入该接口。另外 SOFAArk 容器本身也会定义部分用于插件扩展实现的 SPI 接口，例如 ClassLoaderHook\n为什么不支持 Biz 的 SPI 扩展实现加载 考虑到 Biz 会动态的安装和卸载，如果支持 Biz 的扩展实现加载，生命周期容易引起混乱，暂时不考虑支持。如果确实存在 Ark Plugin 需要主动触发 Ark Biz 的逻辑调用，可以通过 SOFAArk 内部事件机制。\nSOFAArk 默认扩展点 SOFAArk 容器目前提供了唯一一个扩展点 ClassLoaderHook，用于其他插件提供扩展实现，自定义类/资源加载逻辑。ClassLoaderHooker 接口定义如下，用于扩展 BizClassLoader 和 PluginClassLoader 类(资源）加载逻辑：\n@Extensible public interface ClassLoaderHook\u0026amp;lt;T\u0026amp;gt; { Class\u0026amp;lt;?\u0026amp;gt; preFindClass(String name, ClassLoaderService classLoaderService, T t) throws ClassNotFoundException; Class\u0026amp;lt;?\u0026amp;gt; postFindClass(String name, ClassLoaderService classLoaderService, T t) throws ClassNotFoundException; URL preFindResource(String name, ClassLoaderService classLoaderService, T t); URL postFindResource(String name, ClassLoaderService classLoaderService, T t); Enumeration\u0026amp;lt;URL\u0026amp;gt; preFindResources(String name, ClassLoaderService classLoaderService, T t) throws IOException; Enumeration\u0026amp;lt;URL\u0026amp;gt; postFindResources(String name, ClassLoaderService classLoaderService, T t) throws IOException; }  通过在插件中扩展该 SPI 接口实现，可以自定义 PluginClassLoader 和 BizClassLoader 的类/资源的加载逻辑。 …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-extension/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8927fec244063dbe118efb049668d378","permalink":"/projects/moss/sofa-ark-ark-extension/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-ark-extension/","summary":"Ark 容器和 Ark Plugin 在运行时由不同的类加载器加载，不能使用常规的 ServiceLoader 提供 SPI 扩展，SOFAArk 自定义扩展点 SPI 机制， Ark Plugin 实现 SPI 机制，考虑到 Biz 卸载问题，A","tags":null,"title":"Ark 扩展机制","type":"projects","url":"/projects/moss/sofa-ark-ark-extension/","wordcount":1143},{"author":null,"categories":null,"content":" Ark 容器和 Ark Plugin 在运行时由不同的类加载器加载，不能使用常规的 ServiceLoader 提供 SPI 扩展，SOFAArk 自定义扩展点 SPI 机制， Ark Plugin 实现 SPI 机制，考虑到 Biz 卸载问题，Ark Biz 暂时不支持该 SPI 机制，只适用于 Ark Plugin 之间。\n声明扩展接口 使用注解 @Extensible 声明扩展接口，注解定义如下：\n@Target({ ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Extensible { /** * return specify extensible file name, default value is the * full name of interface. */ String file() default \u0026amp;quot;\u0026amp;quot;; /** * return whether this a singleton, with a single, shared instance * returned on all calls, default value is true. */ boolean singleton() default true; }   file 用于声明 SPI 扩展文件名，默认为接口全类名 singleton 用于声明加载扩展类是否为单例模式  声明扩展实现 使用注解 @Extension 声明扩展实现，注解定义如下：\n@Target({ ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Extension { /** * extension name */ String value(); /** * extension order, Higher values are interpreted as lower priority. * As a consequence, the object with the lowest value has the highest * priority. */ int order() default 100; }   value 用于定义扩展实现名称，例如不同的插件扩展同一个接口，可能会取不同的名字。 order 用于决定具体扩展实现的生效顺序  运行时，对于同一个接口的扩展实现生效规则如下： + 规则一：名称相同的扩展实现，只会返回优先级高的扩展实现类，order 数字越小，优先级越高 + 规则二：名称不相同的扩展实现，则返回一个对应的 List 列表，每个名称返回优先级最高的扩展实现\n加载 SPI 实现类 正常情况下，我们使用 ServiceLoader 加载 SPI 接口实现；SOFAArk 提供了工具类 ArkServiceLoader 用于加载扩展实现，工具类定义了两个简单的方法：\npublic class ArkServiceLoader { private static ExtensionLoaderService extensionLoaderService; // 方法一 public static \u0026amp;lt;T\u0026amp;gt; T loadExtension(Class\u0026amp;lt;T\u0026amp;gt; interfaceType, String extensionName) { return extensionLoaderService.getExtensionContributor(interfaceType, extensionName); } // 方法二 public static \u0026amp;lt;T\u0026amp;gt; List\u0026amp;lt;T\u0026amp;gt; loadExtension(Class\u0026amp;lt;T\u0026amp;gt; interfaceType) { return extensionLoaderService.getExtensionContributor(interfaceType); } }   方法一：用于加载指定接口和名称的扩展实现，返回单个结果。参考上述规则一 方法二：用于加载指定接口的扩展实现，返回列表结果。参考上述规则二  需要注意下，定义 SPI 接口的插件需要导出该接口，负责实现 SPI 接口的插件需要导入该接口。另外 SOFAArk 容器本身也会定义部分用于插件扩展实现的 SPI 接口，例如 ClassLoaderHook\n为什么不支持 Biz 的 SPI 扩展实现加载 考虑到 Biz 会动态的安装和卸载，如果支持 Biz 的扩展实现加载，生命周期容易引起混乱，暂时不考虑支持。如果确实存在 Ark Plugin 需要主动触发 Ark Biz 的逻辑调用，可以通过 SOFAArk 内部事件机制。\nSOFAArk 默认扩展点 SOFAArk 容器目前提供了唯一一个扩展点 ClassLoaderHook，用于其他插件提供扩展实现，自定义类/资源加载逻辑。ClassLoaderHooker 接口定义如下，用于扩展 BizClassLoader 和 PluginClassLoader 类(资源）加载逻辑：\n@Extensible public interface ClassLoaderHook\u0026amp;lt;T\u0026amp;gt; { Class\u0026amp;lt;?\u0026amp;gt; preFindClass(String name, ClassLoaderService classLoaderService, T t) throws ClassNotFoundException; Class\u0026amp;lt;?\u0026amp;gt; postFindClass(String name, ClassLoaderService classLoaderService, T t) throws ClassNotFoundException; URL preFindResource(String name, ClassLoaderService classLoaderService, T t); URL postFindResource(String name, ClassLoaderService classLoaderService, T t); Enumeration\u0026amp;lt;URL\u0026amp;gt; preFindResources(String name, ClassLoaderService classLoaderService, T t) throws IOException; Enumeration\u0026amp;lt;URL\u0026amp;gt; postFindResources(String name, ClassLoaderService classLoaderService, T t) throws IOException; }  通过在插件中扩展该 SPI 接口实现，可以自定义 PluginClassLoader 和 BizClassLoader 的类/资源的加载逻辑。 …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-extension/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"685e049f442cde4f3f51fefad5453dae","permalink":"/projects/sofa-boot/sofa-ark-ark-extension/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-extension/","summary":"Ark 容器和 Ark Plugin 在运行时由不同的类加载器加载，不能使用常规的 ServiceLoader 提供 SPI 扩展，SOFAArk 自定义扩展点 SPI 机制， Ark Plugin 实现 SPI 机制，考虑到 Biz 卸载问题，A","tags":null,"title":"Ark 扩展机制","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-extension/","wordcount":1143},{"author":null,"categories":null,"content":"SOFAArk 容器使用了 logback 日志实现，并集成了 sofa-common-tools，日志相关配置可以参考 配置文档, 这里介绍 SOFAArk 三个日志文件：\n sofa-ark/common-default.log \u0026amp;gt; sofa-ark 默认日志，打印 SOFAArk 启动日志等，大概内容如下：  2019-03-12 15:08:55,758 INFO main - Begin to start ArkServiceContainer 2019-03-12 15:08:56,290 INFO main - Init Service: com.alipay.sofa.ark.container.session.StandardTelnetServerImpl 2019-03-12 15:08:56,311 INFO main - Listening on port: 1234 2019-03-12 15:08:56,313 INFO main - Init Service: com.alipay.sofa.ark.container.service.plugin.PluginDeployServiceImpl 2019-03-12 15:08:56,313 INFO main - Init Service: com.alipay.sofa.ark.container.service.biz.BizDeployServiceImpl 2019-03-12 15:08:56,313 INFO main - Init Service: com.alipay.sofa.ark.container.service.classloader.ClassLoaderServiceImpl 2019-03-12 15:08:56,317 INFO main - Finish to start ArkServiceContainer 2019-03-12 15:08:56,338 INFO main - Start to process pipeline stage: com.alipay.sofa.ark.container.pipeline.HandleArchiveStage 2019-03-12 15:08:56,349 INFO main - Finish to process pipeline stage: com.alipay.sofa.ark.container.pipeline.HandleArchiveStage 2019-03-12 15:08:56,349 INFO main - Start to process pipeline stage: com.alipay.sofa.ark.container.pipeline.RegisterServiceStage 2019-03-12 15:08:56,354 INFO main - Service: com.alipay.sofa.ark.spi.service.biz.BizManagerService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,354 INFO main - Service: com.alipay.sofa.ark.spi.service.biz.BizFactoryService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,355 INFO main - Service: com.alipay.sofa.ark.spi.service.plugin.PluginManagerService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,356 INFO main - Service: com.alipay.sofa.ark.spi.service.plugin.PluginFactoryService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,356 INFO main - Service: com.alipay.sofa.ark.spi.service.event.EventAdminService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,357 INFO main - Service: com.alipay.sofa.ark.spi.service.registry.RegistryService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,360 INFO main - Inject {field= bizManagerService} of {service= ServiceMetadata{service=\u0026#39;com.alipay.sofa.ark.spi.service.biz.BizDeployer\u0026#39;, provider=\u0026#39;ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=100}\u0026#39;}} success!   sofa-ark/common-error.log \u0026amp;gt; sofa-ark 错误日志，打印 SOFAArk 容器运行时错误日志，例如 biz 启动失败日志等：  2019-03-12 16:38:41,873 ERROR main - Start biz: Startup In IDE meet error java.lang.reflect.InvocationTargetException: null at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-log/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"cdec5edef9a24510f813b22150dff1c4","permalink":"/projects/moss/sofa-ark-ark-log/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/sofa-ark-ark-log/","summary":"SOFAArk 容器使用了 logback 日志实现，并集成了 sofa-common-tools，日志相关配置可以参考 配置文档, 这里介绍 SOFAArk 三个日志文件： sofa-ark/common-default.log \u0026gt; sofa-ark 默认日志，打","tags":null,"title":"Ark 日志","type":"projects","url":"/projects/moss/sofa-ark-ark-log/","wordcount":667},{"author":null,"categories":null,"content":"SOFAArk 容器使用了 logback 日志实现，并集成了 sofa-common-tools，日志相关配置可以参考 配置文档, 这里介绍 SOFAArk 三个日志文件：\n sofa-ark/common-default.log \u0026amp;gt; sofa-ark 默认日志，打印 SOFAArk 启动日志等，大概内容如下：  2019-03-12 15:08:55,758 INFO main - Begin to start ArkServiceContainer 2019-03-12 15:08:56,290 INFO main - Init Service: com.alipay.sofa.ark.container.session.StandardTelnetServerImpl 2019-03-12 15:08:56,311 INFO main - Listening on port: 1234 2019-03-12 15:08:56,313 INFO main - Init Service: com.alipay.sofa.ark.container.service.plugin.PluginDeployServiceImpl 2019-03-12 15:08:56,313 INFO main - Init Service: com.alipay.sofa.ark.container.service.biz.BizDeployServiceImpl 2019-03-12 15:08:56,313 INFO main - Init Service: com.alipay.sofa.ark.container.service.classloader.ClassLoaderServiceImpl 2019-03-12 15:08:56,317 INFO main - Finish to start ArkServiceContainer 2019-03-12 15:08:56,338 INFO main - Start to process pipeline stage: com.alipay.sofa.ark.container.pipeline.HandleArchiveStage 2019-03-12 15:08:56,349 INFO main - Finish to process pipeline stage: com.alipay.sofa.ark.container.pipeline.HandleArchiveStage 2019-03-12 15:08:56,349 INFO main - Start to process pipeline stage: com.alipay.sofa.ark.container.pipeline.RegisterServiceStage 2019-03-12 15:08:56,354 INFO main - Service: com.alipay.sofa.ark.spi.service.biz.BizManagerService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,354 INFO main - Service: com.alipay.sofa.ark.spi.service.biz.BizFactoryService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,355 INFO main - Service: com.alipay.sofa.ark.spi.service.plugin.PluginManagerService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,356 INFO main - Service: com.alipay.sofa.ark.spi.service.plugin.PluginFactoryService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,356 INFO main - Service: com.alipay.sofa.ark.spi.service.event.EventAdminService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,357 INFO main - Service: com.alipay.sofa.ark.spi.service.registry.RegistryService publish by: ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=-2147483648} succeed 2019-03-12 15:08:56,360 INFO main - Inject {field= bizManagerService} of {service= ServiceMetadata{service=\u0026#39;com.alipay.sofa.ark.spi.service.biz.BizDeployer\u0026#39;, provider=\u0026#39;ServiceProvider{provider=\u0026#39;Ark Container\u0026#39;, order=100}\u0026#39;}} success!   sofa-ark/common-error.log \u0026amp;gt; sofa-ark 错误日志，打印 SOFAArk 容器运行时错误日志，例如 biz 启动失败日志等：  2019-03-12 16:38:41,873 ERROR main - Start biz: Startup In IDE meet error java.lang.reflect.InvocationTargetException: null at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-log/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a514225510e53e9bf7173734c1f878e1","permalink":"/projects/sofa-boot/sofa-ark-ark-log/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-log/","summary":"SOFAArk 容器使用了 logback 日志实现，并集成了 sofa-common-tools，日志相关配置可以参考 配置文档, 这里介绍 SOFAArk 三个日志文件： sofa-ark/common-default.log \u0026gt; sofa-ark 默认日志，打","tags":null,"title":"Ark 日志","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-log/","wordcount":667},{"author":null,"categories":null,"content":" SOFAArk 定义了两种服务类型，用于解决应用和插件，应用和应用之间的通信问题，下面分别介绍这两种服务类型：\n插件服务 SOFAArk 允许在 Plugin 通过 PluginContext 发布和引用服务，也可以使用注解 @ArkInject 引用服务。为了方便开发高级特性，SOFAArk 容器默认将内部功能组件发布成了服务，包括 Biz 管理，Plugin 管理，事件管理，服务注册管理。目前不允许 Biz 发布服务，只能引用插件服务。下面介绍如何发布和引用插件服务，以及 SOFAArk 容器默认发布的服务。\n发布服务 每个 Plugin 都可以定义唯一的插件入口，需要实现 PluginActivator 接口并在打包插件配置中声明，先看下接口定义：\npublic interface PluginActivator { /** * Start Plugin * @param context plugin context * @throws ArkRuntimeException */ void start(PluginContext context); /** * Stop Plugin * @param context * @throws ArkRuntimeException */ void stop(PluginContext context); }  SOFAArk 容器在启动插件时，会调用插件启动入口(如果有)，因此如果插件实现方需要发布插件服务供其他插件或者 Biz 调用，可以使用入参 PluginContext 发布服务，PluginContext 提供了两个方法发布服务：\n/** * Publish Plugin Service * @param ifClass service interface * @param implObject service implement object * @param \u0026amp;lt;T\u0026amp;gt; * @return */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; publishService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, T implObject); /** * Publish Plugin Service * @param ifClass service interface * @param implObject service implement object * @param uniqueId service implementation id * @param \u0026amp;lt;T\u0026amp;gt; * @return */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; publishService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, T implObject, String uniqueId);  这两个方法的区别在于是否指定 uniqueId，因为同一个接口，可能会有多个服务实现，因此需要使用 uniqueId 区别，同样在引用端也需要指定 uniqueId. 默认 uniqueId 为空\n引用服务 SOFAArk 提供了两种方式引用插件服务，在插件内部，可以直接使用 PluginContext 引用服务，PluginContext 提供了两个简单的方法引用服务：\n/** * Get Service publish by plugin, when there are multiple services, return the highest priority plugin service * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @return service reference */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; referenceService(Class\u0026amp;lt;T\u0026amp;gt; ifClass); /** * Get Service publish by one specific plugin * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @param uniqueId service implementation * @return service reference */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; referenceService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, String uniqueId);  在 Biz 内部，如果是 Spring Boot/SOFABoot 应用，可以直接使用注解 @ArkInject 引用服务，注解声明如下：\n@java.lang.annotation.Target(ElementType.FIELD) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Documented public @interface ArkInject { /** * ark service interface * @return */ Class\u0026amp;lt;?\u0026amp;gt; interfaceType() default void.class; /** * ark service uniqueId * * @return return reference unique-id */ String uniqueId() default \u0026amp;quot;\u0026amp;quot;; }  SOFAArk 提供集成 Spring Boot/SOFABoot 功能，在 Field 上打上 @ArkInject，指定接口类型和 uniqueId 即可完成自动注入。为了更加方便的使用，如果没有指定 interfacetType 类型，默认使用被打注解的 Field 类型。\n在插件内部，有时候也可以使用 @ArkInject 引用服务，即插件在发布某个服务时，服务内部可以直接使用 @ArkInject 引用服务；需要注意的是，被引用的服务如果是其他插件发布的，则必须满足其他插件优先当前插件启动。\n默认服务 前面提到，为了方便 Plugin 和 Biz 开发高级特性，SOFAArk 将内部功能组件发布成服务，包括：\n BizManageService \u0026amp;gt; Biz 管理器，管理、查询 Biz 信息\n BizFactoryService \u0026amp;gt; Biz 解析器，解析 Biz 文件\n PluginManagerService \u0026amp;gt; Plugin 管理器，管理、查询 Plugin 信息\n PluginFactoryService \u0026amp;gt; Plugin 解析器，解析 Plugin 文件\n EventAdminService \u0026amp;gt; SOFAArk 事件管理器， …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-service/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9b400d9314cadf7cdabf9e12663329c9","permalink":"/projects/moss/sofa-ark-ark-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-ark-service/","summary":"SOFAArk 定义了两种服务类型，用于解决应用和插件，应用和应用之间的通信问题，下面分别介绍这两种服务类型： 插件服务 SOFAArk 允许在 Plugin 通过 PluginContext 发布和引用服务，也可","tags":null,"title":"Ark 服务机制","type":"projects","url":"/projects/moss/sofa-ark-ark-service/","wordcount":1188},{"author":null,"categories":null,"content":" SOFAArk 定义了两种服务类型，用于解决应用和插件，应用和应用之间的通信问题，下面分别介绍这两种服务类型：\n插件服务 SOFAArk 允许在 Plugin 通过 PluginContext 发布和引用服务，也可以使用注解 @ArkInject 引用服务。为了方便开发高级特性，SOFAArk 容器默认将内部功能组件发布成了服务，包括 Biz 管理，Plugin 管理，事件管理，服务注册管理。目前不允许 Biz 发布服务，只能引用插件服务。下面介绍如何发布和引用插件服务，以及 SOFAArk 容器默认发布的服务。\n发布服务 每个 Plugin 都可以定义唯一的插件入口，需要实现 PluginActivator 接口并在打包插件配置中声明，先看下接口定义：\npublic interface PluginActivator { /** * Start Plugin * @param context plugin context * @throws ArkRuntimeException */ void start(PluginContext context); /** * Stop Plugin * @param context * @throws ArkRuntimeException */ void stop(PluginContext context); }  SOFAArk 容器在启动插件时，会调用插件启动入口(如果有)，因此如果插件实现方需要发布插件服务供其他插件或者 Biz 调用，可以使用入参 PluginContext 发布服务，PluginContext 提供了两个方法发布服务：\n/** * Publish Plugin Service * @param ifClass service interface * @param implObject service implement object * @param \u0026amp;lt;T\u0026amp;gt; * @return */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; publishService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, T implObject); /** * Publish Plugin Service * @param ifClass service interface * @param implObject service implement object * @param uniqueId service implementation id * @param \u0026amp;lt;T\u0026amp;gt; * @return */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; publishService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, T implObject, String uniqueId);  这两个方法的区别在于是否指定 uniqueId，因为同一个接口，可能会有多个服务实现，因此需要使用 uniqueId 区别，同样在引用端也需要指定 uniqueId. 默认 uniqueId 为空\n引用服务 SOFAArk 提供了两种方式引用插件服务，在插件内部，可以直接使用 PluginContext 引用服务，PluginContext 提供了两个简单的方法引用服务：\n/** * Get Service publish by plugin, when there are multiple services, return the highest priority plugin service * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @return service reference */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; referenceService(Class\u0026amp;lt;T\u0026amp;gt; ifClass); /** * Get Service publish by one specific plugin * @param ifClass service interface * @param \u0026amp;lt;T\u0026amp;gt; * @param uniqueId service implementation * @return service reference */ \u0026amp;lt;T\u0026amp;gt; ServiceReference\u0026amp;lt;T\u0026amp;gt; referenceService(Class\u0026amp;lt;T\u0026amp;gt; ifClass, String uniqueId);  在 Biz 内部，如果是 Spring Boot/SOFABoot 应用，可以直接使用注解 @ArkInject 引用服务，注解声明如下：\n@java.lang.annotation.Target(ElementType.FIELD) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Documented public @interface ArkInject { /** * ark service interface * @return */ Class\u0026amp;lt;?\u0026amp;gt; interfaceType() default void.class; /** * ark service uniqueId * * @return return reference unique-id */ String uniqueId() default \u0026amp;quot;\u0026amp;quot;; }  SOFAArk 提供集成 Spring Boot/SOFABoot 功能，在 Field 上打上 @ArkInject，指定接口类型和 uniqueId 即可完成自动注入。为了更加方便的使用，如果没有指定 interfacetType 类型，默认使用被打注解的 Field 类型。\n在插件内部，有时候也可以使用 @ArkInject 引用服务，即插件在发布某个服务时，服务内部可以直接使用 @ArkInject 引用服务；需要注意的是，被引用的服务如果是其他插件发布的，则必须满足其他插件优先当前插件启动。\n默认服务 前面提到，为了方便 Plugin 和 Biz 开发高级特性，SOFAArk 将内部功能组件发布成服务，包括：\n BizManageService \u0026amp;gt; Biz 管理器，管理、查询 Biz 信息\n BizFactoryService \u0026amp;gt; Biz 解析器，解析 Biz 文件\n PluginManagerService \u0026amp;gt; Plugin 管理器，管理、查询 Plugin 信息\n PluginFactoryService \u0026amp;gt; Plugin 解析器，解析 Plugin 文件\n EventAdminService \u0026amp;gt; SOFAArk 事件管理器， …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-service/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"81b7e697b890139c03831cdb648e094b","permalink":"/projects/sofa-boot/sofa-ark-ark-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-service/","summary":"SOFAArk 定义了两种服务类型，用于解决应用和插件，应用和应用之间的通信问题，下面分别介绍这两种服务类型： 插件服务 SOFAArk 允许在 Plugin 通过 PluginContext 发布和引用服务，也可","tags":null,"title":"Ark 服务机制","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-service/","wordcount":1188},{"author":null,"categories":null,"content":" 在 Ark 服务机制 中，我们详细介绍了如何引用和发布插件服务，主要是解决 Plugin 和 Biz 的通信问题；为了解决 Biz 之间的通信问题，SOFAArk 引入了 SOFABoot 提供的 SofaService/SofaReference 编程界面；下面介绍其使用方法。\n引入依赖 引入 runtime-sofa-boot-plugin 依赖，如果应用基于 Spring Boot 1.x 开发，推荐使用 v2.6.1 版本；如果应用基于 Spring Boot 2.x 开发，推荐使用 v3.1.3 版本；\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;runtime-sofa-boot-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.boot.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  发布和引用 JVM 服务 SOFAArk 引入了 SOFABoot 提供的 SofaService/SofaReference JVM 服务概念(参考文档)，为了方便文档统一，重复其介绍。\nSOFABoot 提供三种方式给开发人员发布和引用 JVM 服务\n XML 方式 Annotation 方式 编程 API 方式  XML 方式 服务发布 首先需要定义一个 Bean：\n\u0026amp;lt;bean id=\u0026amp;quot;sampleService\u0026amp;quot; class=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleServiceImpl\u0026amp;quot;\u0026amp;gt;  然后通过 SOFA 提供的 Spring 扩展标签来将上面的 Bean 发布成一个 SOFA JVM 服务。\n\u0026amp;lt;sofa:service interface=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleService\u0026amp;quot; ref=\u0026amp;quot;sampleService\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.jvm/\u0026amp;gt; \u0026amp;lt;/sofa:service\u0026amp;gt;  上面的配置中的 interface 指的是需要发布成服务的接口，ref 指向的是需要发布成 JVM 服务的 Bean，至此，我们就已经完成了一个 JVM 服务的发布。\n服务引用 使用 SOFA 提供的 Spring 扩展标签引用服务:\n\u0026amp;lt;sofa:reference interface=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleService\u0026amp;quot; id=\u0026amp;quot;sampleServiceRef\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.jvm/\u0026amp;gt; \u0026amp;lt;/sofa:service\u0026amp;gt;  上面的配置中的 interface 是服务的接口，需要和发布服务时配置的 interface 一致。id 属性的含义同 Spring BeanId。上面的配置会生成一个 id 为 sampleServiceRef 的 Spring Bean，你可以将 sampleServiceRef 这个 Bean 注入到当前 SOFABoot 模块 Spring 上下文的任意地方。\n service/reference 标签还支持 RPC 服务发布，相关文档: RPC 服务发布与引用\n Annotation 方式  警告\n如果一个服务已经被加上了 @SofaService 的注解，它就不能再用 XML 的方式去发布服务了，选择一种方式发布服务，而不是两种混用。\n 除了通过 XML 方式发布 JVM 服务和引用之外，SOFABoot 还提供了 Annotation 的方式来发布和引用 JVM 服务。通过 Annotation 方式发布 JVM 服务，只需要在实现类上加一个 @SofaService 注解即可，如下：\n@SofaService public class SampleImpl implements SampleInterface { public void test() { } }   提示\n@SofaService 的作用是将一个 Bean 发布成一个 JVM 服务，这意味着虽然你可以不用再写 \u0026amp;lt;sofa:service/\u0026amp;gt; 的配置，但是还是需要事先将 @SofaService 所注解的类配置成一个 Spring Bean。\n 在使用 XML 配置 \u0026amp;lt;sofa:service/\u0026amp;gt; 的时候，我们配置了一个 interface 属性，但是在使用 @SofaService 注解的时候，却没有看到有配置服务接口的地方。这是因为当被 @SofaService 注解的类只有一个接口的时候，框架会直接采用这个接口作为服务的接口。当被 @SofaService 注解的类实现了多个接口时，可以设置 @SofaService 的 interfaceType 字段来指定服务接口，比如下面这样：\n@SofaService(interfaceType=SampleInterface.class) public class SampleImpl implements SampleInterface, Serializable { public void test() { } }  和 @SofaService 对应，Sofa 提供了 @SofaReference 来引用一个 JVM 服务。假设我们需要在一个 Spring Bean 中使用 SampleJvmService 这个 JVM 服务，那么只需要在字段上加上一个 @SofaReference 的注解即可：\npublic class SampleServiceRef { @SofaReference private SampleService sampleService; }  和 @SofaService 类似，我们也没有在 @SofaReference 上指定服务接口，这是因为 @SofaReference 在不指定服务接口的时候，会采用被注解字段的类型作为服务接口，你也可以通过设定 @SofaReference 的 interfaceType 属性来指定：\npublic class SampleServiceRef { @SofaReference(interfaceType=SampleService.class) private SampleService sampleService; }  使用 @SofaService 注解发布服务时，需要在实现类上打上 @SofaService 注解；在 Spring Boot 使用 Bean Method 创建 Bean 时，会导致 @Bean 和 @SofaService 分散在两处，而且无法对同一个实现类使用不同的 unique id。 …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-jvm/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f2b98763841563e78c7ad67d27f066b9","permalink":"/projects/moss/sofa-ark-ark-jvm/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/moss/sofa-ark-ark-jvm/","summary":"在 Ark 服务机制 中，我们详细介绍了如何引用和发布插件服务，主要是解决 Plugin 和 Biz 的通信问题；为了解决 Biz 之间的通信问题，SOFAArk 引入了 SOFABoot 提供的 SofaService/SofaReference 编","tags":null,"title":"Ark 服务通信","type":"projects","url":"/projects/moss/sofa-ark-ark-jvm/","wordcount":2436},{"author":null,"categories":null,"content":" 在 Ark 服务机制 中，我们详细介绍了如何引用和发布插件服务，主要是解决 Plugin 和 Biz 的通信问题；为了解决 Biz 之间的通信问题，SOFAArk 引入了 SOFABoot 提供的 SofaService/SofaReference 编程界面；下面介绍其使用方法。\n引入依赖 引入 runtime-sofa-boot-plugin 依赖，如果应用基于 Spring Boot 1.x 开发，推荐使用 v2.6.1 版本；如果应用基于 Spring Boot 2.x 开发，推荐使用 v3.1.3 版本；\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;runtime-sofa-boot-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.boot.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  发布和引用 JVM 服务 SOFAArk 引入了 SOFABoot 提供的 SofaService/SofaReference JVM 服务概念(参考文档)，为了方便文档统一，重复其介绍。\nSOFABoot 提供三种方式给开发人员发布和引用 JVM 服务\n XML 方式 Annotation 方式 编程 API 方式  XML 方式 服务发布 首先需要定义一个 Bean：\n\u0026amp;lt;bean id=\u0026amp;quot;sampleService\u0026amp;quot; class=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleServiceImpl\u0026amp;quot;\u0026amp;gt;  然后通过 SOFA 提供的 Spring 扩展标签来将上面的 Bean 发布成一个 SOFA JVM 服务。\n\u0026amp;lt;sofa:service interface=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleService\u0026amp;quot; ref=\u0026amp;quot;sampleService\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.jvm/\u0026amp;gt; \u0026amp;lt;/sofa:service\u0026amp;gt;  上面的配置中的 interface 指的是需要发布成服务的接口，ref 指向的是需要发布成 JVM 服务的 Bean，至此，我们就已经完成了一个 JVM 服务的发布。\n服务引用 使用 SOFA 提供的 Spring 扩展标签引用服务:\n\u0026amp;lt;sofa:reference interface=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleService\u0026amp;quot; id=\u0026amp;quot;sampleServiceRef\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.jvm/\u0026amp;gt; \u0026amp;lt;/sofa:service\u0026amp;gt;  上面的配置中的 interface 是服务的接口，需要和发布服务时配置的 interface 一致。id 属性的含义同 Spring BeanId。上面的配置会生成一个 id 为 sampleServiceRef 的 Spring Bean，你可以将 sampleServiceRef 这个 Bean 注入到当前 SOFABoot 模块 Spring 上下文的任意地方。\n service/reference 标签还支持 RPC 服务发布，相关文档: RPC 服务发布与引用\n Annotation 方式  警告\n如果一个服务已经被加上了 @SofaService 的注解，它就不能再用 XML 的方式去发布服务了，选择一种方式发布服务，而不是两种混用。\n 除了通过 XML 方式发布 JVM 服务和引用之外，SOFABoot 还提供了 Annotation 的方式来发布和引用 JVM 服务。通过 Annotation 方式发布 JVM 服务，只需要在实现类上加一个 @SofaService 注解即可，如下：\n@SofaService public class SampleImpl implements SampleInterface { public void test() { } }   提示\n@SofaService 的作用是将一个 Bean 发布成一个 JVM 服务，这意味着虽然你可以不用再写 \u0026amp;lt;sofa:service/\u0026amp;gt; 的配置，但是还是需要事先将 @SofaService 所注解的类配置成一个 Spring Bean。\n 在使用 XML 配置 \u0026amp;lt;sofa:service/\u0026amp;gt; 的时候，我们配置了一个 interface 属性，但是在使用 @SofaService 注解的时候，却没有看到有配置服务接口的地方。这是因为当被 @SofaService 注解的类只有一个接口的时候，框架会直接采用这个接口作为服务的接口。当被 @SofaService 注解的类实现了多个接口时，可以设置 @SofaService 的 interfaceType 字段来指定服务接口，比如下面这样：\n@SofaService(interfaceType=SampleInterface.class) public class SampleImpl implements SampleInterface, Serializable { public void test() { } }  和 @SofaService 对应，Sofa 提供了 @SofaReference 来引用一个 JVM 服务。假设我们需要在一个 Spring Bean 中使用 SampleJvmService 这个 JVM 服务，那么只需要在字段上加上一个 @SofaReference 的注解即可：\npublic class SampleServiceRef { @SofaReference private SampleService sampleService; }  和 @SofaService 类似，我们也没有在 @SofaReference 上指定服务接口，这是因为 @SofaReference 在不指定服务接口的时候，会采用被注解字段的类型作为服务接口，你也可以通过设定 @SofaReference 的 interfaceType 属性来指定：\npublic class SampleServiceRef { @SofaReference(interfaceType=SampleService.class) private SampleService sampleService; }  使用 @SofaService 注解发布服务时，需要在实现类上打上 @SofaService 注解；在 Spring Boot 使用 Bean Method 创建 Bean 时，会导致 @Bean 和 @SofaService 分散在两处，而且无法对同一个实现类使用不同的 unique id。 …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-jvm/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1bf80b24428da0f91edc6af7b63f6047","permalink":"/projects/sofa-boot/sofa-ark-ark-jvm/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-jvm/","summary":"在 Ark 服务机制 中，我们详细介绍了如何引用和发布插件服务，主要是解决 Plugin 和 Biz 的通信问题；为了解决 Biz 之间的通信问题，SOFAArk 引入了 SOFABoot 提供的 SofaService/SofaReference 编","tags":null,"title":"Ark 服务通信","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-jvm/","wordcount":2436},{"author":null,"categories":null,"content":" SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等能力。在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFA 中间件的能力。\n你可以在发布历史中查看所有的发布报告，SOFABoot 版本和 Spring Boot 版本对应关系如下：\n   SOFABoot 版本 Spring Boot 版本     2.3.x 1.4.2.RELEASE   2.4.x 1.4.2.RELEASE   2.5.x 1.5.16.RELEASE   3.0.x 2.0.3.RELEASE   3.1.x 2.1.0.RELEASE    即 SOFABoot 2.3.x 和 2.4.x 系列版本构建在 Spring Boot 1.4.2.RELEASE 基础之上；SOFABoot 2.5.x 系列版本构建在 Spring Boot 1.5.x 基础之上；SOFABoot 3.x 系列版本将构建在 Spring Boot 2.x 基础之上。你可以在发布历史中查看获取所有的历史版本代码。另外为了方便社区同学能够基于最新开发版本的 SOFABoot 进行开发学习，我们会发布当前开发分支的 SNAPSHOT 版本。为顺利从中央仓库拉取 SNAPSHOT 包，需要在本地 maven setting.xml 文件增加如下 profile 配置:\n\u0026amp;lt;profile\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;activation\u0026amp;gt; \u0026amp;lt;activeByDefault\u0026amp;gt;true\u0026amp;lt;/activeByDefault\u0026amp;gt; \u0026amp;lt;/activation\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;maven-snapshot\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://oss.sonatype.org/content/repositories/snapshots\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;/repositories\u0026amp;gt; \u0026amp;lt;pluginRepositories\u0026amp;gt; \u0026amp;lt;pluginRepository\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;maven-snapshot\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://oss.sonatype.org/content/repositories/snapshots\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;/pluginRepository\u0026amp;gt; \u0026amp;lt;/pluginRepositories\u0026amp;gt; \u0026amp;lt;/profile\u0026amp;gt;  目前 SOFABoot 最新版本为 3.1.0，基于 Spring Boot 2.1.0.RELEASE, 支持 JDK11。\n功能描述 SOFABoot 在 Spring Boot 基础上，提供了以下能力：\n 扩展 Spring Boot 健康检查的能力：在 Spring Boot 健康检查能力基础上，提供了 Readiness Check 的能力，保证应用实例安全上线。 提供模块化开发的能力：基于 Spring 上下文隔离提供模块化开发能力，每个 SOFABoot 模块使用独立的 Spring 上下文，避免不同 SOFABoot 模块间的 BeanId 冲突。 增加模块并行加载和 Spring Bean 异步初始化能力，加速应用启动； 增加日志空间隔离的能力：中间件框架自动发现应用的日志实现依赖并独立打印日志，避免中间件和应用日志实现绑定，通过 sofa-common-tools 实现。 增加类隔离的能力：基于 SOFAArk 框架提供类隔离能力，方便使用者解决各种类冲突问题。 增加中间件集成管理的能力：统一管控、提供中间件统一易用的编程接口、每一个 SOFA 中间件都是独立可插拔的组件。 提供完全兼容 Spring Boot的能力：SOFABoot 基于 Spring Boot 的基础上进行构建，并且完全兼容 Spring Boot。  应用场景 SOFABoot 本身就脱胎于蚂蚁金服内部对于 Spring Boot 的实践，补充了 Spring Boot 在大规模金融级生产场景下一些不足的地方，所以 SOFABoot 特别适合于这样的场景。\n当然，SOFABoot 的每个组件都是可选的，用户可以灵活选择其中的功能来使用，比如如果仅仅想在 Spring Boot 下面引入 SOFA 中间件，可以不需引入 SOFABoot 中的类隔离能力。\n","date":-62135596800,"description":"","dir":"projects/moss/overview/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2d9d19f8650bf36febacb47972512b05","permalink":"/projects/moss/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/overview/","summary":"SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等能力。在增强了 Spring Boot 的同时，SOFABo","tags":null,"title":"Halo Boot 介绍","type":"projects","url":"/projects/moss/overview/","wordcount":855},{"author":null,"categories":null,"content":" SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等能力。在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFA 中间件的能力。\n你可以在发布历史中查看所有的发布报告，SOFABoot 版本和 Spring Boot 版本对应关系如下：\n   SOFABoot 版本 Spring Boot 版本     2.3.x 1.4.2.RELEASE   2.4.x 1.4.2.RELEASE   2.5.x 1.5.16.RELEASE   3.0.x 2.0.3.RELEASE   3.1.x 2.1.0.RELEASE    即 SOFABoot 2.3.x 和 2.4.x 系列版本构建在 Spring Boot 1.4.2.RELEASE 基础之上；SOFABoot 2.5.x 系列版本构建在 Spring Boot 1.5.x 基础之上；SOFABoot 3.x 系列版本将构建在 Spring Boot 2.x 基础之上。你可以在发布历史中查看获取所有的历史版本代码。另外为了方便社区同学能够基于最新开发版本的 SOFABoot 进行开发学习，我们会发布当前开发分支的 SNAPSHOT 版本。为顺利从中央仓库拉取 SNAPSHOT 包，需要在本地 maven setting.xml 文件增加如下 profile 配置:\n\u0026amp;lt;profile\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;activation\u0026amp;gt; \u0026amp;lt;activeByDefault\u0026amp;gt;true\u0026amp;lt;/activeByDefault\u0026amp;gt; \u0026amp;lt;/activation\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;maven-snapshot\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://oss.sonatype.org/content/repositories/snapshots\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;/repositories\u0026amp;gt; \u0026amp;lt;pluginRepositories\u0026amp;gt; \u0026amp;lt;pluginRepository\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;maven-snapshot\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://oss.sonatype.org/content/repositories/snapshots\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;/pluginRepository\u0026amp;gt; \u0026amp;lt;/pluginRepositories\u0026amp;gt; \u0026amp;lt;/profile\u0026amp;gt;  目前 SOFABoot 最新版本为 3.1.0，基于 Spring Boot 2.1.0.RELEASE, 支持 JDK11。\n功能描述 SOFABoot 在 Spring Boot 基础上，提供了以下能力：\n 扩展 Spring Boot 健康检查的能力：在 Spring Boot 健康检查能力基础上，提供了 Readiness Check 的能力，保证应用实例安全上线。 提供模块化开发的能力：基于 Spring 上下文隔离提供模块化开发能力，每个 SOFABoot 模块使用独立的 Spring 上下文，避免不同 SOFABoot 模块间的 BeanId 冲突。 增加模块并行加载和 Spring Bean 异步初始化能力，加速应用启动； 增加日志空间隔离的能力：中间件框架自动发现应用的日志实现依赖并独立打印日志，避免中间件和应用日志实现绑定，通过 sofa-common-tools 实现。 增加类隔离的能力：基于 SOFAArk 框架提供类隔离能力，方便使用者解决各种类冲突问题。 增加中间件集成管理的能力：统一管控、提供中间件统一易用的编程接口、每一个 SOFA 中间件都是独立可插拔的组件。 提供完全兼容 Spring Boot的能力：SOFABoot 基于 Spring Boot 的基础上进行构建，并且完全兼容 Spring Boot。  应用场景 SOFABoot 本身就脱胎于蚂蚁金服内部对于 Spring Boot 的实践，补充了 Spring Boot 在大规模金融级生产场景下一些不足的地方，所以 SOFABoot 特别适合于这样的场景。\n当然，SOFABoot 的每个组件都是可选的，用户可以灵活选择其中的功能来使用，比如如果仅仅想在 Spring Boot 下面引入 SOFA 中间件，可以不需引入 SOFABoot 中的类隔离能力。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/overview/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"fe6aed461c61b86dfed846a2dc0b7dcb","permalink":"/projects/sofa-boot/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/overview/","summary":"SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等能力。在增强了 Spring Boot 的同时，SOFABo","tags":null,"title":"Halo Boot 介绍","type":"projects","url":"/projects/sofa-boot/overview/","wordcount":855},{"author":null,"categories":null,"content":" SOFABoot 提供三种方式给开发人员发布和引用 JVM 服务\n XML 方式 Annotation 方式 编程 API 方式  XML 方式 服务发布 首先需要定义一个 Bean：\n\u0026amp;lt;bean id=\u0026amp;quot;sampleService\u0026amp;quot; class=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleServiceImpl\u0026amp;quot;\u0026amp;gt;  然后通过 SOFA 提供的 Spring 扩展标签来将上面的 Bean 发布成一个 SOFA JVM 服务。\n\u0026amp;lt;sofa:service interface=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleService\u0026amp;quot; ref=\u0026amp;quot;sampleService\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.jvm/\u0026amp;gt; \u0026amp;lt;/sofa:service\u0026amp;gt;  上面的配置中的 interface 指的是需要发布成服务的接口，ref 指向的是需要发布成 JVM 服务的 Bean，至此，我们就已经完成了一个 JVM 服务的发布。\n服务引用 使用 SOFA 提供的 Spring 扩展标签引用服务:\n\u0026amp;lt;sofa:reference interface=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleService\u0026amp;quot; id=\u0026amp;quot;sampleServiceRef\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.jvm/\u0026amp;gt; \u0026amp;lt;/sofa:reference\u0026amp;gt;  上面的配置中的 interface 是服务的接口，需要和发布服务时配置的 interface 一致。id 属性的含义同 Spring BeanId。上面的配置会生成一个 id 为 sampleServiceRef 的 Spring Bean，你可以将 sampleServiceRef 这个 Bean 注入到当前 SOFABoot 模块 Spring 上下文的任意地方。\n service/reference 标签还支持 RPC 服务发布，相关文档: RPC 服务发布与引用\n Annotation 方式  警告\n如果一个服务已经被加上了 @SofaService 的注解，它就不能再用 XML 的方式去发布服务了，选择一种方式发布服务，而不是两种混用。\n 除了通过 XML 方式发布 JVM 服务和引用之外，SOFABoot 还提供了 Annotation 的方式来发布和引用 JVM 服务。通过 Annotation 方式发布 JVM 服务，只需要在实现类上加一个 @SofaService 注解即可，如下：\n@SofaService public class SampleImpl implements SampleInterface { public void test() { } }   提示\n@SofaService 的作用是将一个 Bean 发布成一个 JVM 服务，这意味着虽然你可以不用再写 \u0026amp;lt;sofa:service/\u0026amp;gt; 的配置，但是还是需要事先将 @SofaService 所注解的类配置成一个 Spring Bean。\n 在使用 XML 配置 \u0026amp;lt;sofa:service/\u0026amp;gt; 的时候，我们配置了一个 interface 属性，但是在使用 @SofaService 注解的时候，却没有看到有配置服务接口的地方。这是因为当被 @SofaService 注解的类只有一个接口的时候，框架会直接采用这个接口作为服务的接口。当被 @SofaService 注解的类实现了多个接口时，可以设置 @SofaService 的 interfaceType 字段来指定服务接口，比如下面这样：\n@SofaService(interfaceType=SampleInterface.class) public class SampleImpl implements SampleInterface, Serializable { public void test() { } }  和 @SofaService 对应，Sofa 提供了 @SofaReference 来引用一个 JVM 服务。假设我们需要在一个 Spring Bean 中使用 SampleJvmService 这个 JVM 服务，那么只需要在字段上加上一个 @SofaReference 的注解即可：\npublic class SampleServiceRef { @SofaReference private SampleService sampleService; }  和 @SofaService 类似，我们也没有在 @SofaReference 上指定服务接口，这是因为 @SofaReference 在不指定服务接口的时候，会采用被注解字段的类型作为服务接口，你也可以通过设定 @SofaReference 的 interfaceType 属性来指定：\npublic class SampleServiceRef { @SofaReference(interfaceType=SampleService.class) private SampleService sampleService; }  使用 @SofaService 注解发布服务时，需要在实现类上打上 @SofaService 注解；在 Spring Boot 使用 Bean Method 创建 Bean 时，会导致 @Bean 和 @SofaService 分散在两处，而且无法对同一个实现类使用不同的 unique id。因此自 SOFABoot v2.6.0 及 v3.1.0 版本起，支持 @SofaService 作用在 Bean Method 之上，例如：\n@Configuration public class SampleSofaServiceConfiguration { @Bean(\u0026amp;quot;sampleSofaService\u0026amp;quot;) @SofaService(uniqueId = \u0026amp;quot;service1\u0026amp;quot;) SampleService service() { return new SampleServiceImpl(\u0026amp;quot;\u0026amp;quot;); } }  同样为了方便在 Spring Boot Bean Method 使用注解 @SofaReference 引用服务，自 SOFABoot v2.6.0 及 v3.1.0 版本起，支持在 Bean Method 参数上使用 @SofaReference 注解引用 JVM 服务，例如：\n@Configuration public class MultiSofaReferenceConfiguration { @Bean(\u0026amp;quot;sampleReference\u0026amp;quot;) TestService …","date":-62135596800,"description":"","dir":"projects/moss/module-service/","fuzzywordcount":2000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"785457897eb4a3b0778bd5a44f86f723","permalink":"/projects/moss/module-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/moss/module-service/","summary":"SOFABoot 提供三种方式给开发人员发布和引用 JVM 服务 XML 方式 Annotation 方式 编程 API 方式 XML 方式 服务发布 首先需要定义一个 Bean： \u0026lt;bean id=\u0026quot;sampleService\u0026quot; class=\u0026quot;com.alipay.sofa.runtime.test.service.SampleServiceImpl\u0026quot;\u0026gt; 然后通过 SOFA 提供的 Spring 扩展标签来将上","tags":null,"title":"JVM 服务发布与引用","type":"projects","url":"/projects/moss/module-service/","wordcount":1926},{"author":null,"categories":null,"content":" SOFABoot 提供三种方式给开发人员发布和引用 JVM 服务\n XML 方式 Annotation 方式 编程 API 方式  XML 方式 服务发布 首先需要定义一个 Bean：\n\u0026amp;lt;bean id=\u0026amp;quot;sampleService\u0026amp;quot; class=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleServiceImpl\u0026amp;quot;\u0026amp;gt;  然后通过 SOFA 提供的 Spring 扩展标签来将上面的 Bean 发布成一个 SOFA JVM 服务。\n\u0026amp;lt;sofa:service interface=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleService\u0026amp;quot; ref=\u0026amp;quot;sampleService\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.jvm/\u0026amp;gt; \u0026amp;lt;/sofa:service\u0026amp;gt;  上面的配置中的 interface 指的是需要发布成服务的接口，ref 指向的是需要发布成 JVM 服务的 Bean，至此，我们就已经完成了一个 JVM 服务的发布。\n服务引用 使用 SOFA 提供的 Spring 扩展标签引用服务:\n\u0026amp;lt;sofa:reference interface=\u0026amp;quot;com.alipay.sofa.runtime.test.service.SampleService\u0026amp;quot; id=\u0026amp;quot;sampleServiceRef\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.jvm/\u0026amp;gt; \u0026amp;lt;/sofa:reference\u0026amp;gt;  上面的配置中的 interface 是服务的接口，需要和发布服务时配置的 interface 一致。id 属性的含义同 Spring BeanId。上面的配置会生成一个 id 为 sampleServiceRef 的 Spring Bean，你可以将 sampleServiceRef 这个 Bean 注入到当前 SOFABoot 模块 Spring 上下文的任意地方。\n service/reference 标签还支持 RPC 服务发布，相关文档: RPC 服务发布与引用\n Annotation 方式  警告\n如果一个服务已经被加上了 @SofaService 的注解，它就不能再用 XML 的方式去发布服务了，选择一种方式发布服务，而不是两种混用。\n 除了通过 XML 方式发布 JVM 服务和引用之外，SOFABoot 还提供了 Annotation 的方式来发布和引用 JVM 服务。通过 Annotation 方式发布 JVM 服务，只需要在实现类上加一个 @SofaService 注解即可，如下：\n@SofaService public class SampleImpl implements SampleInterface { public void test() { } }   提示\n@SofaService 的作用是将一个 Bean 发布成一个 JVM 服务，这意味着虽然你可以不用再写 \u0026amp;lt;sofa:service/\u0026amp;gt; 的配置，但是还是需要事先将 @SofaService 所注解的类配置成一个 Spring Bean。\n 在使用 XML 配置 \u0026amp;lt;sofa:service/\u0026amp;gt; 的时候，我们配置了一个 interface 属性，但是在使用 @SofaService 注解的时候，却没有看到有配置服务接口的地方。这是因为当被 @SofaService 注解的类只有一个接口的时候，框架会直接采用这个接口作为服务的接口。当被 @SofaService 注解的类实现了多个接口时，可以设置 @SofaService 的 interfaceType 字段来指定服务接口，比如下面这样：\n@SofaService(interfaceType=SampleInterface.class) public class SampleImpl implements SampleInterface, Serializable { public void test() { } }  和 @SofaService 对应，Sofa 提供了 @SofaReference 来引用一个 JVM 服务。假设我们需要在一个 Spring Bean 中使用 SampleJvmService 这个 JVM 服务，那么只需要在字段上加上一个 @SofaReference 的注解即可：\npublic class SampleServiceRef { @SofaReference private SampleService sampleService; }  和 @SofaService 类似，我们也没有在 @SofaReference 上指定服务接口，这是因为 @SofaReference 在不指定服务接口的时候，会采用被注解字段的类型作为服务接口，你也可以通过设定 @SofaReference 的 interfaceType 属性来指定：\npublic class SampleServiceRef { @SofaReference(interfaceType=SampleService.class) private SampleService sampleService; }  使用 @SofaService 注解发布服务时，需要在实现类上打上 @SofaService 注解；在 Spring Boot 使用 Bean Method 创建 Bean 时，会导致 @Bean 和 @SofaService 分散在两处，而且无法对同一个实现类使用不同的 unique id。因此自 SOFABoot v2.6.0 及 v3.1.0 版本起，支持 @SofaService 作用在 Bean Method 之上，例如：\n@Configuration public class SampleSofaServiceConfiguration { @Bean(\u0026amp;quot;sampleSofaService\u0026amp;quot;) @SofaService(uniqueId = \u0026amp;quot;service1\u0026amp;quot;) SampleService service() { return new SampleServiceImpl(\u0026amp;quot;\u0026amp;quot;); } }  同样为了方便在 Spring Boot Bean Method 使用注解 @SofaReference 引用服务，自 SOFABoot v2.6.0 及 v3.1.0 版本起，支持在 Bean Method 参数上使用 @SofaReference 注解引用 JVM 服务，例如：\n@Configuration public class MultiSofaReferenceConfiguration { @Bean(\u0026amp;quot;sampleReference\u0026amp;quot;) TestService …","date":-62135596800,"description":"","dir":"projects/sofa-boot/module-service/","fuzzywordcount":2000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"527472fbe57ce450e4e2b41d878704cb","permalink":"/projects/sofa-boot/module-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/sofa-boot/module-service/","summary":"SOFABoot 提供三种方式给开发人员发布和引用 JVM 服务 XML 方式 Annotation 方式 编程 API 方式 XML 方式 服务发布 首先需要定义一个 Bean： \u0026lt;bean id=\u0026quot;sampleService\u0026quot; class=\u0026quot;com.alipay.sofa.runtime.test.service.SampleServiceImpl\u0026quot;\u0026gt; 然后通过 SOFA 提供的 Spring 扩展标签来将上","tags":null,"title":"JVM 服务发布与引用","type":"projects","url":"/projects/sofa-boot/module-service/","wordcount":1926},{"author":null,"categories":null,"content":" SOFAArk 是一款基于 Java 实现的轻量级类隔离容器，主要提供类隔离和应用(模块)合并部署能力，由蚂蚁金服公司开源贡献；\n在大型软件开发过程中，通常会推荐底层功能插件化，业务功能模块化的开发模式，以期达到低耦合、高内聚、功能复用的优点。基于此，SOFAArk 提供了一套较为规范化的插件化、模块化的开发方案，产品能力主要包括：\n 定义类加载模型，运行时底层插件、业务应用(模块)之间均相互隔离，单一插件和应用(模块)由不同的 ClassLoader 加载，可以有效避免相互之间的包冲突，提升插件和模块功能复用能力； 定义插件开发规范，提供 maven 打包工具，简单快速将多个二方包打包成插件（Ark Plugin，以下简称 Plugin） 定义模块开发规范，提供 maven 打包工具，简单快速将应用打包成模块 (Ark Biz，以下简称 Biz) 针对 Plugin、Biz 提供标准的编程界面，包括服务、事件、扩展点等机制 支持多 Biz 的合并部署，开发阶段将多个 Biz 打包成可执行 Fat Jar，或者运行时使用 API 或配置中心(Zookeeper)动态地安装卸载 Biz  基于以上能力，SOFAArk 可以帮助解决依赖包冲突、多应用(模块)合并部署等场景问题。\n场景 包冲突 日常使用 Java 开发，常常会遇到包依赖冲突的问题，尤其当应用变得臃肿庞大，包冲突的问题也会变得更加棘手，导致各种各样的报错，例如 LinkageError, NoSuchMethodError 等；实际开发中，可以采用多种方法来解决包冲突问题，比较常见的是类似 Spring Boot 的做法，统一管理应用所有依赖包的版本，保证这些三方包不存在依赖冲突；这种做法只能有效避免包冲突问题，不能根本上解决包冲突的问题；如果某个应用的确需要在运行时使用两个相互冲突的包，例如 protobuf2 和 protobuf3，那么类似 Spring Boot 的做法依然解决不了问题。\n为了彻底解决包冲突的问题，需要借助类隔离机制，使用不同的 ClassLoader 加载不同版本的三方依赖，进而隔离包冲突问题； OSGI 作为业内最出名的类隔离框架，自然是可以被用于解决上述包冲突问题，但是 OSGI 框架太过臃肿，功能繁杂；为了解决包冲突问题，引入 OSGI 框架，有牛刀杀鸡之嫌，且反而使工程变得更加复杂，不利于开发；\nSOFAArk 采用轻量级的类隔离方案来解决日常经常遇到的包冲突问题，在蚂蚁金服内部服务于整个 SOFABoot 技术体系，弥补 Spring Boot 没有的类隔离能力。SOFAArk 提出了一种特殊的包结构 \u0026amp;ndash; Ark Plugin，在遇到包冲突时，用户可以使用 Maven 插件将若干冲突包打包成 Plugin，运行时由独立的 PluginClassLoader 加载，从而解决包冲突。\n假设如下场景，如果工程需要引入两个三方包：A 和 B，但是 A 需要依赖版本号为 0.1 的 C 包，而恰好 B 需要依赖版本号为 0.2 的 C 包，且 C 包的这两个版本无法兼容：\n此时，即可使用 SOFAArk 解决该依赖冲突问题；只需要把 A 和版本为 0.1 的 C 包一起打包成一个 Ark 插件，然后让应用工程引入该插件依赖即可；\n合并部署 复杂项目通常需要跨团队协作开发，各自负责不同的组件，而众所周知，协调跨团队合作开发会遇到不少问题；比如各自技术栈不统一导致的依赖冲突，又比如往同一个 Git 仓库提交代码常常导致 merge 冲突。因此，如果能让每个团队将负责的功能组件当成一个个单独的应用开发，运行时合并部署，通过统一的编程界面交互，那么将极大的提升开发效率及应用可扩展性。SOFAArk 提出了一种特殊的包结构 \u0026amp;ndash; Ark Biz，用户可以使用 Maven 插件将应用打包成 Biz，允许多 Biz 在 SOFAArk 容器之上合并部署，并通过统一的编程界面交互。\n静态合并部署 SOFAArk 提供了静态合并部署能力，在开发阶段，应用可以将其他应用打成的 Biz 包通过 Maven 依赖的方式引入，而当自身被打成可执行 Fat Jar 时，可以将其他应用 Biz 包一并打入，启动时，则会根据优先级依次启动各应用。每个 Biz 使用独立的 BizClassLoader 加载，不需要考虑相互依赖冲突问题，Biz 之间则通过 SofaService/SofaRefernece JVM 服务进行交互。\n动态合并部署 动态合并部署区别于静态合并部署最大的一点是，运行时通过 API 或者配置中心（Zookeeper）来控制 Biz 的部署和卸载。动态合并部署的设计理念图如下：\n无论是静态还是动态合并部署都会有宿主应用（master biz）的概念, 如果 Ark 包只打包了一个 Biz，则该 Biz 默认成为宿主应用；如果 Ark 包打包了多个 Biz 包，需要配置指定宿主应用。宿主应用不允许被卸载，一般而言，宿主应用会作为流量入口的中台系统，具体的服务实现会放在不同的动态 Biz 中，供宿主应用调用。宿主应用可以使用 SOFAArk 提供的客户端 API 实现动态应用的部署和卸载。除了 API, SOFAArk 提供了 Config Plugin，用于对接配置中心（目前支持 Zookeeper），运行时接受动态配置；Config Plugin 会解析下发的配置，控制动态应用的部署和卸载。\n原理 SOFAArk 包含三个概念，Ark Container, Ark Plugin 和 Ark Biz; 运行时逻辑结构图如下:\n在介绍这三个概念之前，先介绍上述 Ark 包概念；Ark 包是满足特定目录格式要求的可运行 Fat Jar，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将单个或多个应用打包成标准格式的 Ark 包；使用 java -jar 命令即可在 SOFAArk 容器之上启动所有应用；Ark 包通常包含 Ark Container、Ark Plugin 和 Ark Biz；以下我们针对这三个概念简单做下名词解释：\n Ark Container: SOFAArk 容器，负责 Ark 包启动运行时的管理；Ark Plugin 和 Ark Biz 运行在 SOFAArk 容器之上；容器具备管理插件和应用的功能；容器启动成功后，会自动解析 classpath 包含的 Ark Plugin 和 Ark Biz 依赖，完成隔离加载并按优先级依次启动之；\n Ark Plugin: Ark 插件，满足特定目录格式要求的 Fat Jar，使用官方提供的 Maven 插件 sofa-ark-plugin-maven-plugin 可以将一个或多个普通的 Java jar 打包成一个标准格式的 Ark Plugin；Ark Plugin 会包含一份配置文件，通常包括插件类导入导出配置、资源导入导出配置、插件启动优先级等；运行时，SOFAArk 容器会使用独立的 PluginClassLoader加载插件，并根据插件配置构建类加载索引表、资源加载索引表，使插件和插件之 …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-readme/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"69e977557b994876ced12e8db85f8342","permalink":"/projects/moss/sofa-ark-readme/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/projects/moss/sofa-ark-readme/","summary":"SOFAArk 是一款基于 Java 实现的轻量级类隔离容器，主要提供类隔离和应用(模块)合并部署能力，由蚂蚁金服公司开源贡献； 在大型软件开发过程中，通常会推荐底层","tags":null,"title":"SOFAArk 介绍","type":"projects","url":"/projects/moss/sofa-ark-readme/","wordcount":2577},{"author":null,"categories":null,"content":" SOFAArk 是一款基于 Java 实现的轻量级类隔离容器，主要提供类隔离和应用(模块)合并部署能力，由蚂蚁金服公司开源贡献；\n在大型软件开发过程中，通常会推荐底层功能插件化，业务功能模块化的开发模式，以期达到低耦合、高内聚、功能复用的优点。基于此，SOFAArk 提供了一套较为规范化的插件化、模块化的开发方案，产品能力主要包括：\n 定义类加载模型，运行时底层插件、业务应用(模块)之间均相互隔离，单一插件和应用(模块)由不同的 ClassLoader 加载，可以有效避免相互之间的包冲突，提升插件和模块功能复用能力； 定义插件开发规范，提供 maven 打包工具，简单快速将多个二方包打包成插件（Ark Plugin，以下简称 Plugin） 定义模块开发规范，提供 maven 打包工具，简单快速将应用打包成模块 (Ark Biz，以下简称 Biz) 针对 Plugin、Biz 提供标准的编程界面，包括服务、事件、扩展点等机制 支持多 Biz 的合并部署，开发阶段将多个 Biz 打包成可执行 Fat Jar，或者运行时使用 API 或配置中心(Zookeeper)动态地安装卸载 Biz  基于以上能力，SOFAArk 可以帮助解决依赖包冲突、多应用(模块)合并部署等场景问题。\n场景 包冲突 日常使用 Java 开发，常常会遇到包依赖冲突的问题，尤其当应用变得臃肿庞大，包冲突的问题也会变得更加棘手，导致各种各样的报错，例如 LinkageError, NoSuchMethodError 等；实际开发中，可以采用多种方法来解决包冲突问题，比较常见的是类似 Spring Boot 的做法，统一管理应用所有依赖包的版本，保证这些三方包不存在依赖冲突；这种做法只能有效避免包冲突问题，不能根本上解决包冲突的问题；如果某个应用的确需要在运行时使用两个相互冲突的包，例如 protobuf2 和 protobuf3，那么类似 Spring Boot 的做法依然解决不了问题。\n为了彻底解决包冲突的问题，需要借助类隔离机制，使用不同的 ClassLoader 加载不同版本的三方依赖，进而隔离包冲突问题； OSGI 作为业内最出名的类隔离框架，自然是可以被用于解决上述包冲突问题，但是 OSGI 框架太过臃肿，功能繁杂；为了解决包冲突问题，引入 OSGI 框架，有牛刀杀鸡之嫌，且反而使工程变得更加复杂，不利于开发；\nSOFAArk 采用轻量级的类隔离方案来解决日常经常遇到的包冲突问题，在蚂蚁金服内部服务于整个 SOFABoot 技术体系，弥补 Spring Boot 没有的类隔离能力。SOFAArk 提出了一种特殊的包结构 \u0026amp;ndash; Ark Plugin，在遇到包冲突时，用户可以使用 Maven 插件将若干冲突包打包成 Plugin，运行时由独立的 PluginClassLoader 加载，从而解决包冲突。\n假设如下场景，如果工程需要引入两个三方包：A 和 B，但是 A 需要依赖版本号为 0.1 的 C 包，而恰好 B 需要依赖版本号为 0.2 的 C 包，且 C 包的这两个版本无法兼容：\n此时，即可使用 SOFAArk 解决该依赖冲突问题；只需要把 A 和版本为 0.1 的 C 包一起打包成一个 Ark 插件，然后让应用工程引入该插件依赖即可；\n合并部署 复杂项目通常需要跨团队协作开发，各自负责不同的组件，而众所周知，协调跨团队合作开发会遇到不少问题；比如各自技术栈不统一导致的依赖冲突，又比如往同一个 Git 仓库提交代码常常导致 merge 冲突。因此，如果能让每个团队将负责的功能组件当成一个个单独的应用开发，运行时合并部署，通过统一的编程界面交互，那么将极大的提升开发效率及应用可扩展性。SOFAArk 提出了一种特殊的包结构 \u0026amp;ndash; Ark Biz，用户可以使用 Maven 插件将应用打包成 Biz，允许多 Biz 在 SOFAArk 容器之上合并部署，并通过统一的编程界面交互。\n静态合并部署 SOFAArk 提供了静态合并部署能力，在开发阶段，应用可以将其他应用打成的 Biz 包通过 Maven 依赖的方式引入，而当自身被打成可执行 Fat Jar 时，可以将其他应用 Biz 包一并打入，启动时，则会根据优先级依次启动各应用。每个 Biz 使用独立的 BizClassLoader 加载，不需要考虑相互依赖冲突问题，Biz 之间则通过 SofaService/SofaRefernece JVM 服务进行交互。\n动态合并部署 动态合并部署区别于静态合并部署最大的一点是，运行时通过 API 或者配置中心（Zookeeper）来控制 Biz 的部署和卸载。动态合并部署的设计理念图如下：\n无论是静态还是动态合并部署都会有宿主应用（master biz）的概念, 如果 Ark 包只打包了一个 Biz，则该 Biz 默认成为宿主应用；如果 Ark 包打包了多个 Biz 包，需要配置指定宿主应用。宿主应用不允许被卸载，一般而言，宿主应用会作为流量入口的中台系统，具体的服务实现会放在不同的动态 Biz 中，供宿主应用调用。宿主应用可以使用 SOFAArk 提供的客户端 API 实现动态应用的部署和卸载。除了 API, SOFAArk 提供了 Config Plugin，用于对接配置中心（目前支持 Zookeeper），运行时接受动态配置；Config Plugin 会解析下发的配置，控制动态应用的部署和卸载。\n原理 SOFAArk 包含三个概念，Ark Container, Ark Plugin 和 Ark Biz; 运行时逻辑结构图如下:\n在介绍这三个概念之前，先介绍上述 Ark 包概念；Ark 包是满足特定目录格式要求的可运行 Fat Jar，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将单个或多个应用打包成标准格式的 Ark 包；使用 java -jar 命令即可在 SOFAArk 容器之上启动所有应用；Ark 包通常包含 Ark Container、Ark Plugin 和 Ark Biz；以下我们针对这三个概念简单做下名词解释：\n Ark Container: SOFAArk 容器，负责 Ark 包启动运行时的管理；Ark Plugin 和 Ark Biz 运行在 SOFAArk 容器之上；容器具备管理插件和应用的功能；容器启动成功后，会自动解析 classpath 包含的 Ark Plugin 和 Ark Biz 依赖，完成隔离加载并按优先级依次启动之；\n Ark Plugin: Ark 插件，满足特定目录格式要求的 Fat Jar，使用官方提供的 Maven 插件 sofa-ark-plugin-maven-plugin 可以将一个或多个普通的 Java jar 打包成一个标准格式的 Ark Plugin；Ark Plugin 会包含一份配置文件，通常包括插件类导入导出配置、资源导入导出配置、插件启动优先级等；运行时，SOFAArk 容器会使用独立的 PluginClassLoader加载插件，并根据插件配置构建类加载索引表、资源加载索引表，使插件和插件之 …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-readme/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"cdb6729fc7a63954b7559c8ea319f550","permalink":"/projects/sofa-boot/sofa-ark-readme/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/projects/sofa-boot/sofa-ark-readme/","summary":"SOFAArk 是一款基于 Java 实现的轻量级类隔离容器，主要提供类隔离和应用(模块)合并部署能力，由蚂蚁金服公司开源贡献； 在大型软件开发过程中，通常会推荐底层","tags":null,"title":"SOFAArk 介绍","type":"projects","url":"/projects/sofa-boot/sofa-ark-readme/","wordcount":2577},{"author":null,"categories":null,"content":" SOFAArk 的配置目录不是必须存在，如果需要，统一放在工程根目录 ${baseDir}/conf/ark 下，执行 sofa-ark-maven-plugin 打包，将会自动将该目录下的配置打包至 Ark 包，例如 Ark 包目录为：\n. ├── META-INF │ └── MANIFEST.MF ├── SOFA-ARK │ ├── biz │ │ └── demo-0.0.1-SNAPSHOT-ark-biz.jar │ └── container │ └── sofa-ark-all-0.6.0-SNAPSHOT.jar ├── com │ └── alipay │ └── sofa │ └── ark │ ├── ... │ └── conf └── ark ├── bootstrap-dev.properties ├── bootstrap.properties └── log └── logback-conf.xml  注意事项：如果应用中包含 SOFAArk 配置，打包时需要注意 baseDir 配置，用于指定工程根目录，具体参考文档\n上述 conf/ark 目录中可以配置 SOFAArk 容器启动配置以及日志配置，下面介绍配置的使用.\nconf/ark/bootstrap.properties 是 SOFAArk 容器默认启动配置文件，配置内容包括：日志配置、plugin 激活和钝化配置、biz 激活和钝化配置.\n日志配置 SOFAArk 容器日志内部实现使用 logback, 日志配置参数包括： + logging.path \u0026amp;gt; 容器日志目录根路径，这里只影响 SOFAArk 容器日志路径，不影响应用日志，应用自身日志由自身配置决定，默认打印在 ${user.admin}/logs 目录\n logging.level.com.alipay.sofa.ark \u0026amp;gt; 设置 SOFAArk 容器日志级别，默认为 INFO\n logging.config.com.alipay.sofa.ark \u0026amp;gt; 指定自定义日志配置文件名，用于覆盖 SOFAArk 容器自带的日志配置文件。建议自定义配置文件放在 conf/ark/log 目录中\n sofa.middleware.log.com.alipay.sofa.ark.console \u0026amp;gt; 配置容器日志是否打印在 console，默认为 false.\n sofa.middleware.log.com.alipay.sofa.ark.console.level \u0026amp;gt; 配合上述配置项使用，如果打印在 console ，该配置项用于配置 SOFAArk 容器打印在 console 的日志级别\n  插件配置  ark.plugin.active.include \u0026amp;gt; 指定激活哪些插件，多个插件使用 \u0026amp;lsquo;,\u0026amp;rsquo; 分隔；默认激活 Ark 包中所有的插件。\n ark.plugin.active.exclude \u0026amp;gt; 指定排除哪些插件，多个插件使用 \u0026amp;lsquo;,\u0026amp;rsquo; 分隔；默认为空\n  注：如果同时配置了这两个属性，以 ark.plugin.active.include 为准\nbiz配置  ark.biz.active.include \u0026amp;gt; 指定激活哪些 Biz，多个 Biz 使用 \u0026amp;lsquo;,\u0026amp;rsquo; 分隔；默认激活 Ark 包中所有的 Biz.\n ark.biz.active.exclude \u0026amp;gt; 指定排除哪些 Biz，多个 Biz 使用 \u0026amp;lsquo;,\u0026amp;rsquo; 分隔；默认为空\n com.alipay.sofa.ark.master.biz \u0026amp;gt; 指定宿主 Biz 名，如果 Ark 包中只有一个 Biz，则不用设置，默认设置为宿主 Biz; 否则需要显示设置\n  注：如果同时配置了前两个属性，以 ark.biz.active.include 为准\n动态配置 SOFAArk 提供了对接 Zookeeper 的插件，目前用于动态接收 Biz 指令，目前只支持 Zookeeper，配置格式如下：\ncom.alipay.sofa.ark.config.address=zookeeper://ip:port?key1=value1\u0026amp;amp;key2=value2  特别注意，SOFAArk 有一个默认的逻辑，如果用户配置了 com.alipay.sofa.ark.config.address，且 Ark 包中打入了多个 Biz，则只会启动宿主应用(master biz)；这样做的原因是如果配置了动态配置，SOFAArk 会优先根据动态配置控制 Biz 的部署。\nProfile 机制 默认 SOFAArk 容器使用 bootstrap.properties 配置，实际开发中，可能根据运行环境加载不同的配置，SOFAArk 提供了 profile 机制. 指定 profile 值，SOFAArk 容器会加载 bootstrap-${profile}.properties 配置文件。指定 profile 的配置有两种方式： + 通过 -D VM 参数传入，例如：-Dark.profile=dev,dev2 多个值使用 \u0026amp;lsquo;,\u0026amp;rsquo; 隔开。 + 通过应用启动参数传入，例如：java -jar demo-executable-ark.jar -Aprofile=dev,dev2 多个值使用 \u0026amp;lsquo;,\u0026amp;rsquo; 隔开。\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-config/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3e45c194dab76880b478217f503d9b70","permalink":"/projects/moss/sofa-ark-ark-config/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-ark-config/","summary":"SOFAArk 的配置目录不是必须存在，如果需要，统一放在工程根目录 ${baseDir}/conf/ark 下，执行 sofa-ark-maven-plugin 打包，将会自动将该目录下的配置打包至 Ark 包，例如 Ark 包目录为： . ├── META-INF │ └─","tags":null,"title":"SOFAArk 配置","type":"projects","url":"/projects/moss/sofa-ark-ark-config/","wordcount":1036},{"author":null,"categories":null,"content":" SOFAArk 的配置目录不是必须存在，如果需要，统一放在工程根目录 ${baseDir}/conf/ark 下，执行 sofa-ark-maven-plugin 打包，将会自动将该目录下的配置打包至 Ark 包，例如 Ark 包目录为：\n. ├── META-INF │ └── MANIFEST.MF ├── SOFA-ARK │ ├── biz │ │ └── demo-0.0.1-SNAPSHOT-ark-biz.jar │ └── container │ └── sofa-ark-all-0.6.0-SNAPSHOT.jar ├── com │ └── alipay │ └── sofa │ └── ark │ ├── ... │ └── conf └── ark ├── bootstrap-dev.properties ├── bootstrap.properties └── log └── logback-conf.xml  注意事项：如果应用中包含 SOFAArk 配置，打包时需要注意 baseDir 配置，用于指定工程根目录，具体参考文档\n上述 conf/ark 目录中可以配置 SOFAArk 容器启动配置以及日志配置，下面介绍配置的使用.\nconf/ark/bootstrap.properties 是 SOFAArk 容器默认启动配置文件，配置内容包括：日志配置、plugin 激活和钝化配置、biz 激活和钝化配置.\n日志配置 SOFAArk 容器日志内部实现使用 logback, 日志配置参数包括： + logging.path \u0026amp;gt; 容器日志目录根路径，这里只影响 SOFAArk 容器日志路径，不影响应用日志，应用自身日志由自身配置决定，默认打印在 ${user.admin}/logs 目录\n logging.level.com.alipay.sofa.ark \u0026amp;gt; 设置 SOFAArk 容器日志级别，默认为 INFO\n logging.config.com.alipay.sofa.ark \u0026amp;gt; 指定自定义日志配置文件名，用于覆盖 SOFAArk 容器自带的日志配置文件。建议自定义配置文件放在 conf/ark/log 目录中\n sofa.middleware.log.com.alipay.sofa.ark.console \u0026amp;gt; 配置容器日志是否打印在 console，默认为 false.\n sofa.middleware.log.com.alipay.sofa.ark.console.level \u0026amp;gt; 配合上述配置项使用，如果打印在 console ，该配置项用于配置 SOFAArk 容器打印在 console 的日志级别\n  插件配置  ark.plugin.active.include \u0026amp;gt; 指定激活哪些插件，多个插件使用 \u0026amp;lsquo;,\u0026amp;rsquo; 分隔；默认激活 Ark 包中所有的插件。\n ark.plugin.active.exclude \u0026amp;gt; 指定排除哪些插件，多个插件使用 \u0026amp;lsquo;,\u0026amp;rsquo; 分隔；默认为空\n  注：如果同时配置了这两个属性，以 ark.plugin.active.include 为准\nbiz配置  ark.biz.active.include \u0026amp;gt; 指定激活哪些 Biz，多个 Biz 使用 \u0026amp;lsquo;,\u0026amp;rsquo; 分隔；默认激活 Ark 包中所有的 Biz.\n ark.biz.active.exclude \u0026amp;gt; 指定排除哪些 Biz，多个 Biz 使用 \u0026amp;lsquo;,\u0026amp;rsquo; 分隔；默认为空\n com.alipay.sofa.ark.master.biz \u0026amp;gt; 指定宿主 Biz 名，如果 Ark 包中只有一个 Biz，则不用设置，默认设置为宿主 Biz; 否则需要显示设置\n  注：如果同时配置了前两个属性，以 ark.biz.active.include 为准\n动态配置 SOFAArk 提供了对接 Zookeeper 的插件，目前用于动态接收 Biz 指令，目前只支持 Zookeeper，配置格式如下：\ncom.alipay.sofa.ark.config.address=zookeeper://ip:port?key1=value1\u0026amp;amp;key2=value2  特别注意，SOFAArk 有一个默认的逻辑，如果用户配置了 com.alipay.sofa.ark.config.address，且 Ark 包中打入了多个 Biz，则只会启动宿主应用(master biz)；这样做的原因是如果配置了动态配置，SOFAArk 会优先根据动态配置控制 Biz 的部署。\nProfile 机制 默认 SOFAArk 容器使用 bootstrap.properties 配置，实际开发中，可能根据运行环境加载不同的配置，SOFAArk 提供了 profile 机制. 指定 profile 值，SOFAArk 容器会加载 bootstrap-${profile}.properties 配置文件。指定 profile 的配置有两种方式： + 通过 -D VM 参数传入，例如：-Dark.profile=dev,dev2 多个值使用 \u0026amp;lsquo;,\u0026amp;rsquo; 隔开。 + 通过应用启动参数传入，例如：java -jar demo-executable-ark.jar -Aprofile=dev,dev2 多个值使用 \u0026amp;lsquo;,\u0026amp;rsquo; 隔开。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-config/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"70dd9c389e65ee3f89573cf93bd466ec","permalink":"/projects/sofa-boot/sofa-ark-ark-config/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-config/","summary":"SOFAArk 的配置目录不是必须存在，如果需要，统一放在工程根目录 ${baseDir}/conf/ark 下，执行 sofa-ark-maven-plugin 打包，将会自动将该目录下的配置打包至 Ark 包，例如 Ark 包目录为： . ├── META-INF │ └─","tags":null,"title":"SOFAArk 配置","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-config/","wordcount":1036},{"author":null,"categories":null,"content":" 功能架构 SOFABolt　的基础功能：  基础通信功能 ( remoting-core )  基于 Netty 高效的网络 IO 与线程模型运用 连接管理 (无锁建连，定时断链，自动重连) 基础通信模型 ( oneway，sync，future，callback ) 超时控制 批量解包与批量提交处理器 心跳与 IDLE 事件处理  协议框架 ( protocol-skeleton )  命令与命令处理器 编解码处理器 心跳触发器  私有协议定制实现 - RPC 通信协议 ( protocol-implementation )  RPC 通信协议的设计 灵活的反序列化时机控制 请求处理超时 FailFast 机制 用户请求处理器 ( UserProcessor ) 双工通信   用法1 将 SOFABolt 用作一个远程通信框架，使用者可以不用关心如何实现一个私有协议的细节，直接使用我们内置的 RPC 通信协议。可以非常简单的启动客户端与服务端，同时注册一个用户请求处理器，即可完成远程调用。同时，像连接管理、心跳等基础功能特性都默认可以使用。 当前支持的调用类型如下图所示：\n 示例 Demo 请参考我们的 用户手册  用法2 将 SOFABolt 用作一个协议框架，使用者可以复用基础的通信模型、协议包含的接口定义等基础功能。然后根据自己设计的私有协议自定义 Command 类型、Command 处理器、编解码处理器等。如下图所示，RPC 和消息的 Command 定义结构：\n","date":-62135596800,"description":"","dir":"projects/sofa-bolt/sofa-bolt-functions/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"fde29139cbd8b786326a6479e52814dd","permalink":"/projects/sofa-bolt/sofa-bolt-functions/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-bolt/sofa-bolt-functions/","summary":"功能架构 SOFABolt 的基础功能： 基础通信功能 ( remoting-core ) 基于 Netty 高效的网络 IO 与线程模型运用 连接管理 (无锁建连，定时断链，自动重连) 基础通信模型 ( oneway，","tags":null,"title":"SOFABolt 功能介绍","type":"projects","url":"/projects/sofa-bolt/sofa-bolt-functions/","wordcount":450},{"author":null,"categories":null,"content":" 参与贡献 开放代码允许在签署协议之后,提交贡献代码.\n版权协议 对 SOFABolt 代码的修改和变更，需要遵守版权协议\n准备工作 贡献代码前需要先了解git工具的使用和GitHub网站的使用。 git 工具用法可以查看git官方书籍,需要阅读前几章来熟悉。 git 协作流程可以查看这篇文章Git协作流程\nGitHub 贡献代码流程 提issue 不论你是修复 Bolt 的bug还是新增 Bolt 的功能，在你提交代码之前，在 Bolt 的GitHub上提交一个 issue, 描述你要修复的问题或者要增加的功能。这么做有几个好处: 不会与其它开发者或是他们对这个项目的计划发生冲突,产生重复工作. Bolt 的维护人员会对你提的bug或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。 在达成一致后再开发,并提交代码，减少双方沟通成本，也减少pull request被拒绝的情况。\n获取源码 要修改或新增功能，在提issue后，点击左上角的fork按钮，复制一份 Bolt 主干代码到你的代码仓库。\n拉分支 Bolt 所有修改都在分支上进行，修改完后提交 pull request ， 在code review 后由项目维护人员 merge 到主干。 因此，在获取源码步骤介绍后，你需要： * 下载代码到本地,这一步你可以选择git/https方式.\ngit clone https://github.com/ant-tech-alliance/bolt.git   拉分支准备修改代码  git branch add_xxx_feature   执行完上述命令后，你的代码仓库就切换到相应分支了。执行如下命令可以看到你当前分支：  git branch -a   如果你想切换回主干，执行下面命令:  git checkout -b master   如果你想切换回分支，执行下面命令：  git checkout -b \u0026amp;quot;branchName\u0026amp;quot;   想直接从github上拉取分支到本地  git clone -b branchname https://xxx.git  修改代码提交到本地 拉完分支后，就可以修改代码了。\n修改代码注意事项  代码风格保持一致 Bolt 通过 Maven插件来保持代码格式一致.在提交代码前,务必本地执行  mvn clean package   补充单元测试代码 新有修改应该通过已有的单元测试. 应该提供新的单元测试来证明以前的代码存在bugs，而新的代码已经解决了这些bugs.  你可以用如下命令运行所有测试\nmvn clean test  也可以通过IDE来辅助运行.\n其它注意事项  请保持你编辑的代码的原有风格,尤其是空格换行等. 对于无用的注释, 请直接删除 对逻辑和功能不容易被理解的地方添加注释. 及时更新文档 修改完代码后，执行如下命令提交所有修改到本地:  git commit -am \u0026#39;添加xx功能\u0026#39;  提交代码到远程仓库 在代码提交到本地后，就是与远程仓库同步代码了。执行如下命令提交本地修改到github上：\ngit push origin \u0026amp;quot;branchname\u0026amp;quot;  如果前面你是通过fork来做的,那么那么这里的 origin 是push到你的代码仓库，而不是 Bolt 的代码仓库.\n提交合并代码到主干的请求 在你的代码提交到GitHub后，你就可以发送请求来把你改好的代码合入 Bolt 主干代码了。此时你需要进入你的 GitHub 上的对应仓库，按右上角的 pull request按钮。选择目标分支,一般就是主干master, 系统会通知 Bolt 的人员，Bolt 人员会 review 你的代码，符合要求后就会合入主干，成为 Bolt 主干代码的一部分。\n代码review 在你提交代码后，你的代码会被指派给维护人员review,请保持耐心。如果在数天后，仍然没有人对你的提交给予任何回复，可以在pull request下面留言,并@对应的人员. 对于代码review的意见会提交到对应issue。如果觉得建议是合理的，也请你把这些建议更新到你的补丁中。\n合并代码到主干 在代码 Bolt 通过后，就由 Bolt 维护人员操作合入主干了。这一步不用参与,review合并之后,你会收到合并成功的提示.\nContributing to SOFABolt SOFABolt is released under the Apache 2.0 license, and follows a very standard Github development process, using Github tracker for issues and merging pull requests into master . If you would like to contribute something, or simply want to hack on the code this document should help you get started.\nSign the Contributor License Agreement Before we accept a non-trivial patch or pull request we will need you to sign the Contributor License Agreement. Signing the contributor’s agreement does not grant anyone commit rights to the main repository, but it does mean that we can accept your contributions, and you will get an author credit if we do. Active contributors might be asked to join the core team, and given the ability to merge pull requests.\nCode Conventions None of these is essential for a pull request, but they will all help.\n we provided a code formatter file, it will formatting automatically your project when during process of building.\n Make sure all new .java files to have a simple Javadoc class comment with at least an @author tag identifying you, and preferably at least a paragraph on what the class is for.\n Add the …","date":-62135596800,"description":"","dir":"projects/sofa-bolt/sofa-bolt-contribution/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c044ad534cf99e4d6d400113b490f816","permalink":"/projects/sofa-bolt/sofa-bolt-contribution/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/sofa-bolt/sofa-bolt-contribution/","summary":"参与贡献 开放代码允许在签署协议之后,提交贡献代码. 版权协议 对 SOFABolt 代码的修改和变更，需要遵守版权协议 准备工作 贡献代码前需要先了解git工具的使用","tags":null,"title":"SOFABolt 参与贡献","type":"projects","url":"/projects/sofa-bolt/sofa-bolt-contribution/","wordcount":1647},{"author":null,"categories":null,"content":" 发展路线 Version 1.5.1  修复项目中代码风格的问题：https://github.com/alipay/sofa-bolt/issues/85 修复项目中已知的BUG：https://github.com/alipay/sofa-bolt/issues/82 RPC 层支持从 IO 线程派发 message list：https://github.com/alipay/sofa-bolt/pull/84  Version 1.6.0 整体目标  统一生命周期组件 抽象并沉淀网络组件的API 收敛配置入口\u0026amp;amp;增强配置的可扩展性  统一生命周期组件 在1.5.x的Bolt版本中，管理组件的生命周期相关的API命名并不统一，比如：\n ReconnectManager不需要启动或者初始化，关闭方法为stop DefaultConnectionMonitor初始化方法为start，关闭的方法为destroy RpcClient初始化方法为init，关闭的方法为shutdown RpcTaskScanner初始化的方法为start，关闭方法为shutdown  在1.6.0版本里，统一了所有组件的生命周期接口：\n 对于有生命周期的组件，即使用前需要进行初始化，使用完毕需要释放资源的，统一提供startup/shutdown接口  抽象并沉淀网络组件的API Bolt中remoting类是网络操作的主要入口，目前以抽象类的形式提供，后续希望对方法进行收敛，暴露对应的接口：\n 标准化，规范使用 沉淀接口，保持稳定 收敛入口，便于内部的代码迭代  在1.5.x的版本中，ReconnectManager类尽管提供了public的addCancelUrl方法，但是这个方法在Bolt项目中没有调用：\n IDE会给出警告 给用户造成困惑：这个方法可否删除？  在1.6.0版本中解决了以上的问题，抽象出一套稳定的API，便于用户使用、提升代码可读性，同时也为后续的迭代打下基础。\n收敛配置入口\u0026amp;amp;增强配置的可扩展性 1.5.x版本的Bolt配置入口有以下几个：\n ProtocolSwitch：协议配置（是否开启CRC校验），通过静态的方法创建配置对象 GlobalSwitch：实例级配置，每个AbstractConfigurableInstance拥有自己的GlobalSwitch配置，默认值取自SystemProperty，可以通过API调整配置 ConfigItem：Netty相关的配置项的枚举，不可以继承拓展（用户需要修改源码） ConfigManager：配置读取入口，通过静态方法读取SystemProperty的配置 Configs：配置项名称的定义和配置项的默认值  整体上看Bolt的配置项比较零散，且对用户来说难以拓展使用，有以接口暴露的配置项、有以静态方法暴露的配置项，配置项可以通过系统参数配置也可以通过API执行配置。\n且Bolt配置项存在相互影响的问题，比如一个产品同时使用了RPC和消息，而RPC和消息底层都依赖于Bolt，那么基于SystemProperty的配置将无法做到RPC和消息的配置隔离。\n在1.6.0版本中对配置模块进行了调整，在兼容当前版本配置的情况下：\n 收敛配置入口，提供统一的配置的编程界面（以类似Netty的Option的方式进行配置） 支持配置隔离，不同的Bolt实例使用不同的配置项 提升配置的可扩展性  ","date":-62135596800,"description":"","dir":"projects/sofa-bolt/sofa-bolt-roadmap/","fuzzywordcount":1400,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3d4eac90b5c8e657d14eb885ab1f9a92","permalink":"/projects/sofa-bolt/sofa-bolt-roadmap/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-bolt/sofa-bolt-roadmap/","summary":"发展路线 Version 1.5.1 修复项目中代码风格的问题：https://github.com/alipay/sofa-bolt/issues/85 修复项目中已","tags":null,"title":"SOFABolt 发展路线","type":"projects","url":"/projects/sofa-bolt/sofa-bolt-roadmap/","wordcount":1356},{"author":null,"categories":null,"content":" 介绍 SOFABolt 是蚂蚁金融服务集团开发的一套基于 Netty 实现的网络通信框架。\n 为了让 Java 程序员能将更多的精力放在基于网络通信的业务逻辑实现上，而不是过多的纠结于网络底层 NIO 的实现以及处理难以调试的网络问题，Netty 应运而生。 为了让中间件开发者能将更多的精力放在产品功能特性实现上，而不是重复地一遍遍制造通信框架的轮子，SOFABolt 应运而生。  Bolt 名字取自迪士尼动画-闪电狗，是一个基于 Netty 最佳实践的轻量、易用、高性能、易扩展的通信框架。 这些年我们在微服务与消息中间件在网络通信上解决过很多问题，积累了很多经验，并持续的进行着优化和完善，我们希望能把总结出的解决方案沉淀到 SOFABolt 这个基础组件里，让更多的使用网络通信的场景能够统一受益。 目前该产品已经运用在了蚂蚁中间件的微服务 (SOFARPC)、消息中心、分布式事务、分布式开关、以及配置中心等众多产品上。\n多语言  node python cpp  ","date":-62135596800,"description":"","dir":"projects/sofa-bolt/overview/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5ee08df7c4bbd2c3be846e16f3bc81b1","permalink":"/projects/sofa-bolt/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-bolt/overview/","summary":"介绍 SOFABolt 是蚂蚁金融服务集团开发的一套基于 Netty 实现的网络通信框架。 为了让 Java 程序员能将更多的精力放在基于网络通信的业务逻辑实现上，而不是过多的纠结于","tags":null,"title":"SOFABolt 概述","type":"projects","url":"/projects/sofa-bolt/overview/","wordcount":369},{"author":null,"categories":null,"content":" 用户指南 maven coordinator \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;bolt\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   check release note for version\n 1. 基础功能 1.1 实现用户请求处理器 (UserProcessor) 我们提供了两种用户请求处理器，SyncUserProcessor 与 AsyncUserProcessor。 二者的区别在于，前者需要在当前处理线程以return返回值的形式返回处理结果；而后者，有一个 AsyncContext 存根，可以在当前线程，也可以在异步线程，调用 sendResponse 方法返回处理结果。示例可参考如下两个类：\n 同步请求处理器 异步请求处理器  1.2 实现连接事件处理器 (ConnectionEventProcessor) 我们提供了两种事件监听，建连事件（ConnectionEventType.CONNECT）与断连事件（ConnectionEventType.CLOSE），用户可以创建自己的事件处理器，并注册到客户端或者服务端。客户端与服务端，都可以监听到各自的建连与断连事件。\n 处理连接建立事件 处理连接断开事件  1.3 客户端与服务端初始化 (RpcClient，RpcServer) 我们提供了一个 RpcClient 与 RpcServer，经过简单的必要功能初始化，或者功能开关，即可使用。一个最简单的例子如下：\n 客户端初始化示例 服务端初始化示例  1.4 基础通信模型 我们提供了四种通信模型：\n1.Oneway 调用\n当前线程发起调用后，不关心调用结果，不做超时控制，只要请求已经发出，就完成本次调用。注意 Oneway 调用不保证成功，而且发起方无法知道调用结果。因此通常用于可以重试，或者定时通知类的场景，调用过程是有可能因为网络问题，机器故障等原因，导致请求失败。业务场景需要能接受这样的异常场景，才可以使用。请参考示例。\n2. Sync 同步调用\n当前线程发起调用后，需要在指定的超时时间内，等到响应结果，才能完成本次调用。如果超时时间内没有得到结果，那么会抛出超时异常。这种调用模式最常用。注意要根据对端的处理能力，合理设置超时时间。请参考示例。\n3. Future调用\n当前线程发起调用，得到一个 RpcResponseFuture 对象，当前线程可以继续执行下一次调用。可以在任意时刻，使用 RpcResponseFuture 对象的 get() 方法来获取结果，如果响应已经回来，此时就马上得到结果；如果响应没有回来，则会阻塞住当前线程，直到响应回来，或者超时时间到。请参考示例。\n4. Callback异步调用\n当前线程发起调用，则本次调用马上结束，可以马上执行下一次调用。发起调用时需要注册一个回调，该回调需要分配一个异步线程池。待响应回来后，会在回调的异步线程池，来执行回调逻辑。请参考示例。\n1.5 日志打印 SOFABolt 只依赖 SLF4J 作为日志门面。同时提供了 log4j、log4j2、logback 三种日志模板，使用者只需要在运行时依赖某一种日志实现，我们依赖的 sofa-common-tools 组件，会在运行时动态感知是哪一种日志实现，同时加载正确的日志模板，进行打印。日志会打印在 ~/logs/bolt/ 目录下面，包括如下几种日志：\n common-default.log：默认日志，打印一些客户端、服务器启动、关闭等通信过程的普通日志 common-error.log：异常日志，框架运行过程中出现的异常 connection-event.log：连接事件日志 remoting-rpc.log：RPC 协议相关的日志  关于日志依赖，可以参考日志实现依赖参考\n2. 进阶功能 2.1 请求上下文 在调用过程中，我们还提供了带 InvokeContext 的接口，并一路传递下去，可以在自定义序列化器，用户请求处理器中获得。我们分为两种场景来使用请求上下文：\n 客户端：用户可以设置一些针对本次请求生效的参数，比如序列化类型，是否开启crc等机制。同时可以从上下文中获取建连耗时，连接信息等。 服务端：用户可以从用户请求处理器中获得请求到达后的排队耗时，连接信息等 注意：客户端与服务端的上线文是独立的，即客户端设置的上下文只在客户端可见，对服务端不可见；反之同理。 使用示例  2.2 双工通信 除了服务端可以注册用户请求处理器，我们的客户端也可以注册用户请求处理器。此时，服务端就可以发起对客户端的调用，也可以使用 1.4 提到了任何一种通信模型。\n 示例1：使用 Connection 对象的双工通信，注意使用 Connection 对象的双工通信，服务端需要通过事件监听处理器或者用户请求处理器，自己保存好 Connection 对象。 示例2：使用 Address 的双工通信，注意使用 Address 方式的双工通信，需要在初始化 RpcServer 时，打开 manageConnection 开关，表示服务端会根据客户端发起的建连，维护一份地址与连接的映射关系。默认不需要双工通信的时候，这个功能是关闭的。  2.3 建立多连接与连接预热 通常来说，点对点的直连通信，客户端和服务端，一个 IP 一个连接对象就够用了。不管是吞吐能力还是并发度，都能满足一般业务的通信需求。而有一些场景，比如不是点对点直连通信，而是经过了 LVS VIP，或者 F5 设备的连接，此时，为了负载均衡和容错，会针对一个 URL 地址建立多个连接。我们提供如下方式来建立多连接，即发起调用时传入的 URL 增加如下参数 127.0.0.1:12200?_CONNECTIONNUM=30\u0026amp;amp;_CONNECTIONWARMUP=true，表示针对这个 IP 地址，需要建立30个连接，同时需要预热连接。其中预热与不预热的区别是：\n 预热：即第一次调用（比如 Sync 同步调用），就建立30个连接 不预热：每一次调用，创建一个连接，直到创建满30个连接 使用示例  2.4 自动断连与重连 通常 RPC 调用过程，是不需要断链与重连的。因为每次 RPC 调用过程，都会校验是否有可用连接，如果没有则新建一个。但有一些场景，是需要断链和保持长连接的：\n 自动断连：比如通过 LVS VIP 或者 F5 建立多个连接的场景，因为网络设备的负载均衡机制，有可能某一些连接固定映射到了某几台后端的 RS 上面，此时需要自动断连，然后重连，靠建连过程的随机性来实现最终负载均衡。注意，开启了自动断连的场景，通常需要配合重连使用。 重连：比如客户端发起建连后，由服务端来通过双工通信，发起请求到客户端。此时如果没有重连机制，则无法实现。 使用示例，注意考虑一个进程可能会有多个 SOFABolt 的通信实例，我们提供了全局开关以及用户开关两种开关方式： …","date":-62135596800,"description":"","dir":"projects/sofa-bolt/sofa-bolt-handbook/","fuzzywordcount":3600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2a0a2e3c7749dbcdceea064f6f850e33","permalink":"/projects/sofa-bolt/sofa-bolt-handbook/","publishdate":"0001-01-01T00:00:00Z","readingtime":8,"relpermalink":"/projects/sofa-bolt/sofa-bolt-handbook/","summary":"用户指南 maven coordinator \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bolt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; check release note for version 1. 基础功能 1.1 实现用户请求处理器 (UserProcessor) 我们提供了两种用户请求处理器，SyncUserProcessor 与 Async","tags":null,"title":"SOFABolt 用户手册","type":"projects","url":"/projects/sofa-bolt/sofa-bolt-handbook/","wordcount":3516},{"author":null,"categories":null,"content":" 相关链接  ISSUES 用户手册 中文介绍文章: 蚂蚁通信框架实践  ","date":-62135596800,"description":"","dir":"projects/sofa-bolt/related-links/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6844d2a639b69fa3128132b8631f33e3","permalink":"/projects/sofa-bolt/related-links/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-bolt/related-links/","summary":"相关链接 ISSUES 用户手册 中文介绍文章: 蚂蚁通信框架实践","tags":null,"title":"SOFABolt 相关链接","type":"projects","url":"/projects/sofa-bolt/related-links/","wordcount":24},{"author":null,"categories":null,"content":" SOFABoot 2.3.x/2.4.x 升级到 2.5.x SOFABoot 2.3.x/2.4.x 基于 Spring Boot 1.4.2.RELEASE 版本开发，SOFABoot 2.5.x 则是基于 Spring Boot 1.5.x 版本开发。 从 SOFABoot 2.3.x/2.4.x 升级到 SOFABoot 2.5.x 需要重点考虑 Spring Boot 1.5.x 相较 Spring Boot 1.4.x 的升级注意点。\n重命名的 spring boot starters  spring-boot-starter-ws \u0026amp;ndash;\u0026amp;gt; spring-boot-starter-web-services spring-boot-starter-redis \u0026amp;ndash;\u0026amp;gt; spring-boot-starter-data-redis  endpoint 安全性控制 Spring Boot 1.5.x 对所有 Sensitive Endpoint 默认进行了安全管控，即之前在 1.4.x 默认能访问的诸如 /beans, /dump 等 endpoints 在 1.5.x 版本均不能访问。如果需要访问，需要配置： \u0026amp;gt; management.security.enabled=false\n默认情况下，在 1.5.x 只有 /health, /info, /docs 能够访问。详细请参考官方描述： + endpoints + Accessing sensitive endpoints\nApplicationEvent 变更 Spring Boot 1.5.x 将 1.4.x 中的 ApplicationStartedEvent 重命名为 ApplicationStartingEvent，在 1.5.x 仍然保持向前兼容。需要格外注意的是，在 2.x 版本中，ApplicationStartedEvent 事件意义完全不一样。\n强烈建议升级到 SOFABoot 2.5.x 的用户，将应用中使用的 ApplicationStartedEvent 变更为 ApplicationStartingEvent；避免今后升级至 SOFABoot 3.0.x 出现兼容性问题\nProperty 重命名  server.max-http-post-size \u0026amp;ndash;\u0026amp;gt; server.tomcat.max-http-post-size spring.data.neo4j.session.scope 被移除  具体参考 Spring Boot 1.5.x 配置的 changelog\n总结 以上总结了从 SOFABoot 2.3.x/2.4.x 升级到 SOFABoot 2.5.x 的几个主要注意点，详细可以参考 Spring Boot 1.5.x 的发布报告\n","date":-62135596800,"description":"","dir":"projects/moss/upgrade_2_5_x/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d2c94f52f254b450d19ec3c37c6b84eb","permalink":"/projects/moss/upgrade_2_5_x/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/moss/upgrade_2_5_x/","summary":"SOFABoot 2.3.x/2.4.x 升级到 2.5.x SOFABoot 2.3.x/2.4.x 基于 Spring Boot 1.4.2.RELEASE 版本开发，SOFABoot 2.5.x 则是基于 Spring Boot 1.5.x 版本开发。 从 SOFABoot 2.3.x/2.4.x 升级到 SOFABoot 2.5.x 需要重点考虑 Spring Boot 1.5.x 相较 Spring Boot 1.4.x 的升级注意点。 重命","tags":null,"title":"SOFABoot 2.5.x 升级注意事项","type":"projects","url":"/projects/moss/upgrade_2_5_x/","wordcount":404},{"author":null,"categories":null,"content":" SOFABoot 2.3.x/2.4.x 升级到 2.5.x SOFABoot 2.3.x/2.4.x 基于 Spring Boot 1.4.2.RELEASE 版本开发，SOFABoot 2.5.x 则是基于 Spring Boot 1.5.x 版本开发。 从 SOFABoot 2.3.x/2.4.x 升级到 SOFABoot 2.5.x 需要重点考虑 Spring Boot 1.5.x 相较 Spring Boot 1.4.x 的升级注意点。\n重命名的 spring boot starters  spring-boot-starter-ws \u0026amp;ndash;\u0026amp;gt; spring-boot-starter-web-services spring-boot-starter-redis \u0026amp;ndash;\u0026amp;gt; spring-boot-starter-data-redis  endpoint 安全性控制 Spring Boot 1.5.x 对所有 Sensitive Endpoint 默认进行了安全管控，即之前在 1.4.x 默认能访问的诸如 /beans, /dump 等 endpoints 在 1.5.x 版本均不能访问。如果需要访问，需要配置： \u0026amp;gt; management.security.enabled=false\n默认情况下，在 1.5.x 只有 /health, /info, /docs 能够访问。详细请参考官方描述： + endpoints + Accessing sensitive endpoints\nApplicationEvent 变更 Spring Boot 1.5.x 将 1.4.x 中的 ApplicationStartedEvent 重命名为 ApplicationStartingEvent，在 1.5.x 仍然保持向前兼容。需要格外注意的是，在 2.x 版本中，ApplicationStartedEvent 事件意义完全不一样。\n强烈建议升级到 SOFABoot 2.5.x 的用户，将应用中使用的 ApplicationStartedEvent 变更为 ApplicationStartingEvent；避免今后升级至 SOFABoot 3.0.x 出现兼容性问题\nProperty 重命名  server.max-http-post-size \u0026amp;ndash;\u0026amp;gt; server.tomcat.max-http-post-size spring.data.neo4j.session.scope 被移除  具体参考 Spring Boot 1.5.x 配置的 changelog\n总结 以上总结了从 SOFABoot 2.3.x/2.4.x 升级到 SOFABoot 2.5.x 的几个主要注意点，详细可以参考 Spring Boot 1.5.x 的发布报告\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/upgrade_2_5_x/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4b7dd4287b00106684831d2a8524a6f7","permalink":"/projects/sofa-boot/upgrade_2_5_x/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-boot/upgrade_2_5_x/","summary":"SOFABoot 2.3.x/2.4.x 升级到 2.5.x SOFABoot 2.3.x/2.4.x 基于 Spring Boot 1.4.2.RELEASE 版本开发，SOFABoot 2.5.x 则是基于 Spring Boot 1.5.x 版本开发。 从 SOFABoot 2.3.x/2.4.x 升级到 SOFABoot 2.5.x 需要重点考虑 Spring Boot 1.5.x 相较 Spring Boot 1.4.x 的升级注意点。 重命","tags":null,"title":"SOFABoot 2.5.x 升级注意事项","type":"projects","url":"/projects/sofa-boot/upgrade_2_5_x/","wordcount":404},{"author":null,"categories":null,"content":" 前言 SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等能力。在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFA 中间件的能力。\n自今年 4 月份 SOFABoot 开源至今，我们收到了非常多来自社区同学的反馈，也非常高兴的看到很多社区同学积极的参与到 SOFAStack 开源共建，这极大了鼓舞了我们建设 SOFAStack 开源社区的决心，力图把 SOFAStack 社区和生态建设更加繁荣。在此，我们宣布推出 SOFABoot 3.0 版本，SOFABoot 3.0 是基于 Spring Boot 2.0 版本开发。在 SOFABoot 3.0 中，可以将 SOFABoot 扩展能力和 Spring Boot 2.x 官方组件无缝集成。此外，我们在 SOFABoot 3.0 中兼容了 Spring Cloud 组件集成，可以很方便地在 SOFABoot 框架中集成 Spring Cloud 组件，如 Zuul, Config 等。\n以下，本文将详细介绍 SOFABoot 3.0 相较 SOFABoot 2.x 的变更。\nSpring Boot 升级 2.x SOFABoot 3.0 版本升级 Spring Boot 版本至 2.0。鉴于Spring Boot 社区最近刚公告 1.x 版本将维护至明年 8 月份为止，未来，我们也将主力维护 SOFABoot 3.x 版本，近期也将发布 SOFABoot 3.1 升级 Spring Boot 版本至 2.1。\nSpring Cloud 兼容 在 SOFABoot 2.x 中，存在部分组件和 SOFABoot 兼容性问题。在 SOFABoot 3.x 中，对 Spring Cloud 各组件进行了比较完备的兼容性测试和问题修复，保证了 SOFABoot 3.x 与 Spring Cloud 良好的兼容性。\nWebFlux 框架兼容 Spring Boot 2.x 引入了 WebFlux 框架，SOFABoot 3.x 主要在两个方面兼容了 WebFlux 框架； + 健康检查兼容了 ReactiveHealthIndicator 扩展接口，业务对这个接口的扩展实现将会纳入到 Readiness Check； + 兼容对 WebFlux 网络请求进行埋点，埋点日志格式和文件保持对普通 MVC 请求兼容，详细参考MVC 埋点请求\nJDK 版本支持 SOFABoot 3.x 最低要求运行在 JDK 8 及其以上版本，不支持 JDK 6，7。\n健康检查 SOFABoot 为 Spring Boot 的健康检查能力增加了 Readiness Check 能力，以确保应用在正常对外服务前，所有组件及业务本身处于健康状态。相较于与 SOFABoot 2.x, SOFABoot 3.0 在健康检查做了很大的重构，主要是剥离了部分蚂蚁金服内部兼容逻辑，采用更加友好的编码方案；其次，SOFABoot 3.0 健康检查提供了多种不同场景下的健康检查扩展形式，支持 Spring Boot 2.x 引入的 ReactiveHealthIndicator 扩展接口，丰富了健康检查扩展特性。\n调整 Readiness Check Endpoint 路径 在 SOFABoot 2.x 中，查看健康检查结果的 Endpoint 为 /health/readiness，而在 SOFABoot 3.0 中，变更为 /actuator/readiness。\n扩展接口变更 在 SOFABoot 3.x 中，提供四种方式扩展健康检查，分别是 + HealthChecker + HealthIndicator(Spring Boot 原生) + ReactiveHealthIndicator(Spring Boot 原生) + ReadinessCheckCallback\n这四个接口的扩展实现执行顺序是 HealthChecker \u0026amp;gt; HealthIndicator, ReactiveHealthIndicator \u0026amp;gt; ReadinessCheckCallback，相同接口的扩展实现执行顺序则遵循 Spring Boot 标准的方案。即扩展类可以额外实现两个标准的 Order 接口：\n org.springframework.core.Ordered org.springframework.core.PriorityOrdered  或者使用注解\n org.springframework.core.annotation.Order  这些接口的扩展实现处理结果将会在健康检查结果查中展现。\n删除 SofaBootBeforeHealthCheckEvent 事件 在 SOFABoot 2.x 中，我们没有提供支持对健康检查扩展实现进行排序，导致用户无法预期自身扩展执行时机。如上述，SOFABoot 3.x 支持各组件扩展实现的排序，因此该事件可以统一使用 HealthChecker 接口和高优先级顺序实现替代。其次，在 SOFABoot 2.x 中，SofaBootBeforeHealthCheckEvent 事件的处理逻辑结果并不会反应在健康检查结果中，使用 HealthChecker 替代之后，这部分逻辑处理自然变成健康检查的一部分，可供查看。\n删除 DefaultHealthChecker 接口 使用 JDK8 默认方法特性，删除 DefaultHealthChecker 接口，用户可以直接使用 HealthChecker 接口替代 DefaultHealthChecker.\n删除 SofaBootMiddlewareAfterReadinessCheckCallback 和 SofaBootAfterReadinessCheckCallback 接口 在 SOFABoot 2.x 中，这两个接口是两种场景下的健康检查回调；推荐 SOFABoot 官方 Starter 使用 SofaBootMiddlewareAfterReadinessCheckCallback，而业务应用推荐使用SofaBootAfterReadinessCheckCallback，框架将优先执行 SofaBootMiddlewareAfterReadinessCheckCallback 的扩展实现，然后执行 SofaBootAfterReadinessCheckCallback 的扩展实现。这样的设计有两个缺陷： + 两个接口本质没有区别，但是隐藏了先后顺序逻辑，给用户引入了额外的学习成本； + 只考虑了 SofaBootMiddlewareAfterReadinessCheckCallback 和 SofaBootAfterReadinessCheckCallback 两个接口的顺序，但无法保证相同接口实现的执行顺序。\nSOFABoot 3.x …","date":-62135596800,"description":"","dir":"projects/moss/upgrade_3_x/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"80398045c5e68a97cd4c19ab9b718512","permalink":"/projects/moss/upgrade_3_x/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/moss/upgrade_3_x/","summary":"前言 SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等能力。在增强了 Spring Boot 的同时，SOFA","tags":null,"title":"SOFABoot 3.0 升级注意事项","type":"projects","url":"/projects/moss/upgrade_3_x/","wordcount":1687},{"author":null,"categories":null,"content":" 前言 SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等能力。在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFA 中间件的能力。\n自今年 4 月份 SOFABoot 开源至今，我们收到了非常多来自社区同学的反馈，也非常高兴的看到很多社区同学积极的参与到 SOFAStack 开源共建，这极大了鼓舞了我们建设 SOFAStack 开源社区的决心，力图把 SOFAStack 社区和生态建设更加繁荣。在此，我们宣布推出 SOFABoot 3.0 版本，SOFABoot 3.0 是基于 Spring Boot 2.0 版本开发。在 SOFABoot 3.0 中，可以将 SOFABoot 扩展能力和 Spring Boot 2.x 官方组件无缝集成。此外，我们在 SOFABoot 3.0 中兼容了 Spring Cloud 组件集成，可以很方便地在 SOFABoot 框架中集成 Spring Cloud 组件，如 Zuul, Config 等。\n以下，本文将详细介绍 SOFABoot 3.0 相较 SOFABoot 2.x 的变更。\nSpring Boot 升级 2.x SOFABoot 3.0 版本升级 Spring Boot 版本至 2.0。鉴于Spring Boot 社区最近刚公告 1.x 版本将维护至明年 8 月份为止，未来，我们也将主力维护 SOFABoot 3.x 版本，近期也将发布 SOFABoot 3.1 升级 Spring Boot 版本至 2.1。\nSpring Cloud 兼容 在 SOFABoot 2.x 中，存在部分组件和 SOFABoot 兼容性问题。在 SOFABoot 3.x 中，对 Spring Cloud 各组件进行了比较完备的兼容性测试和问题修复，保证了 SOFABoot 3.x 与 Spring Cloud 良好的兼容性。\nWebFlux 框架兼容 Spring Boot 2.x 引入了 WebFlux 框架，SOFABoot 3.x 主要在两个方面兼容了 WebFlux 框架； + 健康检查兼容了 ReactiveHealthIndicator 扩展接口，业务对这个接口的扩展实现将会纳入到 Readiness Check； + 兼容对 WebFlux 网络请求进行埋点，埋点日志格式和文件保持对普通 MVC 请求兼容，详细参考MVC 埋点请求\nJDK 版本支持 SOFABoot 3.x 最低要求运行在 JDK 8 及其以上版本，不支持 JDK 6，7。\n健康检查 SOFABoot 为 Spring Boot 的健康检查能力增加了 Readiness Check 能力，以确保应用在正常对外服务前，所有组件及业务本身处于健康状态。相较于与 SOFABoot 2.x, SOFABoot 3.0 在健康检查做了很大的重构，主要是剥离了部分蚂蚁金服内部兼容逻辑，采用更加友好的编码方案；其次，SOFABoot 3.0 健康检查提供了多种不同场景下的健康检查扩展形式，支持 Spring Boot 2.x 引入的 ReactiveHealthIndicator 扩展接口，丰富了健康检查扩展特性。\n调整 Readiness Check Endpoint 路径 在 SOFABoot 2.x 中，查看健康检查结果的 Endpoint 为 /health/readiness，而在 SOFABoot 3.0 中，变更为 /actuator/readiness。\n扩展接口变更 在 SOFABoot 3.x 中，提供四种方式扩展健康检查，分别是 + HealthChecker + HealthIndicator(Spring Boot 原生) + ReactiveHealthIndicator(Spring Boot 原生) + ReadinessCheckCallback\n这四个接口的扩展实现执行顺序是 HealthChecker \u0026amp;gt; HealthIndicator, ReactiveHealthIndicator \u0026amp;gt; ReadinessCheckCallback，相同接口的扩展实现执行顺序则遵循 Spring Boot 标准的方案。即扩展类可以额外实现两个标准的 Order 接口：\n org.springframework.core.Ordered org.springframework.core.PriorityOrdered  或者使用注解\n org.springframework.core.annotation.Order  这些接口的扩展实现处理结果将会在健康检查结果查中展现。\n删除 SofaBootBeforeHealthCheckEvent 事件 在 SOFABoot 2.x 中，我们没有提供支持对健康检查扩展实现进行排序，导致用户无法预期自身扩展执行时机。如上述，SOFABoot 3.x 支持各组件扩展实现的排序，因此该事件可以统一使用 HealthChecker 接口和高优先级顺序实现替代。其次，在 SOFABoot 2.x 中，SofaBootBeforeHealthCheckEvent 事件的处理逻辑结果并不会反应在健康检查结果中，使用 HealthChecker 替代之后，这部分逻辑处理自然变成健康检查的一部分，可供查看。\n删除 DefaultHealthChecker 接口 使用 JDK8 默认方法特性，删除 DefaultHealthChecker 接口，用户可以直接使用 HealthChecker 接口替代 DefaultHealthChecker.\n删除 SofaBootMiddlewareAfterReadinessCheckCallback 和 SofaBootAfterReadinessCheckCallback 接口 在 SOFABoot 2.x 中，这两个接口是两种场景下的健康检查回调；推荐 SOFABoot 官方 Starter 使用 SofaBootMiddlewareAfterReadinessCheckCallback，而业务应用推荐使用SofaBootAfterReadinessCheckCallback，框架将优先执行 SofaBootMiddlewareAfterReadinessCheckCallback 的扩展实现，然后执行 SofaBootAfterReadinessCheckCallback 的扩展实现。这样的设计有两个缺陷： + 两个接口本质没有区别，但是隐藏了先后顺序逻辑，给用户引入了额外的学习成本； + 只考虑了 SofaBootMiddlewareAfterReadinessCheckCallback 和 SofaBootAfterReadinessCheckCallback 两个接口的顺序，但无法保证相同接口实现的执行顺序。\nSOFABoot 3.x …","date":-62135596800,"description":"","dir":"projects/sofa-boot/upgrade_3_x/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"91ba09adf6bc42aaf70645b9a19b409b","permalink":"/projects/sofa-boot/upgrade_3_x/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/sofa-boot/upgrade_3_x/","summary":"前言 SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等能力。在增强了 Spring Boot 的同时，SOFA","tags":null,"title":"SOFABoot 3.0 升级注意事项","type":"projects","url":"/projects/sofa-boot/upgrade_3_x/","wordcount":1687},{"author":null,"categories":null,"content":" Spring 框架从 3.1.X 版本开始提供了 profile 功能: Bean Definition Profiles，SOFABoot 支持模块级 profile 能力，即在各个模块启动的时候决定模块是否能够启动。\n使用 Module-Profile 激活 module 使用 SOFABoot 的 profile 功能，需要在 application.properties 文件增加 com.alipay.sofa.boot.active-profiles 字段，该字段的值为逗号分隔的字符串，表示允许激活的 profile 列表，指定该字段后，SOFABoot 会为每个可以激活的模块指定此字段表示的 profile 列表。\nSOFABoot 模块的 sofa-module.properties 文件支持 Module-Profile 字段，该字段的值为逗号分隔的字符串，表示当前模块允许在哪些 profile 激活。Module-Profile 支持取反操作， !dev 表示 com.alipay.sofa.boot.active-profiles 不包含 dev 时被激活。\n当应用未指定 com.alipay.sofa.boot.active-profiles 参数时，表示应用所有模块均可启动。SOFABoot 模块未指定 Module-Profile 时，表示当前 SOFABoot 模块可以在任何 profile 启动。\n使用例子 激活 dev SOFABoot 模块 application.properties 中增加配置如下：\ncom.alipay.sofa.boot.active-profiles=dev  该配置表示激活 profile 为 dev 的模块。\n在每个需要限定为 dev profile 被激活模块的 sofa-module.properties 文件中增加如下配置：\nModule-Profile=dev  配置多个激活 profile application.properties 中增加配置如下：\ncom.alipay.sofa.boot.active-profiles=dev,test  该配置表示激活 profile 为 dev 或者 test 的模块。\n在 SOFABoot 模块的 sofa-module.properties 文件中增加如下配置：\nModule-Profile=test,product  该配置表示当 com.alipay.sofa.boot.active-profiles 包含 test 或者 product 时激活模块，由于当前指定的 com.alipay.sofa.boot.active-profiles 为 dev,test ，此模块将被激活。\nModule-Profile 取反 application.properties 中增加配置如下：\ncom.alipay.sofa.boot.active-profiles=dev  该配置表示激活 profile 为 dev 的模块。\n在 SOFABoot 模块的 sofa-module.properties 文件中增加如下配置：\nModule-Profile=!product  该配置表示当 com.alipay.sofa.boot.active-profiles 不包含 product 时激活模块，由于当前指定的 com.alipay.sofa.boot.active-profiles 为 dev ，此模块将被激活。\n设置激活模块 Spring 上下文的 spring.profiles.active 属性 application.properties 中增加配置如下：\ncom.alipay.sofa.boot.active-profiles=dev,test  该配置表示激活 profile 为 dev 或者 test 的模块，当一个模块满足上面的激活条件时，这个模块就会被启动，同时 Spring 上下文的环境信息 spring.profiles.active 也被设置为了 dev,test ，这样如下的配置 beanId 为 devBeanId 和 testBeanId 的bean都会被激活。\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;beans xmlns=\u0026amp;quot;http://www.springframework.org/schema/beans\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xmlns:jdbc=\u0026amp;quot;http://www.springframework.org/schema/jdbc\u0026amp;quot; xmlns:jee=\u0026amp;quot;http://www.springframework.org/schema/jee\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026amp;quot; default-autowire=\u0026amp;quot;byName\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;beans profile=\u0026amp;quot;dev\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;devBeanId\u0026amp;quot; class=\u0026amp;quot;com.alipay.cloudenginetest.sofaprofilesenv.DemoBean\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;name\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;value\u0026amp;gt;demoBeanDev\u0026amp;lt;/value\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/beans\u0026amp;gt; \u0026amp;lt;beans profile=\u0026amp;quot;test\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;testBeanId\u0026amp;quot; class=\u0026amp;quot;com.alipay.cloudenginetest.sofaprofilesenv.DemoBean\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;name\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;value\u0026amp;gt;demoBeanTest\u0026amp;lt;/value\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/beans\u0026amp;gt; \u0026amp;lt;/beans\u0026amp;gt;  ","date":-62135596800,"description":"","dir":"projects/moss/sofaboot-profile/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b6908ebf3d0801d8feff69e7d413854e","permalink":"/projects/moss/sofaboot-profile/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/sofaboot-profile/","summary":"Spring 框架从 3.1.X 版本开始提供了 profile 功能: Bean Definition Profiles，SOFABoot 支持模块级 profile 能力，即在各个模块启动的时候决定模块是否能够启动。 使用 Module-Profile 激","tags":null,"title":"SOFABoot Profile","type":"projects","url":"/projects/moss/sofaboot-profile/","wordcount":666},{"author":null,"categories":null,"content":" Spring 框架从 3.1.X 版本开始提供了 profile 功能: Bean Definition Profiles，SOFABoot 支持模块级 profile 能力，即在各个模块启动的时候决定模块是否能够启动。\n使用 Module-Profile 激活 module 使用 SOFABoot 的 profile 功能，需要在 application.properties 文件增加 com.alipay.sofa.boot.active-profiles 字段，该字段的值为逗号分隔的字符串，表示允许激活的 profile 列表，指定该字段后，SOFABoot 会为每个可以激活的模块指定此字段表示的 profile 列表。\nSOFABoot 模块的 sofa-module.properties 文件支持 Module-Profile 字段，该字段的值为逗号分隔的字符串，表示当前模块允许在哪些 profile 激活。Module-Profile 支持取反操作， !dev 表示 com.alipay.sofa.boot.active-profiles 不包含 dev 时被激活。\n当应用未指定 com.alipay.sofa.boot.active-profiles 参数时，表示应用所有模块均可启动。SOFABoot 模块未指定 Module-Profile 时，表示当前 SOFABoot 模块可以在任何 profile 启动。\n使用例子 激活 dev SOFABoot 模块 application.properties 中增加配置如下：\ncom.alipay.sofa.boot.active-profiles=dev  该配置表示激活 profile 为 dev 的模块。\n在每个需要限定为 dev profile 被激活模块的 sofa-module.properties 文件中增加如下配置：\nModule-Profile=dev  配置多个激活 profile application.properties 中增加配置如下：\ncom.alipay.sofa.boot.active-profiles=dev,test  该配置表示激活 profile 为 dev 或者 test 的模块。\n在 SOFABoot 模块的 sofa-module.properties 文件中增加如下配置：\nModule-Profile=test,product  该配置表示当 com.alipay.sofa.boot.active-profiles 包含 test 或者 product 时激活模块，由于当前指定的 com.alipay.sofa.boot.active-profiles 为 dev,test ，此模块将被激活。\nModule-Profile 取反 application.properties 中增加配置如下：\ncom.alipay.sofa.boot.active-profiles=dev  该配置表示激活 profile 为 dev 的模块。\n在 SOFABoot 模块的 sofa-module.properties 文件中增加如下配置：\nModule-Profile=!product  该配置表示当 com.alipay.sofa.boot.active-profiles 不包含 product 时激活模块，由于当前指定的 com.alipay.sofa.boot.active-profiles 为 dev ，此模块将被激活。\n设置激活模块 Spring 上下文的 spring.profiles.active 属性 application.properties 中增加配置如下：\ncom.alipay.sofa.boot.active-profiles=dev,test  该配置表示激活 profile 为 dev 或者 test 的模块，当一个模块满足上面的激活条件时，这个模块就会被启动，同时 Spring 上下文的环境信息 spring.profiles.active 也被设置为了 dev,test ，这样如下的配置 beanId 为 devBeanId 和 testBeanId 的bean都会被激活。\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;beans xmlns=\u0026amp;quot;http://www.springframework.org/schema/beans\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xmlns:jdbc=\u0026amp;quot;http://www.springframework.org/schema/jdbc\u0026amp;quot; xmlns:jee=\u0026amp;quot;http://www.springframework.org/schema/jee\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026amp;quot; default-autowire=\u0026amp;quot;byName\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;beans profile=\u0026amp;quot;dev\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;devBeanId\u0026amp;quot; class=\u0026amp;quot;com.alipay.cloudenginetest.sofaprofilesenv.DemoBean\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;name\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;value\u0026amp;gt;demoBeanDev\u0026amp;lt;/value\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/beans\u0026amp;gt; \u0026amp;lt;beans profile=\u0026amp;quot;test\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;testBeanId\u0026amp;quot; class=\u0026amp;quot;com.alipay.cloudenginetest.sofaprofilesenv.DemoBean\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;name\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;value\u0026amp;gt;demoBeanTest\u0026amp;lt;/value\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/beans\u0026amp;gt; \u0026amp;lt;/beans\u0026amp;gt;  ","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofaboot-profile/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b29d568fa057cad0b440790d5cc65d07","permalink":"/projects/sofa-boot/sofaboot-profile/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/sofaboot-profile/","summary":"Spring 框架从 3.1.X 版本开始提供了 profile 功能: Bean Definition Profiles，SOFABoot 支持模块级 profile 能力，即在各个模块启动的时候决定模块是否能够启动。 使用 Module-Profile 激","tags":null,"title":"SOFABoot Profile","type":"projects","url":"/projects/sofa-boot/sofaboot-profile/","wordcount":666},{"author":null,"categories":null,"content":" SOFABoot 提供了类隔离框架 SOFAArk, 弥补了 Spring Boot 在类隔离能力上的缺失，用以解决在实际开发中常见的类冲突、包冲突问题，详细请参考 SOFAArk。\n在 SOFABoot 工程中使用类隔离能力，只需两步操作；配置 sofa-ark-maven-plugin 打包插件以及引入 sofa-ark-springboot-starter 类隔离框架依赖；\n配置 Maven 打包插件 官方提供了 Maven 插件 - sofa-ark-maven-plugin ，只需要简单的配置项，即可将 SpringBoot 工程打包成标准格式规范的可执行 Ark 包，插件坐标为：\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;  配置模板如下：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;!--goal executed to generate executable-ark-jar --\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--specify destination where executable-ark-jar will be saved, default saved to ${project.build.directory}--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;./target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!--default none--\u0026amp;gt; \u0026amp;lt;arkClassifier\u0026amp;gt;executable-ark\u0026amp;lt;/arkClassifier\u0026amp;gt; \u0026amp;lt;!-- all class exported by ark plugin would be resolved by ark biz in default, if configure denyImportClasses, then it would prefer to load them by ark biz itself --\u0026amp;gt; \u0026amp;lt;denyImportClasses\u0026amp;gt; \u0026amp;lt;class\u0026amp;gt;com.alipay.sofa.SampleClass1\u0026amp;lt;/class\u0026amp;gt; \u0026amp;lt;class\u0026amp;gt;com.alipay.sofa.SampleClass2\u0026amp;lt;/class\u0026amp;gt; \u0026amp;lt;/denyImportClasses\u0026amp;gt; \u0026amp;lt;!-- Corresponding to denyImportClasses, denyImportPackages is package-level --\u0026amp;gt; \u0026amp;lt;denyImportPackages\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;org.springframework\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;/denyImportPackages\u0026amp;gt; \u0026amp;lt;!-- denyImportResources can prevent resource exported by ark plugin with accurate name to be resolved --\u0026amp;gt; \u0026amp;lt;denyImportResources\u0026amp;gt; \u0026amp;lt;resource\u0026amp;gt;META-INF/spring/test1.xml\u0026amp;lt;/resource\u0026amp;gt; \u0026amp;lt;resource\u0026amp;gt;META-INF/spring/test2.xml\u0026amp;lt;/resource\u0026amp;gt; \u0026amp;lt;/denyImportResources\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/execution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  插件配置项解释：\n outputDirectory: 执行 mvn package 命令后，指定打出来的 ark 包存放目录，默认存放至 ${project.build.directory} arkClassifier: 执行 mvn depleoy 命令后，指定发布到仓库的 ark 包的maven坐标的 classifer 值, 默认为空；我们推荐配置此配置项用于和普通的 Fat Jar 加以名字上区别； denyImportClasses: 默认情况下，应用会优先加载 ark plugin 导出的类，使用该配置项，可以禁止应用从 ark plugin 加载其导出类； denyImportPackages: 对应上述的 denyImportClasses, 提供包级别的禁止导入； denyImportResources: 默认情况下，应用会优先加载 ark plugin 导出的资源，使用该配置项，可以禁止应用从 ark plugin 加载其导出资源；  添加类隔离框架依赖 在实际开发中，为了在跑测试用例时使用 SOFABoot 类隔离能力，需要在 SOFABoot 工程中添加如下的依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-springboot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  根据 SpringBoot 依赖即服务的原则，添加该依赖之后，应用启动之前，会优先启动 SOFABoot 类隔离容器；\nSOFABoot 的类隔离框架会自动检测应用中是否有引入 Ark Plugin（即需要被隔离的jar包，详情请参考 SOFAArk）, 并隔离加载；例如为了避免 SOFABoot 官方提供的 SOFARPC 组件和应用产生依赖冲突，SOFABoot提供了 SOFARPC 组件对应的 ark plugin 版，用户如果需要隔离 SOFARPC，只需要添加如下组件：\n\u0026amp;lt;dependency\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/moss/classloader-isolation/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8aea4943485ea67a8fc2fb82b4230e06","permalink":"/projects/moss/classloader-isolation/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/moss/classloader-isolation/","summary":"SOFABoot 提供了类隔离框架 SOFAArk, 弥补了 Spring Boot 在类隔离能力上的缺失，用以解决在实际开发中常见的类冲突、包冲突问题，详细请参考 SOFAArk。 在 SOFABoot 工程中使用类","tags":null,"title":"SOFABoot 使用类隔离","type":"projects","url":"/projects/moss/classloader-isolation/","wordcount":1667},{"author":null,"categories":null,"content":" SOFABoot 提供了类隔离框架 SOFAArk, 弥补了 Spring Boot 在类隔离能力上的缺失，用以解决在实际开发中常见的类冲突、包冲突问题，详细请参考 SOFAArk。\n在 SOFABoot 工程中使用类隔离能力，只需两步操作；配置 sofa-ark-maven-plugin 打包插件以及引入 sofa-ark-springboot-starter 类隔离框架依赖；\n配置 Maven 打包插件 官方提供了 Maven 插件 - sofa-ark-maven-plugin ，只需要简单的配置项，即可将 SpringBoot 工程打包成标准格式规范的可执行 Ark 包，插件坐标为：\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;  配置模板如下：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;!--goal executed to generate executable-ark-jar --\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--specify destination where executable-ark-jar will be saved, default saved to ${project.build.directory}--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;./target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!--default none--\u0026amp;gt; \u0026amp;lt;arkClassifier\u0026amp;gt;executable-ark\u0026amp;lt;/arkClassifier\u0026amp;gt; \u0026amp;lt;!-- all class exported by ark plugin would be resolved by ark biz in default, if configure denyImportClasses, then it would prefer to load them by ark biz itself --\u0026amp;gt; \u0026amp;lt;denyImportClasses\u0026amp;gt; \u0026amp;lt;class\u0026amp;gt;com.alipay.sofa.SampleClass1\u0026amp;lt;/class\u0026amp;gt; \u0026amp;lt;class\u0026amp;gt;com.alipay.sofa.SampleClass2\u0026amp;lt;/class\u0026amp;gt; \u0026amp;lt;/denyImportClasses\u0026amp;gt; \u0026amp;lt;!-- Corresponding to denyImportClasses, denyImportPackages is package-level --\u0026amp;gt; \u0026amp;lt;denyImportPackages\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;org.springframework\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;/denyImportPackages\u0026amp;gt; \u0026amp;lt;!-- denyImportResources can prevent resource exported by ark plugin with accurate name to be resolved --\u0026amp;gt; \u0026amp;lt;denyImportResources\u0026amp;gt; \u0026amp;lt;resource\u0026amp;gt;META-INF/spring/test1.xml\u0026amp;lt;/resource\u0026amp;gt; \u0026amp;lt;resource\u0026amp;gt;META-INF/spring/test2.xml\u0026amp;lt;/resource\u0026amp;gt; \u0026amp;lt;/denyImportResources\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/execution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  插件配置项解释：\n outputDirectory: 执行 mvn package 命令后，指定打出来的 ark 包存放目录，默认存放至 ${project.build.directory} arkClassifier: 执行 mvn depleoy 命令后，指定发布到仓库的 ark 包的maven坐标的 classifer 值, 默认为空；我们推荐配置此配置项用于和普通的 Fat Jar 加以名字上区别； denyImportClasses: 默认情况下，应用会优先加载 ark plugin 导出的类，使用该配置项，可以禁止应用从 ark plugin 加载其导出类； denyImportPackages: 对应上述的 denyImportClasses, 提供包级别的禁止导入； denyImportResources: 默认情况下，应用会优先加载 ark plugin 导出的资源，使用该配置项，可以禁止应用从 ark plugin 加载其导出资源；  添加类隔离框架依赖 在实际开发中，为了在跑测试用例时使用 SOFABoot 类隔离能力，需要在 SOFABoot 工程中添加如下的依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-springboot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  根据 SpringBoot 依赖即服务的原则，添加该依赖之后，应用启动之前，会优先启动 SOFABoot 类隔离容器；\nSOFABoot 的类隔离框架会自动检测应用中是否有引入 Ark Plugin（即需要被隔离的jar包，详情请参考 SOFAArk）, 并隔离加载；例如为了避免 SOFABoot 官方提供的 SOFARPC 组件和应用产生依赖冲突，SOFABoot提供了 SOFARPC 组件对应的 ark plugin 版，用户如果需要隔离 SOFARPC，只需要添加如下组件：\n\u0026amp;lt;dependency\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/sofa-boot/classloader-isolation/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e007416ab008c1dd4b886433dbf8af01","permalink":"/projects/sofa-boot/classloader-isolation/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/sofa-boot/classloader-isolation/","summary":"SOFABoot 提供了类隔离框架 SOFAArk, 弥补了 Spring Boot 在类隔离能力上的缺失，用以解决在实际开发中常见的类冲突、包冲突问题，详细请参考 SOFAArk。 在 SOFABoot 工程中使用类","tags":null,"title":"SOFABoot 使用类隔离","type":"projects","url":"/projects/sofa-boot/classloader-isolation/","wordcount":1667},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"本指南将基于 SOFADashboard 的 ARK 管控能力来实现 SOFAArk 提供的合并部署和动态模块推送的功能。","dir":"guides/kc-sofastack-dynamic-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8bfd4a50e21ce9fc867b1cf18a8c9af3","permalink":"/guides/kc-sofastack-dynamic-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-sofastack-dynamic-demo/","summary":"","tags":null,"title":"SOFABoot 动态模块实践","type":"guides","url":"/guides/kc-sofastack-dynamic-demo/","wordcount":0},{"author":null,"categories":null,"content":" SOFABoot 支持模块化隔离，在实际的使用场景中，一个模块中的 bean 有时候需要开放一些入口，供另外一个模块扩展。SOFABoot 借鉴和使用了 Nuxeo Runtime 项目 以及 nuxeo 项目，并在上面扩展，与 Spring 融合，提供扩展点的能力。\n使用 在 SOFABoot 中使用扩展点能力，需要以下三个步骤：\n定义提供扩展能力的 bean 在使用 SOFABoot 扩展点能力时，首先需要定一个需要被扩展的 bean，先定一个接口：\npackage com.alipay.sofa.boot.test; public interface IExtension { String say(); }  定义这个接口的实现：\npackage com.alipay.sofa.boot.test.impl; public class ExtensionImpl implements IExtension { private String word; @Override public String say() { return word; } public void setWord(String word) { this.word = word; } public void registerExtension(Extension extension) throws Exception { Object[] contributions = extension.getContributions(); String extensionPoint = extension.getExtensionPoint(); if (contributions == null) { return; } for (Object contribution : contributions) { if (\u0026amp;quot;word\u0026amp;quot;.equals(extensionPoint)) { setWord(((ExtensionDescriptor) contribution).getValue()); } } } }  在这里可以看到有一个方法：registerExtension ，暂时可以先不用管这个方法，后续会介绍其具体的作用。\n在模块的 Spring 配置文件中，我们把这个 bean 给配置起来：\n\u0026amp;lt;bean id=\u0026amp;quot;extension\u0026amp;quot; class=\u0026amp;quot;com.alipay.sofa.boot.test.impl.ExtensionImpl\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;word\u0026amp;quot; value=\u0026amp;quot;Hello, world\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  定义扩展点 在上面的 bean 中有一个字段 word ，在实际中，我们希望这个字段能够被其他的模块自定义进行覆盖，这里我们将其以扩展点的形式暴露出来。\n首先需要一个类去描述这个扩展点：\n@XObject(\u0026amp;quot;word\u0026amp;quot;) public class ExtensionDescriptor { @XNode(\u0026amp;quot;value\u0026amp;quot;) private String value; public String getValue() { return value; } }  然后在 xml 中定义扩展点：\n\u0026amp;lt;sofa:extension-point name=\u0026amp;quot;word\u0026amp;quot; ref=\u0026amp;quot;extension\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:object class=\u0026amp;quot;com.alipay.sofa.boot.test.extension.ExtensionDescriptor\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/sofa:extension-point\u0026amp;gt;  其中： - name 为扩展点的名字 - ref 为扩展点所作用在的 bean - object 为扩展点的贡献点具体的描述，这个描述是通过 XMap 的方式来进行的(XMap 的作用是将 Java 对象和 XML 文件进行映射，这里建议通过在网上搜索下 XMap 的文档来了解 XMap)\n定义扩展 上述已经将扩展点定义好了，此时我们就可以对这个 bean 进行扩展了:\n\u0026amp;lt;sofa:extension bean=\u0026amp;quot;extension\u0026amp;quot; point=\u0026amp;quot;word\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:content\u0026amp;gt; \u0026amp;lt;word\u0026amp;gt; \u0026amp;lt;value\u0026amp;gt;newValue\u0026amp;lt;/value\u0026amp;gt; \u0026amp;lt;/word\u0026amp;gt; \u0026amp;lt;/sofa:content\u0026amp;gt; \u0026amp;lt;/sofa:extension\u0026amp;gt;  其中： - bean 为扩展所作用在的 bean - point 为扩展点的名字 - content 里面的内容为扩展的定义，其会通过 XMap 将内容解析为：扩展点的贡献点具体的描述对象，在这里即为 com.alipay.sofa.boot.test.extension.ExtensionDescriptor 对象\n到这里，我们可以回头看一开始在 com.alipay.sofa.boot.test.impl.ExtensionImpl 中定义的 registerExtension 方法了，SOFABoot 在解析到贡献点时，会调用被扩展 bean 的 registerExtension 方法，其中包含了用户定义的贡献点处理逻辑，在上述的例子中，获取用户定义的 value 值，并将其设置到 word 字段中覆盖 bean 中原始定义的值。\n此时，调用 extension bean 的 say() 方法，可以看到返回扩展中定义的值: newValue 。\nXMap 支持和扩展 上述的例子中只是一个很简单的扩展，其实 XMap 包含了非常丰富的描述能力，包括 List, Map 等，这些可以通过查看 XMap 的文档来了解。\n在 SOFABoot 中，除了 XMap 原生的支持以外，还扩展了跟 Spring 集成的能力： - 通过 XNode 扩展出了 XNodeSpring - 通过 XNodeList 扩展出了 XNodeListSpring - 通过 XNodeMap 扩展出了 XNodeMapSpring\n这部分的扩展能力，让扩展点的能力更加丰富，描述对象中可以直接指向一个 SpringBean(用户配置 bean 的名字，SOFABoot 会根据名字从 spring 上下文中获取到 bean)，这里举一个使用 XNodeListSpring 的例子，依然是上述描述的三个步骤：\n定义提供扩展能力的 bean 接口定义：\n在这个接口里，返回一个 list，目标是这个 list 能够被通过扩展的方式填充\npackage com.alipay.sofa.boot.test; public interface IExtension { …","date":-62135596800,"description":"","dir":"projects/moss/extension/","fuzzywordcount":2000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f56c8e59884c28531ed14ca8e0fe1117","permalink":"/projects/moss/extension/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/moss/extension/","summary":"SOFABoot 支持模块化隔离，在实际的使用场景中，一个模块中的 bean 有时候需要开放一些入口，供另外一个模块扩展。SOFABoot 借鉴和使用了 Nuxeo Runtime 项目 以及 nuxeo 项","tags":null,"title":"SOFABoot 拓展点","type":"projects","url":"/projects/moss/extension/","wordcount":1959},{"author":null,"categories":null,"content":" SOFABoot 支持模块化隔离，在实际的使用场景中，一个模块中的 bean 有时候需要开放一些入口，供另外一个模块扩展。SOFABoot 借鉴和使用了 Nuxeo Runtime 项目 以及 nuxeo 项目，并在上面扩展，与 Spring 融合，提供扩展点的能力。\n使用 在 SOFABoot 中使用扩展点能力，需要以下三个步骤：\n定义提供扩展能力的 bean 在使用 SOFABoot 扩展点能力时，首先需要定一个需要被扩展的 bean，先定一个接口：\npackage com.alipay.sofa.boot.test; public interface IExtension { String say(); }  定义这个接口的实现：\npackage com.alipay.sofa.boot.test.impl; public class ExtensionImpl implements IExtension { private String word; @Override public String say() { return word; } public void setWord(String word) { this.word = word; } public void registerExtension(Extension extension) throws Exception { Object[] contributions = extension.getContributions(); String extensionPoint = extension.getExtensionPoint(); if (contributions == null) { return; } for (Object contribution : contributions) { if (\u0026amp;quot;word\u0026amp;quot;.equals(extensionPoint)) { setWord(((ExtensionDescriptor) contribution).getValue()); } } } }  在这里可以看到有一个方法：registerExtension ，暂时可以先不用管这个方法，后续会介绍其具体的作用。\n在模块的 Spring 配置文件中，我们把这个 bean 给配置起来：\n\u0026amp;lt;bean id=\u0026amp;quot;extension\u0026amp;quot; class=\u0026amp;quot;com.alipay.sofa.boot.test.impl.ExtensionImpl\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;word\u0026amp;quot; value=\u0026amp;quot;Hello, world\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  定义扩展点 在上面的 bean 中有一个字段 word ，在实际中，我们希望这个字段能够被其他的模块自定义进行覆盖，这里我们将其以扩展点的形式暴露出来。\n首先需要一个类去描述这个扩展点：\n@XObject(\u0026amp;quot;word\u0026amp;quot;) public class ExtensionDescriptor { @XNode(\u0026amp;quot;value\u0026amp;quot;) private String value; public String getValue() { return value; } }  然后在 xml 中定义扩展点：\n\u0026amp;lt;sofa:extension-point name=\u0026amp;quot;word\u0026amp;quot; ref=\u0026amp;quot;extension\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:object class=\u0026amp;quot;com.alipay.sofa.boot.test.extension.ExtensionDescriptor\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/sofa:extension-point\u0026amp;gt;  其中： - name 为扩展点的名字 - ref 为扩展点所作用在的 bean - object 为扩展点的贡献点具体的描述，这个描述是通过 XMap 的方式来进行的(XMap 的作用是将 Java 对象和 XML 文件进行映射，这里建议通过在网上搜索下 XMap 的文档来了解 XMap)\n定义扩展 上述已经将扩展点定义好了，此时我们就可以对这个 bean 进行扩展了:\n\u0026amp;lt;sofa:extension bean=\u0026amp;quot;extension\u0026amp;quot; point=\u0026amp;quot;word\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:content\u0026amp;gt; \u0026amp;lt;word\u0026amp;gt; \u0026amp;lt;value\u0026amp;gt;newValue\u0026amp;lt;/value\u0026amp;gt; \u0026amp;lt;/word\u0026amp;gt; \u0026amp;lt;/sofa:content\u0026amp;gt; \u0026amp;lt;/sofa:extension\u0026amp;gt;  其中： - bean 为扩展所作用在的 bean - point 为扩展点的名字 - content 里面的内容为扩展的定义，其会通过 XMap 将内容解析为：扩展点的贡献点具体的描述对象，在这里即为 com.alipay.sofa.boot.test.extension.ExtensionDescriptor 对象\n到这里，我们可以回头看一开始在 com.alipay.sofa.boot.test.impl.ExtensionImpl 中定义的 registerExtension 方法了，SOFABoot 在解析到贡献点时，会调用被扩展 bean 的 registerExtension 方法，其中包含了用户定义的贡献点处理逻辑，在上述的例子中，获取用户定义的 value 值，并将其设置到 word 字段中覆盖 bean 中原始定义的值。\n此时，调用 extension bean 的 say() 方法，可以看到返回扩展中定义的值: newValue 。\nXMap 支持和扩展 上述的例子中只是一个很简单的扩展，其实 XMap 包含了非常丰富的描述能力，包括 List, Map 等，这些可以通过查看 XMap 的文档来了解。\n在 SOFABoot 中，除了 XMap 原生的支持以外，还扩展了跟 Spring 集成的能力： - 通过 XNode 扩展出了 XNodeSpring - 通过 XNodeList 扩展出了 XNodeListSpring - 通过 XNodeMap 扩展出了 XNodeMapSpring\n这部分的扩展能力，让扩展点的能力更加丰富，描述对象中可以直接指向一个 SpringBean(用户配置 bean 的名字，SOFABoot 会根据名字从 spring 上下文中获取到 bean)，这里举一个使用 XNodeListSpring 的例子，依然是上述描述的三个步骤：\n定义提供扩展能力的 bean 接口定义：\n在这个接口里，返回一个 list，目标是这个 list 能够被通过扩展的方式填充\npackage com.alipay.sofa.boot.test; public interface IExtension { …","date":-62135596800,"description":"","dir":"projects/sofa-boot/extension/","fuzzywordcount":2000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"93225b6c1f2b68f2047a7cf49b76650b","permalink":"/projects/sofa-boot/extension/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/sofa-boot/extension/","summary":"SOFABoot 支持模块化隔离，在实际的使用场景中，一个模块中的 bean 有时候需要开放一些入口，供另外一个模块扩展。SOFABoot 借鉴和使用了 Nuxeo Runtime 项目 以及 nuxeo 项","tags":null,"title":"SOFABoot 拓展点","type":"projects","url":"/projects/sofa-boot/extension/","wordcount":1959},{"author":null,"categories":null,"content":" SOFAArk 容器提供了一个简单的 telnet 服务端小工具，用于运行时查看容器状态，目前支持查看 Plugin 和 Biz 相关信息。\n使用方式 使用 telnet 连接服务端，端口号为 1234， 例如：\n telnet localhost 1234\n 进入交互界面:\n➜ telnet localhost 1234 Trying 127.0.0.1... Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. sofa-ark\u0026amp;gt; sofa-ark\u0026amp;gt; sofa-ark\u0026amp;gt;  目前支持查看 Plugin 和 Biz 相关信息，相关命令可参考提示信息：\nsofa-ark\u0026amp;gt;h Plugin Command Tips: USAGE: plugin [option...] [pluginName...] SAMPLE: plugin -m plugin-A plugin-B -h Shows the help message. -a Shows all plugin name. -m Shows the meta info of specified pluginName. -s Shows the service info of specified pluginName. -d Shows the detail info of specified pluginName. Biz Command Tips: USAGE: biz [option...] [arguments...] SAMPLE: biz -m bizIdentityA bizIdentityB. -h Shows the help message. -a Shows all biz. -m Shows the meta info of specified bizIdentity. -s Shows the service info of specified bizIdentity. -d Shows the detail info of specified bizIdentity. -i Install biz of specified bizIdentity or bizUrl. -u Uninstall biz of specified bizIdentity. -o Switch biz of specified bizIdentity. sofa-ark\u0026amp;gt;  Plugin 命令 如提示信息所说，plugin 支持查看插件相关信息，包括类(资源)导入导出配置、插件打包配置等。例如：\nsofa-ark\u0026amp;gt;plugin -md runtime-sofa-boot-plugin PluginName: runtime-sofa-boot-plugin Version: 3.1.3 Priority: 1500 Activator: com.alipay.sofa.runtime.integration.activator.SofaRuntimeActivator Export Packages: com.alipay.sofa.runtime.api.*,com.alipay.sofa.runtime.client.*,com.alipay.sofa.runtime.component.*,com.alipay.sofa.runtime.constants.*,com.alipay.sofa.runtime.integration.*,com.alipay.sofa.runtime.model.*,com.alipay.sofa.runtime.service.component,com.alipay.sofa.runtime.service.helper,com.alipay.sofa.runtime.spi.client,com.alipay.sofa.runtime.spi.component,com.alipay.sofa.runtime.spi.health,com.alipay.sofa.runtime.spi.log,com.alipay.sofa.runtime.spi.binding,com.alipay.sofa.runtime.spi.util,org.aopalliance.aop,org.aopalliance.intercept Import Packages: \\ Export Classes: com.alipay.sofa.runtime.service.binding.JvmBinding,com.alipay.sofa.runtime.SofaFramework,com.alipay.sofa.runtime.SofaRuntimeProperties,com.alipay.sofa.runtime.service.binding.JvmBindingParam,com.alipay.sofa.runtime.spi.service.ServiceProxy Import Classes: \\ Export Resources: \\ Import Resources: \\ GroupId: com.alipay.sofa ArtifactId: runtime-sofa-boot-plugin Version: 3.1.3 URL: jar:file:/Users/qilong.zql/.m2/repository/com/alipay/sofa/runtime-sofa-boot-plugin/3.1.3/runtime-sofa-boot-plugin-3.1.3.jar!/ ClassLoader: com.alipay.sofa.ark.container.service.classloader.PluginClassLoader@420a63fb ClassPath: …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-telnet/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5a6fa7ebfa010a607e96d02a2b674d13","permalink":"/projects/moss/sofa-ark-ark-telnet/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/sofa-ark-ark-telnet/","summary":"SOFAArk 容器提供了一个简单的 telnet 服务端小工具，用于运行时查看容器状态，目前支持查看 Plugin 和 Biz 相关信息。 使用方式 使用 telnet 连接服务端，端口号为 1234， 例如：","tags":null,"title":"Telnet 指令","type":"projects","url":"/projects/moss/sofa-ark-ark-telnet/","wordcount":513},{"author":null,"categories":null,"content":" SOFAArk 容器提供了一个简单的 telnet 服务端小工具，用于运行时查看容器状态，目前支持查看 Plugin 和 Biz 相关信息。\n使用方式 使用 telnet 连接服务端，端口号为 1234， 例如：\n telnet localhost 1234\n 进入交互界面:\n➜ telnet localhost 1234 Trying 127.0.0.1... Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. sofa-ark\u0026amp;gt; sofa-ark\u0026amp;gt; sofa-ark\u0026amp;gt;  目前支持查看 Plugin 和 Biz 相关信息，相关命令可参考提示信息：\nsofa-ark\u0026amp;gt;h Plugin Command Tips: USAGE: plugin [option...] [pluginName...] SAMPLE: plugin -m plugin-A plugin-B -h Shows the help message. -a Shows all plugin name. -m Shows the meta info of specified pluginName. -s Shows the service info of specified pluginName. -d Shows the detail info of specified pluginName. Biz Command Tips: USAGE: biz [option...] [arguments...] SAMPLE: biz -m bizIdentityA bizIdentityB. -h Shows the help message. -a Shows all biz. -m Shows the meta info of specified bizIdentity. -s Shows the service info of specified bizIdentity. -d Shows the detail info of specified bizIdentity. -i Install biz of specified bizIdentity or bizUrl. -u Uninstall biz of specified bizIdentity. -o Switch biz of specified bizIdentity. sofa-ark\u0026amp;gt;  Plugin 命令 如提示信息所说，plugin 支持查看插件相关信息，包括类(资源)导入导出配置、插件打包配置等。例如：\nsofa-ark\u0026amp;gt;plugin -md runtime-sofa-boot-plugin PluginName: runtime-sofa-boot-plugin Version: 3.1.3 Priority: 1500 Activator: com.alipay.sofa.runtime.integration.activator.SofaRuntimeActivator Export Packages: com.alipay.sofa.runtime.api.*,com.alipay.sofa.runtime.client.*,com.alipay.sofa.runtime.component.*,com.alipay.sofa.runtime.constants.*,com.alipay.sofa.runtime.integration.*,com.alipay.sofa.runtime.model.*,com.alipay.sofa.runtime.service.component,com.alipay.sofa.runtime.service.helper,com.alipay.sofa.runtime.spi.client,com.alipay.sofa.runtime.spi.component,com.alipay.sofa.runtime.spi.health,com.alipay.sofa.runtime.spi.log,com.alipay.sofa.runtime.spi.binding,com.alipay.sofa.runtime.spi.util,org.aopalliance.aop,org.aopalliance.intercept Import Packages: \\ Export Classes: com.alipay.sofa.runtime.service.binding.JvmBinding,com.alipay.sofa.runtime.SofaFramework,com.alipay.sofa.runtime.SofaRuntimeProperties,com.alipay.sofa.runtime.service.binding.JvmBindingParam,com.alipay.sofa.runtime.spi.service.ServiceProxy Import Classes: \\ Export Resources: \\ Import Resources: \\ GroupId: com.alipay.sofa ArtifactId: runtime-sofa-boot-plugin Version: 3.1.3 URL: jar:file:/Users/qilong.zql/.m2/repository/com/alipay/sofa/runtime-sofa-boot-plugin/3.1.3/runtime-sofa-boot-plugin-3.1.3.jar!/ ClassLoader: com.alipay.sofa.ark.container.service.classloader.PluginClassLoader@420a63fb ClassPath: …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-telnet/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f23d585e5439569b47ed83f7bc955b22","permalink":"/projects/sofa-boot/sofa-ark-ark-telnet/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-telnet/","summary":"SOFAArk 容器提供了一个简单的 telnet 服务端小工具，用于运行时查看容器状态，目前支持查看 Plugin 和 Biz 相关信息。 使用方式 使用 telnet 连接服务端，端口号为 1234， 例如：","tags":null,"title":"Telnet 指令","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-telnet/","wordcount":513},{"author":null,"categories":null,"content":" 在介绍 Biz 生命周期 时，我们提到了有三种方式控制 Biz 的生命周期，并且介绍了使用客户端 API 实现 Biz 的安装、卸载、激活。在这一章节我们介绍如何使用 SOFAArk 提供的动态配置插件，通过 Zookeeper 下发指令，控制 Biz 的生命周期。\n引入依赖 SOFAArk 提供了 config-ark-plugin 对接 Zookeeper 配置中心，用于运行时接受配置，达到控制 Biz 生命周期，引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;config-ark-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  配置 ZK 地址 参考 SOFAArk 配置，在 SOFAArk 配置文件 conf/ark/bootstrap.properties 增加如下配置：\ncom.alipay.sofa.ark.config.address=zookeeper://ip:port  配置维度 SOFAArk 启动后，会在 ZK 注册两个节点配置，分别是宿主应用维度和 IP 维度：\n sofa-ark/${com.alipay.sofa.ark.master.biz}/ \u0026amp;gt; 宿主应用维度配置，应用启动时，会拉取该维度配置，控制相关 Biz 的部署；应用重启后，配置不会丢失\n sofa-ark/${com.alipay.sofa.ark.master.biz}/ip/ \u0026amp;gt; IP 维度配置，应用重启后丢失，通常用于运行时控制单台机器的 Biz 行为\n  通过写这两个节点的配置，可以控制相关机器和应用的 Biz 运行时状态。\n配置形式 下面介绍配置的形式，动态配置采用状态声明指令，SOFAArk 收到配置后，会根据状态描述解析出具体的指令（包括 install，uninstall, switch），指令格式如下：\nbizName:bizVersion:bizState?k1=v1\u0026amp;amp;k2=v2\n多条指令使用 ; 隔开，单条指令主要由 biz 名称，biz 版本，biz 预期状态及参数组成。简单记住一点，状态配置是描述指令推送之后，所有非宿主 Biz 的状态；\n例如当前 SOFAArk 容器部署了两个应用 A，B，版本均为 1.0，其中 A 应用为宿主应用，因为宿主应用不可卸载，因此不需要考虑宿主应用，可以简单认为当前容器的 Biz 状态声明为：\n B:1.0:Activated\n 如果此时你希望安装 C 应用，版本为 1.0，文件流地址为 urlC，那么推送指令应为：\n B:1.0:Activated;C:1.0:Activated?bizUrl=urlC\n 操作继续，如果你又希望安装安装 B 应用，版本为 2.0，文件流地址为 urlB，且希望 2.0 版本处于激活状态，那么你推送的指令应为：\n B:1.0:Deactivated;B:2.0:Actaivated?bizUrl=urlB;C:1.0:Activated\n解释下为什么是这样配置指令，因为 SOFAArk 只允许应用一个版本处于激活状态，如果存在其他版本，则应处于非激活状态；所以当希望激活 B 应用 2.0 版本时，B 应用 1.0 版本应该声明为非激活状态。另外你可能注意到了 C 应用参数 urlC 不用声明了，原因是目前只有当安装新 Biz 时，才有可能需要配置参数 bizUrl，用于指定 biz 文件流地址，其他场景下，参数的解析没有意义。\n 操作继续，如果你希望卸载 B 应用 2.0 版本，激活 B 应用 1.0 版本，卸载 C 应用，那么推送的指令声明为：\n B:1.0:Activated\n 从上面的操作描述看，在推送动态配置时，只需要声明期望的 Biz 状态即可，SOFAArk 会根据状态声明推断具体的执行指令，并尽可能保持服务的连续性，以上面最后一步操作为例，SOFAArk 推断的执行指令顺序如下： + 执行 switch 指令，激活 B 应用 1.0 版本，钝化 B 应用 2.0 版本，保证服务连续性 + 执行 uninstall 指令，卸载 B 应用 2.0 版本 + 执行 uninstall 指令，卸载 C 应用 1.0 版本\n注意事项 目前只有在安装新 Biz 时才可能使用指令参数 bizUrl，用于指定 Biz 文件流地址。文件流地址字符串是能够直接构建 URL 对象，例如 file://xxx 或者 http://xxx. 安装新 Biz 时，参数 bizUrl 不是必须的，SOFAArk 提供了扩展点：\n@Extensible public interface BizFileGenerator { File createBizFile(String bizName, String bizVersion); }  用于扩展实现，根据 biz 名称和 biz 版本返回 biz 文件。\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-zk-config/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"cfe8f68dd7ed1afe779d91f9bd4dcfb5","permalink":"/projects/moss/sofa-ark-zk-config/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-zk-config/","summary":"在介绍 Biz 生命周期 时，我们提到了有三种方式控制 Biz 的生命周期，并且介绍了使用客户端 API 实现 Biz 的安装、卸载、激活。在这一章节我们介绍如何使用 SOFAArk 提供的","tags":null,"title":"Zookeeper 配置","type":"projects","url":"/projects/moss/sofa-ark-zk-config/","wordcount":1160},{"author":null,"categories":null,"content":" 在介绍 Biz 生命周期 时，我们提到了有三种方式控制 Biz 的生命周期，并且介绍了使用客户端 API 实现 Biz 的安装、卸载、激活。在这一章节我们介绍如何使用 SOFAArk 提供的动态配置插件，通过 Zookeeper 下发指令，控制 Biz 的生命周期。\n引入依赖 SOFAArk 提供了 config-ark-plugin 对接 Zookeeper 配置中心，用于运行时接受配置，达到控制 Biz 生命周期，引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;config-ark-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  配置 ZK 地址 参考 SOFAArk 配置，在 SOFAArk 配置文件 conf/ark/bootstrap.properties 增加如下配置：\ncom.alipay.sofa.ark.config.address=zookeeper://ip:port  配置维度 SOFAArk 启动后，会在 ZK 注册两个节点配置，分别是宿主应用维度和 IP 维度：\n sofa-ark/${com.alipay.sofa.ark.master.biz}/ \u0026amp;gt; 宿主应用维度配置，应用启动时，会拉取该维度配置，控制相关 Biz 的部署；应用重启后，配置不会丢失\n sofa-ark/${com.alipay.sofa.ark.master.biz}/ip/ \u0026amp;gt; IP 维度配置，应用重启后丢失，通常用于运行时控制单台机器的 Biz 行为\n  通过写这两个节点的配置，可以控制相关机器和应用的 Biz 运行时状态。\n配置形式 下面介绍配置的形式，动态配置采用状态声明指令，SOFAArk 收到配置后，会根据状态描述解析出具体的指令（包括 install，uninstall, switch），指令格式如下：\nbizName:bizVersion:bizState?k1=v1\u0026amp;amp;k2=v2\n多条指令使用 ; 隔开，单条指令主要由 biz 名称，biz 版本，biz 预期状态及参数组成。简单记住一点，状态配置是描述指令推送之后，所有非宿主 Biz 的状态；\n例如当前 SOFAArk 容器部署了两个应用 A，B，版本均为 1.0，其中 A 应用为宿主应用，因为宿主应用不可卸载，因此不需要考虑宿主应用，可以简单认为当前容器的 Biz 状态声明为：\n B:1.0:Activated\n 如果此时你希望安装 C 应用，版本为 1.0，文件流地址为 urlC，那么推送指令应为：\n B:1.0:Activated;C:1.0:Activated?bizUrl=urlC\n 操作继续，如果你又希望安装安装 B 应用，版本为 2.0，文件流地址为 urlB，且希望 2.0 版本处于激活状态，那么你推送的指令应为：\n B:1.0:Deactivated;B:2.0:Actaivated?bizUrl=urlB;C:1.0:Activated\n解释下为什么是这样配置指令，因为 SOFAArk 只允许应用一个版本处于激活状态，如果存在其他版本，则应处于非激活状态；所以当希望激活 B 应用 2.0 版本时，B 应用 1.0 版本应该声明为非激活状态。另外你可能注意到了 C 应用参数 urlC 不用声明了，原因是目前只有当安装新 Biz 时，才有可能需要配置参数 bizUrl，用于指定 biz 文件流地址，其他场景下，参数的解析没有意义。\n 操作继续，如果你希望卸载 B 应用 2.0 版本，激活 B 应用 1.0 版本，卸载 C 应用，那么推送的指令声明为：\n B:1.0:Activated\n 从上面的操作描述看，在推送动态配置时，只需要声明期望的 Biz 状态即可，SOFAArk 会根据状态声明推断具体的执行指令，并尽可能保持服务的连续性，以上面最后一步操作为例，SOFAArk 推断的执行指令顺序如下： + 执行 switch 指令，激活 B 应用 1.0 版本，钝化 B 应用 2.0 版本，保证服务连续性 + 执行 uninstall 指令，卸载 B 应用 2.0 版本 + 执行 uninstall 指令，卸载 C 应用 1.0 版本\n注意事项 目前只有在安装新 Biz 时才可能使用指令参数 bizUrl，用于指定 Biz 文件流地址。文件流地址字符串是能够直接构建 URL 对象，例如 file://xxx 或者 http://xxx. 安装新 Biz 时，参数 bizUrl 不是必须的，SOFAArk 提供了扩展点：\n@Extensible public interface BizFileGenerator { File createBizFile(String bizName, String bizVersion); }  用于扩展实现，根据 biz 名称和 biz 版本返回 biz 文件。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-zk-config/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c675734b1cb5fa546f96a31d8b9e3533","permalink":"/projects/sofa-boot/sofa-ark-zk-config/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-zk-config/","summary":"在介绍 Biz 生命周期 时，我们提到了有三种方式控制 Biz 的生命周期，并且介绍了使用客户端 API 实现 Biz 的安装、卸载、激活。在这一章节我们介绍如何使用 SOFAArk 提供的","tags":null,"title":"Zookeeper 配置","type":"projects","url":"/projects/sofa-boot/sofa-ark-zk-config/","wordcount":1160},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"使用该指南您可以快速部署应用到 CloudMesh ，对服务进行访问，通过监控查看流量，体验服务治理、Sidecar管理和对服务的新版本进行灰度发布等实用功能。","dir":"guides/kc-cloud-mesh-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e389a65e6736e909718275cd76505525","permalink":"/guides/kc-cloud-mesh-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-cloud-mesh-demo/","summary":"","tags":null,"title":"使用 CloudMesh 轻松实践 Service Mesh","type":"guides","url":"/guides/kc-cloud-mesh-demo/","wordcount":0},{"author":null,"categories":null,"content":" 摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter。\nzuul的Filter类型 Zuul 的 Filter 是通过filterType()方法来指定，一个 Filter 只能对应一种类型，要么是 “pre” 要么是“post”\nSpring Cloud Gateway的Filter类型 Spring Cloud Gateway 基于 Project Reactor 和 WebFlux，采用响应式编程风格，打开它的 Filter 的接口GatewayFilter你会发现它只有一个方法filter\nPre类型的Filter 在Spring Cloud Gateway源码中定义了一个Pre类型的Filter，code将会在chain.filter() 之前被执行,代码:AddRequestHeader\npackage org.springframework.cloud.gateway.filter.factory; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.http.server.reactive.ServerHttpRequest; /** * @author Spencer Gibb */ public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory { @Override public GatewayFilter apply(NameValueConfig config) { return (exchange, chain) -\u0026amp;gt; { ServerHttpRequest request = exchange.getRequest().mutate() .header(config.getName(), config.getValue()) .build(); return chain.filter(exchange.mutate().request(request).build()); }; } }  Post类型的Filter 对于Post类型的Filter，SetStatus 代码将会在chain.filter(exchange).then()里面的代码运行。\npublic class SetStatusGatewayFilterFactory extends AbstractGatewayFilterFactory\u0026amp;lt;SetStatusGatewayFilterFactory.Config\u0026amp;gt; { @Override public GatewayFilter apply(Config config) { final HttpStatus status = ServerWebExchangeUtils.parse(config.status); return (exchange, chain) -\u0026amp;gt; { return chain.filter(exchange).then(Mono.fromRunnable(() -\u0026amp;gt; { // check not really needed, since it is guarded in setStatusCode, // but it\u0026#39;s a good example if (!exchange.getResponse().isCommitted()) { setResponseStatus(exchange, status); } })); }; } }  ","date":-62135596800,"description":"本指南将基于 SOFAStack 快速构建一个微服务。","dir":"guides/sofastack-quick-start/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"78bfd4806a86dc15ac86eee16fb85c82","permalink":"/guides/sofastack-quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/guides/sofastack-quick-start/","summary":"摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Fi","tags":null,"title":"使用 SOFAStack 快速构建微服务","type":"guides","url":"/guides/sofastack-quick-start/","wordcount":491},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"该指南将向您展示如何使用开源分布式事务框架 Seata 的 AT 模式、TCC 模式解决业务数据的最终一致性问题。 ","dir":"guides/kc-seata-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"60071a0eb44bf0901fb187eefd63ccdb","permalink":"/guides/kc-seata-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-seata-demo/","summary":"","tags":null,"title":"使用 Seata 保障支付一致性","type":"guides","url":"/guides/kc-seata-demo/","wordcount":0},{"author":null,"categories":null,"content":" SOFABoot 是在 Spring Boot 的基础上提供的功能扩展。基于 Spring Boot 的机制，SOFABoot 管理了 SOFA 中间件的依赖，并且提供了 Spring Boot 的 Starter，方便用户在 Spring Boot 中使用 SOFA 中间件。\nSOFABoot 依赖管理 \u0026amp;ndash; Maven 在使用 SOFA 中间件之前，需要引入 SOFABoot 依赖管理。类似 Spring Boot 引入方式，在工程中增加如下 \u0026amp;lt;parent/\u0026amp;gt; 标签配置的方式:\n\u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofaboot-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.boot.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt;  其中 ${sofa.boot.version} 为具体的 SOFABoot 版本，参考发布历史。\nSOFABoot 依赖管理 \u0026amp;ndash; Gradle 从 SOFABoot 3.1.1 版本开始，SOFABoot 开始支持使用 Gradle 来进行依赖管理，如果要使用 Gradle 来进行依赖管理，需要按照如下的形式来配置 build.gradle：\nbuildscript { ext { sofaBootVersion = \u0026#39;3.1.1\u0026#39; } repositories { mavenLocal() mavenCentral() } dependencies { classpath(\u0026amp;quot;com.alipay.sofa:sofa-boot-gradle-plugin:${sofaBootVersion}\u0026amp;quot;) } } apply plugin: \u0026#39;java\u0026#39; apply plugin: \u0026#39;eclipse\u0026#39; apply plugin: \u0026#39;com.alipay.sofa.boot\u0026#39; apply plugin: \u0026#39;io.spring.dependency-management\u0026#39; group = \u0026#39;com.example\u0026#39; version = \u0026#39;0.0.1-SNAPSHOT\u0026#39; sourceCompatibility = 1.8 repositories { mavenLocal() mavenCentral() } dependencies { implementation(\u0026#39;com.alipay.sofa:rpc-sofa-boot-starter\u0026#39;) implementation(\u0026#39;org.springframework.boot:spring-boot-starter\u0026#39;) testImplementation(\u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39;) }  主要有几个步骤：\n 添加 buildScript，增加 sofa-boot-gradle-plugin 的依赖，其中版本号为你使用的 SOFABoot 的版本。 添加两个 plugin，分别是 com.alipay.sofa.boot 和 io.spring.dependency-management。  这样，在 dependencies 里面，就可以直接添加 SOFABoot 管理的各种中间件和依赖了，而不用声明版本号。\n引入 SOFA 中间件 SOFABoot 使用一系列后缀为 -sofa-boot-starter 来标示一个中间件组件，如果想要使用某个中间件，直接添加对应的依赖即可。例如，如果期望使用 SOFARPC，只需增加下面的 Maven 依赖即可：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;rpc-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  注意上面的 Maven 依赖中并没有声明版本，这个是因为版本已经在 sofaboot-dependencies 里面声明好。这样做的好处是对于 SOFA 中间件，用户统一进行升级即可，不需要单独升级一个中间件的版本，防止出现依赖冲突以及兼容性的问题。目前管控的 SOFABoot 中间件列表如下:\n   中间件 starter     SOFARPC rpc-sofa-boot-starter   SOFATracer tracer-sofa-boot-starter   SOFALookout lookout-sofa-boot-starter    引入 SOFABoot 扩展组件 SOFABoot 基于 Spring Boot 提供了健康检查，模块隔离，类隔离等扩展能力。遵循 Spring Boot 依赖即服务的理念，添加相关组件依赖之后，扩展能力即可生效。目前提供的扩展组件如下：\n   扩展组件 starter     健康检查 healthcheck-sofa-boot-starter   模块化隔离 isle-sofa-boot-starter   类隔离 sofa-ark-springboot-starter   测试扩展 test-sofa-boot-starter    引入 SOFA 中间件 ark 插件 SOFABoot 提供了类隔离组件 SOFAArk，借助 SOFAArk 容器，用户可以将依赖冲突的三方包打包成 ark 插件。运行时，ark 插件使用单独的类加载器加载，可以和其他 ark 插件以及业务依赖隔离，解决类冲突问题。SOFABoot 官方提供了 SOFARPC 和 SOFATracer 的 ark 插件，例如在应用中引入 SOFARPC ark 插件依赖替代 SOFARPC starter，从而隔离应用和 SOFARPC 及其间接依赖。目前管控的 ark 插件列表如下:\n   Ark插件 plugin     SOFARPC rpc-sofa-boot-plugin   SOFATracer tracer-sofa-boot-plugin    引入 SOFABoot 命名空间 使用 SOFA 中间件时，需要在 XML 中根据中间件的具体使用方式添加相应的配置，这个时候需要引入 SOFABoot 的命名空间 xmlns:sofa=\u0026amp;quot;http://sofastack.io/schema/sofaboot\u0026amp;quot; 以能够正确解析相应的配置标签，示例：\n\u0026amp;lt;beans xmlns=\u0026amp;quot;http://www.springframework.org/schema/beans\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; …","date":-62135596800,"description":"","dir":"projects/moss/dependency-management/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5607e4731f50f00def324fcf397450da","permalink":"/projects/moss/dependency-management/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/dependency-management/","summary":"SOFABoot 是在 Spring Boot 的基础上提供的功能扩展。基于 Spring Boot 的机制，SOFABoot 管理了 SOFA 中间件的依赖，并且提供了 Spring Boot 的 Starter，方便用户在 Spring Boot 中使用","tags":null,"title":"依赖管理","type":"projects","url":"/projects/moss/dependency-management/","wordcount":979},{"author":null,"categories":null,"content":" SOFABoot 是在 Spring Boot 的基础上提供的功能扩展。基于 Spring Boot 的机制，SOFABoot 管理了 SOFA 中间件的依赖，并且提供了 Spring Boot 的 Starter，方便用户在 Spring Boot 中使用 SOFA 中间件。\nSOFABoot 依赖管理 \u0026amp;ndash; Maven 在使用 SOFA 中间件之前，需要引入 SOFABoot 依赖管理。类似 Spring Boot 引入方式，在工程中增加如下 \u0026amp;lt;parent/\u0026amp;gt; 标签配置的方式:\n\u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofaboot-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.boot.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt;  其中 ${sofa.boot.version} 为具体的 SOFABoot 版本，参考发布历史。\nSOFABoot 依赖管理 \u0026amp;ndash; Gradle 从 SOFABoot 3.1.1 版本开始，SOFABoot 开始支持使用 Gradle 来进行依赖管理，如果要使用 Gradle 来进行依赖管理，需要按照如下的形式来配置 build.gradle：\nbuildscript { ext { sofaBootVersion = \u0026#39;3.1.1\u0026#39; } repositories { mavenLocal() mavenCentral() } dependencies { classpath(\u0026amp;quot;com.alipay.sofa:sofa-boot-gradle-plugin:${sofaBootVersion}\u0026amp;quot;) } } apply plugin: \u0026#39;java\u0026#39; apply plugin: \u0026#39;eclipse\u0026#39; apply plugin: \u0026#39;com.alipay.sofa.boot\u0026#39; apply plugin: \u0026#39;io.spring.dependency-management\u0026#39; group = \u0026#39;com.example\u0026#39; version = \u0026#39;0.0.1-SNAPSHOT\u0026#39; sourceCompatibility = 1.8 repositories { mavenLocal() mavenCentral() } dependencies { implementation(\u0026#39;com.alipay.sofa:rpc-sofa-boot-starter\u0026#39;) implementation(\u0026#39;org.springframework.boot:spring-boot-starter\u0026#39;) testImplementation(\u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39;) }  主要有几个步骤：\n 添加 buildScript，增加 sofa-boot-gradle-plugin 的依赖，其中版本号为你使用的 SOFABoot 的版本。 添加两个 plugin，分别是 com.alipay.sofa.boot 和 io.spring.dependency-management。  这样，在 dependencies 里面，就可以直接添加 SOFABoot 管理的各种中间件和依赖了，而不用声明版本号。\n引入 SOFA 中间件 SOFABoot 使用一系列后缀为 -sofa-boot-starter 来标示一个中间件组件，如果想要使用某个中间件，直接添加对应的依赖即可。例如，如果期望使用 SOFARPC，只需增加下面的 Maven 依赖即可：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;rpc-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  注意上面的 Maven 依赖中并没有声明版本，这个是因为版本已经在 sofaboot-dependencies 里面声明好。这样做的好处是对于 SOFA 中间件，用户统一进行升级即可，不需要单独升级一个中间件的版本，防止出现依赖冲突以及兼容性的问题。目前管控的 SOFABoot 中间件列表如下:\n   中间件 starter     SOFARPC rpc-sofa-boot-starter   SOFATracer tracer-sofa-boot-starter   SOFALookout lookout-sofa-boot-starter    引入 SOFABoot 扩展组件 SOFABoot 基于 Spring Boot 提供了健康检查，模块隔离，类隔离等扩展能力。遵循 Spring Boot 依赖即服务的理念，添加相关组件依赖之后，扩展能力即可生效。目前提供的扩展组件如下：\n   扩展组件 starter     健康检查 healthcheck-sofa-boot-starter   模块化隔离 isle-sofa-boot-starter   类隔离 sofa-ark-springboot-starter   测试扩展 test-sofa-boot-starter    引入 SOFA 中间件 ark 插件 SOFABoot 提供了类隔离组件 SOFAArk，借助 SOFAArk 容器，用户可以将依赖冲突的三方包打包成 ark 插件。运行时，ark 插件使用单独的类加载器加载，可以和其他 ark 插件以及业务依赖隔离，解决类冲突问题。SOFABoot 官方提供了 SOFARPC 和 SOFATracer 的 ark 插件，例如在应用中引入 SOFARPC ark 插件依赖替代 SOFARPC starter，从而隔离应用和 SOFARPC 及其间接依赖。目前管控的 ark 插件列表如下:\n   Ark插件 plugin     SOFARPC rpc-sofa-boot-plugin   SOFATracer tracer-sofa-boot-plugin    引入 SOFABoot 命名空间 使用 SOFA 中间件时，需要在 XML 中根据中间件的具体使用方式添加相应的配置，这个时候需要引入 SOFABoot 的命名空间 xmlns:sofa=\u0026amp;quot;http://sofastack.io/schema/sofaboot\u0026amp;quot; 以能够正确解析相应的配置标签，示例：\n\u0026amp;lt;beans xmlns=\u0026amp;quot;http://www.springframework.org/schema/beans\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; …","date":-62135596800,"description":"","dir":"projects/sofa-boot/dependency-management/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"dabdbd425f20dee4d7ab580d43574456","permalink":"/projects/sofa-boot/dependency-management/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/dependency-management/","summary":"SOFABoot 是在 Spring Boot 的基础上提供的功能扩展。基于 Spring Boot 的机制，SOFABoot 管理了 SOFA 中间件的依赖，并且提供了 Spring Boot 的 Starter，方便用户在 Spring Boot 中使用","tags":null,"title":"依赖管理","type":"projects","url":"/projects/sofa-boot/dependency-management/","wordcount":979},{"author":null,"categories":null,"content":" SOFABoot 为 Spring Boot 的健康检查能力增加了 Readiness Check 的能力。如果你需要使用 SOFA 中间件，那么建议使用 SOFABoot 的健康检查能力的扩展，来更优雅的上线应用实例\n引入健康检查扩展 要引入 SOFABoot 的健康检查能力的扩展，只需要引入以下的 Starter 即可：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;healthcheck-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  如果不引入 SOFABoot 的健康检查扩展，用户依然可以直接依赖 HealthIndicator 接口进行原生的 Spring Boot Actuator 的 Liveness Check。\n安全提醒 从 SOFABoot 2.3.0 开始，由于健康检查能力依赖于 SpringBoot 1.4.x 里的 Actuator 组件，而 Actuator 会默认开启很多 EndPoint，例如 /dump，/trace 等等，可能存在安全风险，可以参照官方文档里的安全建议进行设置。\n SpringBoot 1.5.x 和 SpringBoot 2.x 已修复了部分安全行为，SOFABoot 将通过升级 SpringBoot 内核进行支持。\n 查看健康检查结果 加入健康检查扩展之后，我们可以直接在浏览器中输入 http://localhost:8080/health/readiness 来查看 Readiness Check 的结果。如果要查看 Liveness Check 的结果，可以直接查看 Spring Boot 的健康检查的 URL http://localhost:8080/health。\n除了通过 URL 来查看健康检查的结果之外，在 SOFABoot 中，还可以通过查看具体的日志来确定健康检查的结果，日志的目录位于 health-check 目录下，日志的内容大概如下：\n2018-04-06 23:29:50,240 INFO main - Readiness check result: success  目前 SOFA 中间件已经通过 SOFABoot 的 Readiness Check 的能力来控制了上游流量的进入，但是一个应用的流量可能并不是全部都是从中间件进入的，比较常见的还有从负载均衡器进入的，为了控制从负载均衡器进入的流量，建议使用者通过 PAAS 来访问 Readiness Check 的结果，根据结果来控制是否要在负载均衡器中上线对应的节点。\n注: 自 SOFABoot 2.x 之后，不再间接引入 spring-boot-starter-web 依赖，如果需要在浏览器中查看健康检查结果，需要额外在工程中引入 web 容器依赖。\n注: 在 SOFABoot 3.x 中调整了 endpoint 路径，health/readiness 更改为 actuator/readiness\n扩展 Readiness Check 能力 在 Readiness Check 的各个阶段，SOFABoot 都提供了扩展的能力，应用可以根据自己的需要进行扩展，在 2.x 版本中，可供扩展的点如下：\n   回调接口 说明     org.springframework.context.ApplicationListener 如果想要在 Readiness Check 之前做一些事情，那么监听这个 Listener 的 SofaBootBeforeHealthCheckEvent 事件。   org.springframework.boot.actuate.health.HealthIndicator 如果想要在 SOFABoot 的 Readiness Check 里面增加一个检查项，那么可以直接扩展 Spring Boot 的这个接口。   com.alipay.sofa.healthcheck.startup.SofaBootAfterReadinessCheckCallback 如果想要在 Readiness Check 之后做一些事情，那么可以扩展 SOFABoot 的这个接口。    在 3.x 版本中，可供扩展点如下：\n   回调接口 说明     com.alipay.sofa.healthcheck.core.HealthChecker 如果想要在 SOFABoot 的 Readiness Check 里面增加一个检查项，可以直接扩展该接口。相较于 Spring Boot 本身的 HealthIndicator 接口，该接口提供了一些额外的参数配置，比如检查失败重试次数等。   org.springframework.boot.actuate.health.HealthIndicator 如果想要在 SOFABoot 的 Readiness Check 里面增加一个检查项，那么可以直接扩展 Spring Boot 的这个接口。   org.springframework.boot.actuate.health.ReactiveHealthIndicator 在 WebFlux 中，如果想要在 SOFABoot 的 Readiness Check 里面增加一个检查项，那么可以直接扩展 Spring Boot 的这个接口。   com.alipay.sofa.healthcheck.startup.ReadinessCheckCallback 如果想要在 Readiness Check 之后做一些事情，那么可以扩展 SOFABoot 的这个接口。    需要指出的是，上述四个扩展接口均可以通过 Spring Boot 标准的 Ordered, PriorityOrdered 和注解 @Order 实现执行顺序的设置。\nReadiness Check 配置项 应用在引入 SOFABoot 的健康检查扩展之后，可以在 Spring Boot 的配置文件 application.properties 中添加相关配置项来定制 Readiness Check 的相关行为。\n   Readiness Check 配置项 说明 默认值 开始支持版本     com.alipay.sofa.healthcheck.skip.all 是否跳过整个 Readiness Check 阶段 false 2.4.0   com.alipay.sofa.healthcheck.skip.component 是否跳过 SOFA 中间件的 Readiness Check false 2.4.0   com.alipay.sofa.healthcheck.skip.indicator 是否跳过 HealthIndicator 的 Readiness Check false 2.4.0 …","date":-62135596800,"description":"","dir":"projects/moss/health-check/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e790182983eafeb12ede99886af893a9","permalink":"/projects/moss/health-check/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/health-check/","summary":"SOFABoot 为 Spring Boot 的健康检查能力增加了 Readiness Check 的能力。如果你需要使用 SOFA 中间件，那么建议使用 SOFABoot 的健康检查能力的扩展，来更优雅的上线应用实例 引入健康检查扩展 要","tags":null,"title":"健康检查","type":"projects","url":"/projects/moss/health-check/","wordcount":1269},{"author":null,"categories":null,"content":" SOFABoot 为 Spring Boot 的健康检查能力增加了 Readiness Check 的能力。如果你需要使用 SOFA 中间件，那么建议使用 SOFABoot 的健康检查能力的扩展，来更优雅的上线应用实例\n引入健康检查扩展 要引入 SOFABoot 的健康检查能力的扩展，只需要引入以下的 Starter 即可：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;healthcheck-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  如果不引入 SOFABoot 的健康检查扩展，用户依然可以直接依赖 HealthIndicator 接口进行原生的 Spring Boot Actuator 的 Liveness Check。\n安全提醒 从 SOFABoot 2.3.0 开始，由于健康检查能力依赖于 SpringBoot 1.4.x 里的 Actuator 组件，而 Actuator 会默认开启很多 EndPoint，例如 /dump，/trace 等等，可能存在安全风险，可以参照官方文档里的安全建议进行设置。\n SpringBoot 1.5.x 和 SpringBoot 2.x 已修复了部分安全行为，SOFABoot 将通过升级 SpringBoot 内核进行支持。\n 查看健康检查结果 加入健康检查扩展之后，我们可以直接在浏览器中输入 http://localhost:8080/health/readiness 来查看 Readiness Check 的结果。如果要查看 Liveness Check 的结果，可以直接查看 Spring Boot 的健康检查的 URL http://localhost:8080/health。\n除了通过 URL 来查看健康检查的结果之外，在 SOFABoot 中，还可以通过查看具体的日志来确定健康检查的结果，日志的目录位于 health-check 目录下，日志的内容大概如下：\n2018-04-06 23:29:50,240 INFO main - Readiness check result: success  目前 SOFA 中间件已经通过 SOFABoot 的 Readiness Check 的能力来控制了上游流量的进入，但是一个应用的流量可能并不是全部都是从中间件进入的，比较常见的还有从负载均衡器进入的，为了控制从负载均衡器进入的流量，建议使用者通过 PAAS 来访问 Readiness Check 的结果，根据结果来控制是否要在负载均衡器中上线对应的节点。\n注: 自 SOFABoot 2.x 之后，不再间接引入 spring-boot-starter-web 依赖，如果需要在浏览器中查看健康检查结果，需要额外在工程中引入 web 容器依赖。\n注: 在 SOFABoot 3.x 中调整了 endpoint 路径，health/readiness 更改为 actuator/readiness\n扩展 Readiness Check 能力 在 Readiness Check 的各个阶段，SOFABoot 都提供了扩展的能力，应用可以根据自己的需要进行扩展，在 2.x 版本中，可供扩展的点如下：\n   回调接口 说明     org.springframework.context.ApplicationListener 如果想要在 Readiness Check 之前做一些事情，那么监听这个 Listener 的 SofaBootBeforeHealthCheckEvent 事件。   org.springframework.boot.actuate.health.HealthIndicator 如果想要在 SOFABoot 的 Readiness Check 里面增加一个检查项，那么可以直接扩展 Spring Boot 的这个接口。   com.alipay.sofa.healthcheck.startup.SofaBootAfterReadinessCheckCallback 如果想要在 Readiness Check 之后做一些事情，那么可以扩展 SOFABoot 的这个接口。    在 3.x 版本中，可供扩展点如下：\n   回调接口 说明     com.alipay.sofa.healthcheck.core.HealthChecker 如果想要在 SOFABoot 的 Readiness Check 里面增加一个检查项，可以直接扩展该接口。相较于 Spring Boot 本身的 HealthIndicator 接口，该接口提供了一些额外的参数配置，比如检查失败重试次数等。   org.springframework.boot.actuate.health.HealthIndicator 如果想要在 SOFABoot 的 Readiness Check 里面增加一个检查项，那么可以直接扩展 Spring Boot 的这个接口。   org.springframework.boot.actuate.health.ReactiveHealthIndicator 在 WebFlux 中，如果想要在 SOFABoot 的 Readiness Check 里面增加一个检查项，那么可以直接扩展 Spring Boot 的这个接口。   com.alipay.sofa.healthcheck.startup.ReadinessCheckCallback 如果想要在 Readiness Check 之后做一些事情，那么可以扩展 SOFABoot 的这个接口。    需要指出的是，上述四个扩展接口均可以通过 Spring Boot 标准的 Ordered, PriorityOrdered 和注解 @Order 实现执行顺序的设置。\nReadiness Check 配置项 应用在引入 SOFABoot 的健康检查扩展之后，可以在 Spring Boot 的配置文件 application.properties 中添加相关配置项来定制 Readiness Check 的相关行为。\n   Readiness Check 配置项 说明 默认值 开始支持版本     com.alipay.sofa.healthcheck.skip.all 是否跳过整个 Readiness Check 阶段 false 2.4.0   com.alipay.sofa.healthcheck.skip.component 是否跳过 SOFA 中间件的 Readiness Check false 2.4.0   com.alipay.sofa.healthcheck.skip.indicator 是否跳过 HealthIndicator 的 Readiness Check false 2.4.0 …","date":-62135596800,"description":"","dir":"projects/sofa-boot/health-check/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a366b25125fa4aedb08a9cef572db1c8","permalink":"/projects/sofa-boot/health-check/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/health-check/","summary":"SOFABoot 为 Spring Boot 的健康检查能力增加了 Readiness Check 的能力。如果你需要使用 SOFA 中间件，那么建议使用 SOFABoot 的健康检查能力的扩展，来更优雅的上线应用实例 引入健康检查扩展 要","tags":null,"title":"健康检查","type":"projects","url":"/projects/sofa-boot/health-check/","wordcount":1269},{"author":null,"categories":null,"content":"  可以先去 发展路线 内了解下开发任务及未来规划。\n 准备工作 贡献代码前需要先了解 git 工具的使用和 GitHub 网站的使用。\n git 工具用法可以查看 git官方书籍，需要阅读前几章来熟悉。 git 协作流程可以查看这篇文章 Git协作流程。  GitHub 贡献代码流程 提交issue 不论您是修复 SOFAArk 的 bug 还是新增 SOFAArk 的功能，在您提交代码之前，在 SOFAArk 的 GitHub 地址上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:\n 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作. SOFAArk 的维护人员会对您提的bug或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。 在达成一致后再开发,并提交代码，减少双方沟通成本，也减少pull request被拒绝的情况。  获取源码 要修改或新增功能，在提 issue 后，点击左上角的fork按钮，复制一份 SOFAArk 主干代码到您的代码仓库。\n拉分支 SOFAArk 所有修改都在分支上进行，修改完后提交 pull request， 在 Code Review 后由项目维护人员 Merge 到主干。\n因此，在获取源码步骤介绍后，您需要：\n 下载代码到本地,这一步您可以选择git/https方式.\ngit clone https://github.com/您的账号名/sofa-ark.git  拉分支准备修改代码\ngit branch add_xxx_feature   执行完上述命令后，您的代码仓库就切换到相应分支了。执行如下命令可以看到您当前分支：\n git branch -a  如果您想切换回主干，执行下面命令:\n git checkout -b master  如果您想切换回分支，执行下面命令：\n git checkout -b \u0026amp;quot;branchName\u0026amp;quot;  修改代码提交到本地 拉完分支后，就可以修改代码了。\n修改代码注意事项  代码风格保持一致  SOFAArk 通过 Maven 插件来保持代码格式一致.在提交代码前,务必本地执行\nmvn clean compile   补充单元测试代码 新有修改应该通过已有的单元测试. 应该提供新的单元测试来证明以前的代码存在 bug，而新的代码已经解决了这些 bug  您可以用如下命令运行所有测试\n mvn clean test  也可以通过IDE来辅助运行。\n其它注意事项  请保持您编辑的代码的原有风格，尤其是空格换行等. 对于无用的注释，请直接删除 对逻辑和功能不容易被理解的地方添加注释。 及时更新文档  修改完代码后，执行如下命令提交所有修改到本地:\n git commit -am \u0026#39;添加xx功能\u0026#39;  提交代码到远程仓库 在代码提交到本地后，就是与远程仓库同步代码了。执行如下命令提交本地修改到 github 上：\ngit push origin \u0026amp;quot;branchname\u0026amp;quot;  如果前面您是通过 fork 来做的,那么这里的 origin 是 push 到您的代码仓库，而不是 SOFAArk 的代码仓库.\n提交合并代码到主干的请求 在的代码提交到 GitHub 后，您就可以发送请求来把您改好的代码合入 SOFAArk 主干代码了。此时您需要进入您的 GitHub 上的对应仓库，按右上角的 pull request按钮。选择目标分支,一般就是 master，系统会通知 SOFAArk 的人员， SOFAArk 人员会 Review 您的代码，符合要求后就会合入主干，成为 SOFAArk 的一部分。\n代码 Review 在您提交代码后，您的代码会被指派给维护人员 Review，请耐心等待。如果在数天后，仍然没有人对您的提交给予任何回复，可以在 PR 下面留言，并 @ 对应的人员.\n对于代码 Review 的意见会直接备注到到对应 PR 或者 Issue。如果觉得建议是合理的，也请您把这些建议更新到您的补丁中。\n合并代码到主干 在代码 Review 通过后，就由 SOFAArk 维护人员操作合入主干了。这一步不用参与，代码合并之后，您会收到合并成功的提示。\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-contribution/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9480760cd2dcefa78f191f036c47c0db","permalink":"/projects/moss/sofa-ark-contribution/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-contribution/","summary":"可以先去 发展路线 内了解下开发任务及未来规划。 准备工作 贡献代码前需要先了解 git 工具的使用和 GitHub 网站的使用。 git 工具用法可以查看 git官方书籍，需要阅","tags":null,"title":"参与贡献","type":"projects","url":"/projects/moss/sofa-ark-contribution/","wordcount":1278},{"author":null,"categories":null,"content":"  可以先去 发展路线 内了解下开发任务及未来规划。\n 准备工作 贡献代码前需要先了解 git 工具的使用和 GitHub 网站的使用。\n git 工具用法可以查看 git官方书籍，需要阅读前几章来熟悉。 git 协作流程可以查看这篇文章 Git协作流程。  GitHub 贡献代码流程 提交issue 不论您是修复 SOFAArk 的 bug 还是新增 SOFAArk 的功能，在您提交代码之前，在 SOFAArk 的 GitHub 地址上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:\n 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作. SOFAArk 的维护人员会对您提的bug或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。 在达成一致后再开发,并提交代码，减少双方沟通成本，也减少pull request被拒绝的情况。  获取源码 要修改或新增功能，在提 issue 后，点击左上角的fork按钮，复制一份 SOFAArk 主干代码到您的代码仓库。\n拉分支 SOFAArk 所有修改都在分支上进行，修改完后提交 pull request， 在 Code Review 后由项目维护人员 Merge 到主干。\n因此，在获取源码步骤介绍后，您需要：\n 下载代码到本地,这一步您可以选择git/https方式.\ngit clone https://github.com/您的账号名/sofa-ark.git  拉分支准备修改代码\ngit branch add_xxx_feature   执行完上述命令后，您的代码仓库就切换到相应分支了。执行如下命令可以看到您当前分支：\n git branch -a  如果您想切换回主干，执行下面命令:\n git checkout -b master  如果您想切换回分支，执行下面命令：\n git checkout -b \u0026amp;quot;branchName\u0026amp;quot;  修改代码提交到本地 拉完分支后，就可以修改代码了。\n修改代码注意事项  代码风格保持一致  SOFAArk 通过 Maven 插件来保持代码格式一致.在提交代码前,务必本地执行\nmvn clean compile   补充单元测试代码 新有修改应该通过已有的单元测试. 应该提供新的单元测试来证明以前的代码存在 bug，而新的代码已经解决了这些 bug  您可以用如下命令运行所有测试\n mvn clean test  也可以通过IDE来辅助运行。\n其它注意事项  请保持您编辑的代码的原有风格，尤其是空格换行等. 对于无用的注释，请直接删除 对逻辑和功能不容易被理解的地方添加注释。 及时更新文档  修改完代码后，执行如下命令提交所有修改到本地:\n git commit -am \u0026#39;添加xx功能\u0026#39;  提交代码到远程仓库 在代码提交到本地后，就是与远程仓库同步代码了。执行如下命令提交本地修改到 github 上：\ngit push origin \u0026amp;quot;branchname\u0026amp;quot;  如果前面您是通过 fork 来做的,那么这里的 origin 是 push 到您的代码仓库，而不是 SOFAArk 的代码仓库.\n提交合并代码到主干的请求 在的代码提交到 GitHub 后，您就可以发送请求来把您改好的代码合入 SOFAArk 主干代码了。此时您需要进入您的 GitHub 上的对应仓库，按右上角的 pull request按钮。选择目标分支,一般就是 master，系统会通知 SOFAArk 的人员， SOFAArk 人员会 Review 您的代码，符合要求后就会合入主干，成为 SOFAArk 的一部分。\n代码 Review 在您提交代码后，您的代码会被指派给维护人员 Review，请耐心等待。如果在数天后，仍然没有人对您的提交给予任何回复，可以在 PR 下面留言，并 @ 对应的人员.\n对于代码 Review 的意见会直接备注到到对应 PR 或者 Issue。如果觉得建议是合理的，也请您把这些建议更新到您的补丁中。\n合并代码到主干 在代码 Review 通过后，就由 SOFAArk 维护人员操作合入主干了。这一步不用参与，代码合并之后，您会收到合并成功的提示。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-contribution/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"dbf77f98884a71c5c7a3fbb4dd189cfe","permalink":"/projects/sofa-boot/sofa-ark-contribution/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-contribution/","summary":"可以先去 发展路线 内了解下开发任务及未来规划。 准备工作 贡献代码前需要先了解 git 工具的使用和 GitHub 网站的使用。 git 工具用法可以查看 git官方书籍，需要阅","tags":null,"title":"参与贡献","type":"projects","url":"/projects/sofa-boot/sofa-ark-contribution/","wordcount":1278},{"author":null,"categories":null,"content":" 任务列表 下面表格记录了还没有实现的功能特性，欢迎大家认领任务，参与贡献。\n   类型 任务 困难度 认领人及时间 计划完成时间 进度 相关 Issue     代码 支持多个 Web 应用合并部署，采用多 Host/单 Host 两种模式 难       代码 支持 telnet 指令查看 ark plugin 简单       代码 支持 telnet 指令查看 jvm/rpc 服务 中        版本迭代计划 v0.5.0  支持多个 Web 应用合并部署，采用多 Host/单 Host 两种模式  v0.6.0  支持 telnet 指令查看 ark plugin； 支持 telnet 指令查看 jvm/rpc 服务；  ","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-roadmap/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0322fbfee895536ee232bc90b473a855","permalink":"/projects/moss/sofa-ark-roadmap/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/moss/sofa-ark-roadmap/","summary":"任务列表 下面表格记录了还没有实现的功能特性，欢迎大家认领任务，参与贡献。 类型 任务 困难度 认领人及时间 计划完成时间 进度 相关 Issue 代码 支持多个 Web 应用合","tags":null,"title":"发展路线","type":"projects","url":"/projects/moss/sofa-ark-roadmap/","wordcount":175},{"author":null,"categories":null,"content":" 任务列表 下面表格记录了还没有实现的功能特性，欢迎大家认领任务，参与贡献。\n   类型 任务 困难度 认领人及时间 计划完成时间 进度 相关 Issue     代码 支持多个 Web 应用合并部署，采用多 Host/单 Host 两种模式 难       代码 支持 telnet 指令查看 ark plugin 简单       代码 支持 telnet 指令查看 jvm/rpc 服务 中        版本迭代计划 v0.5.0  支持多个 Web 应用合并部署，采用多 Host/单 Host 两种模式  v0.6.0  支持 telnet 指令查看 ark plugin； 支持 telnet 指令查看 jvm/rpc 服务；  ","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-roadmap/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c4532d11cef15d8fe3ff5e04c7b08f90","permalink":"/projects/sofa-boot/sofa-ark-roadmap/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-boot/sofa-ark-roadmap/","summary":"任务列表 下面表格记录了还没有实现的功能特性，欢迎大家认领任务，参与贡献。 类型 任务 困难度 认领人及时间 计划完成时间 进度 相关 Issue 代码 支持多个 Web 应用合","tags":null,"title":"发展路线","type":"projects","url":"/projects/sofa-boot/sofa-ark-roadmap/","wordcount":175},{"author":null,"categories":null,"content":"更多参见：https://github.com/sofastack/sofa-ark/releases\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-release/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8b3dab9c3e6ea51dce19682a5fbba161","permalink":"/projects/moss/sofa-ark-release/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/moss/sofa-ark-release/","summary":"更多参见：https://github.com/sofastack/sofa-ark/releases","tags":null,"title":"发布说明","type":"projects","url":"/projects/moss/sofa-ark-release/","wordcount":51},{"author":null,"categories":null,"content":"更多参见：https://github.com/sofastack/sofa-ark/releases\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-release/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"994c3569ea416ee5b0dea253f08af6be","permalink":"/projects/sofa-boot/sofa-ark-release/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-boot/sofa-ark-release/","summary":"更多参见：https://github.com/sofastack/sofa-ark/releases","tags":null,"title":"发布说明","type":"projects","url":"/projects/sofa-boot/sofa-ark-release/","wordcount":51},{"author":null,"categories":null,"content":" SOFABoot 提供了模块并行加载以及 Spring Bean 异步初始化能力，用于加快应用启动速度。模块并行加载参考相应文档，下面介绍如何使用 SOFABoot 异步初始化 Spring Bean 能力来提高应用启动速度。\n引入依赖 SOFABoot 在 v2.6.0 开始提供异步初始化 Spring Bean 能力，引入如下 Starter 即可：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;runtime-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  使用场景 在实际使用 Spring/Spring Boot 开发中，会有一些 Bean 在初始化过程中执行准备操作，如拉取远程配置、初始化数据源等等；在应用启动期间，这类 Bean 会增加 Spring 上下文刷新时间，导致应用启动耗时变长。为了加速应用启动，SOFABoot 通过配置可选项，将 Bean 的初始化方法(init-method) 使用单独线程异步执行，加快 Spring 上下文加载过程，提高应用启动速度。\n使用方法 异步初始化 Bean 的原理是开启单独线程负责执行 Bean 的初始化方法(init-method)，因此在使用过程中，除了引入上述依赖管理，还需要在 Bean 的 xml 定义中配置 async-init=\u0026amp;quot;true\u0026amp;quot; 属性，用于指定是否异步执行该 Bean 的初始化方法，例如：\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;beans xmlns=\u0026amp;quot;http://www.springframework.org/schema/beans\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xmlns:sofa=\u0026amp;quot;http://sofastack.io/schema/sofaboot\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://sofastack.io/schema/sofaboot http://sofastack.io/schema/sofaboot.xsd\u0026amp;quot; default-autowire=\u0026amp;quot;byName\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;!-- async init test --\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;testBean\u0026amp;quot; class=\u0026amp;quot;com.alipay.sofa.runtime.beans.TimeWasteBean\u0026amp;quot; init-method=\u0026amp;quot;init\u0026amp;quot; async-init=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/beans\u0026amp;gt;  配置 SOFABoot 异步初始化能力提供两个属性配置，用于指定负责异步执行 Bean 初始化方法(init-method)的线程池大小： + com.alipay.sofa.boot.asyncInitBeanCoreSize \u0026amp;gt; 线程池基本大小，默认值为 CPU 核数加一 + com.alipay.sofa.boot.asyncInitBeanMaxSize \u0026amp;gt; 线程池中允许的最大线程数大小，默认值为 CPU 核数加一\n配置可以通过 VM -D 参数或者 Spring Boot 配置文件 application.yml 设置。\n","date":-62135596800,"description":"","dir":"projects/moss/speed-up-startup/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"679f114c27eeebdb457c081a1f724f17","permalink":"/projects/moss/speed-up-startup/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/moss/speed-up-startup/","summary":"SOFABoot 提供了模块并行加载以及 Spring Bean 异步初始化能力，用于加快应用启动速度。模块并行加载参考相应文档，下面介绍如何使用 SOFABoot 异步初始化 Spring Bean 能力来提高应用启","tags":null,"title":"启动加速","type":"projects","url":"/projects/moss/speed-up-startup/","wordcount":519},{"author":null,"categories":null,"content":" SOFABoot 提供了模块并行加载以及 Spring Bean 异步初始化能力，用于加快应用启动速度。模块并行加载参考相应文档，下面介绍如何使用 SOFABoot 异步初始化 Spring Bean 能力来提高应用启动速度。\n引入依赖 SOFABoot 在 v2.6.0 开始提供异步初始化 Spring Bean 能力，引入如下 Starter 即可：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;runtime-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  使用场景 在实际使用 Spring/Spring Boot 开发中，会有一些 Bean 在初始化过程中执行准备操作，如拉取远程配置、初始化数据源等等；在应用启动期间，这类 Bean 会增加 Spring 上下文刷新时间，导致应用启动耗时变长。为了加速应用启动，SOFABoot 通过配置可选项，将 Bean 的初始化方法(init-method) 使用单独线程异步执行，加快 Spring 上下文加载过程，提高应用启动速度。\n使用方法 异步初始化 Bean 的原理是开启单独线程负责执行 Bean 的初始化方法(init-method)，因此在使用过程中，除了引入上述依赖管理，还需要在 Bean 的 xml 定义中配置 async-init=\u0026amp;quot;true\u0026amp;quot; 属性，用于指定是否异步执行该 Bean 的初始化方法，例如：\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;beans xmlns=\u0026amp;quot;http://www.springframework.org/schema/beans\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xmlns:sofa=\u0026amp;quot;http://sofastack.io/schema/sofaboot\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://sofastack.io/schema/sofaboot http://sofastack.io/schema/sofaboot.xsd\u0026amp;quot; default-autowire=\u0026amp;quot;byName\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;!-- async init test --\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;testBean\u0026amp;quot; class=\u0026amp;quot;com.alipay.sofa.runtime.beans.TimeWasteBean\u0026amp;quot; init-method=\u0026amp;quot;init\u0026amp;quot; async-init=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/beans\u0026amp;gt;  配置 SOFABoot 异步初始化能力提供两个属性配置，用于指定负责异步执行 Bean 初始化方法(init-method)的线程池大小： + com.alipay.sofa.boot.asyncInitBeanCoreSize \u0026amp;gt; 线程池基本大小，默认值为 CPU 核数加一 + com.alipay.sofa.boot.asyncInitBeanMaxSize \u0026amp;gt; 线程池中允许的最大线程数大小，默认值为 CPU 核数加一\n配置可以通过 VM -D 参数或者 Spring Boot 配置文件 application.yml 设置。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/speed-up-startup/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ebd933894c7828948b87610d1d0ca020","permalink":"/projects/sofa-boot/speed-up-startup/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/sofa-boot/speed-up-startup/","summary":"SOFABoot 提供了模块并行加载以及 Spring Bean 异步初始化能力，用于加快应用启动速度。模块并行加载参考相应文档，下面介绍如何使用 SOFABoot 异步初始化 Spring Bean 能力来提高应用启","tags":null,"title":"启动加速","type":"projects","url":"/projects/sofa-boot/speed-up-startup/","wordcount":519},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"使用该指南您可以体验到快速创建 Serveless 应用、根据业务请求秒级 0-1-N 自动伸缩、通过日志查看器快速排错、按时间触发应用等产品新功能。","dir":"guides/kc-serverless-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f355d1b598fed47b730bd74ad25f3683","permalink":"/guides/kc-serverless-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-serverless-demo/","summary":"","tags":null,"title":"基于 Serverless 轻松构建云上应用","type":"guides","url":"/guides/kc-serverless-demo/","wordcount":0},{"author":null,"categories":null,"content":" Ark 包 SOFAArk 定义特殊格式的可执行 Jar 包，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将工程应用打包成一个标准格式的 Ark 包；使用命令 java -jar 即可在 SOFAArk 容器之上启动应用；Ark 包 通常包含 Ark Container 、Ark Plugin 依赖（如果有）、合并部署的 Ark Biz （如果有）以及应用自身的 Ark Biz；详情可参考 Ark 包；\nArk Container Ark 容器，Ark Plugin 和 Ark Biz 运行在 SOFAArk 容器之上；容器具备管理多插件、多应用的功能；容器启动成功后，会解析 Ark Plugin 和 Ark Biz 配置，完成隔离加载并按优先级依次启动之；Ark Container 一般不会被用户直接感知，由打包插件 sofa-ark-maven-plugin 自动打入。详情可参考 SOFAArk 容器启动；\nArk Plugin Ark 插件，SOFAArk 定义特殊格式的 Fat Jar，使用官方提供的 Maven 插件 sofa-ark-plugin-maven-plugin 可以将一个或多个普通的 Java Jar 包打包成一个标准格式的 Ark Plugin； Ark Plugin 会包含一份配置文件，通常包括插件类和资源的导入导出配置、插件启动优先级等；运行时，Ark 容器会使用独立的 PluginClassLoader 加载插件，并根据插件配置构建类加载索引表，从而使插件与插件、插件与应用之间相互隔离；详情可参考 Ark Plugin；\nArk Biz Ark 模块，SOFAArk 定义特殊格式的 Fat Jar ，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将工程应用打包成一个标准格式的 Ark Biz 包；作用有二点，一、在 Ark 包 中，作为工程应用模块及其依赖包的组织单元；二、可以被其他应用当成普通 Jar 包依赖，用于在同一个 SOFAArk 容器启动多个 Ark Biz；多个 Ark Biz 共享 Ark Container 和 Ark Plugin ；详情可参考 Ark Biz；\n合并部署 SOFAArk 允许将多个应用（Biz 包）合并打入到 Ark 包中，当启动 Ark 包时，会启动所有应用；也支持在运行时通过 API 或者配置中心（例如 Zookeeper）动态的部署和卸载应用，这些应用同时运行在同一个 JVM 中，由独立的 BizClassLoader 加载，各应用之间通过 SofaService/SofaReference 实现交互，称之为多应用的合并部署。\n宿主应用 宿主应用是相对合并部署而言，在打包 Ark 包时，至少有一个 Biz 包被打入，如果应用引入了其他 Biz 包，则 Ark 包中会存在多个 Biz 包。当只有一个 Biz 包时，默认将其设置为宿主应用；如果存在多个 Biz 包，则需要配置指定宿主应用。宿主应用相对其他 Biz 包最大的不同，即不允许被卸载。\n简单总结下，在 SOFAArk 框架中，应用(配置、源码、依赖)被打包成 Biz 包组织在一起，但是特殊的依赖（Ark Plugin 和其他应用 Biz 包）不会被打入 Biz 包中，Biz 包是不可执行的 Fat Jar; Ark Plugin 是特殊的二方包，可以将多个二方依赖打包成 Plugin，运行时由独立的 PluginClassLoader 加载，根据打包时配置的导出导入资源、类，构建运行时类加载模型；Ark 包是可执行 Fat Jar，一般由 Ark Container、Ark Plugin(0个或多个)、Ark Biz(至少一个)。\n","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-terminology/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f4744a1c9c06be01105c3879176b9a02","permalink":"/projects/moss/sofa-ark-terminology/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-terminology/","summary":"Ark 包 SOFAArk 定义特殊格式的可执行 Jar 包，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将工程应用打包成一个标准格式的 Ark 包；使用命令 java -jar 即可在 SOFAArk 容器之上启动应用；Ark 包","tags":null,"title":"基础术语","type":"projects","url":"/projects/moss/sofa-ark-terminology/","wordcount":1015},{"author":null,"categories":null,"content":" Ark 包 SOFAArk 定义特殊格式的可执行 Jar 包，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将工程应用打包成一个标准格式的 Ark 包；使用命令 java -jar 即可在 SOFAArk 容器之上启动应用；Ark 包 通常包含 Ark Container 、Ark Plugin 依赖（如果有）、合并部署的 Ark Biz （如果有）以及应用自身的 Ark Biz；详情可参考 Ark 包；\nArk Container Ark 容器，Ark Plugin 和 Ark Biz 运行在 SOFAArk 容器之上；容器具备管理多插件、多应用的功能；容器启动成功后，会解析 Ark Plugin 和 Ark Biz 配置，完成隔离加载并按优先级依次启动之；Ark Container 一般不会被用户直接感知，由打包插件 sofa-ark-maven-plugin 自动打入。详情可参考 SOFAArk 容器启动；\nArk Plugin Ark 插件，SOFAArk 定义特殊格式的 Fat Jar，使用官方提供的 Maven 插件 sofa-ark-plugin-maven-plugin 可以将一个或多个普通的 Java Jar 包打包成一个标准格式的 Ark Plugin； Ark Plugin 会包含一份配置文件，通常包括插件类和资源的导入导出配置、插件启动优先级等；运行时，Ark 容器会使用独立的 PluginClassLoader 加载插件，并根据插件配置构建类加载索引表，从而使插件与插件、插件与应用之间相互隔离；详情可参考 Ark Plugin；\nArk Biz Ark 模块，SOFAArk 定义特殊格式的 Fat Jar ，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将工程应用打包成一个标准格式的 Ark Biz 包；作用有二点，一、在 Ark 包 中，作为工程应用模块及其依赖包的组织单元；二、可以被其他应用当成普通 Jar 包依赖，用于在同一个 SOFAArk 容器启动多个 Ark Biz；多个 Ark Biz 共享 Ark Container 和 Ark Plugin ；详情可参考 Ark Biz；\n合并部署 SOFAArk 允许将多个应用（Biz 包）合并打入到 Ark 包中，当启动 Ark 包时，会启动所有应用；也支持在运行时通过 API 或者配置中心（例如 Zookeeper）动态的部署和卸载应用，这些应用同时运行在同一个 JVM 中，由独立的 BizClassLoader 加载，各应用之间通过 SofaService/SofaReference 实现交互，称之为多应用的合并部署。\n宿主应用 宿主应用是相对合并部署而言，在打包 Ark 包时，至少有一个 Biz 包被打入，如果应用引入了其他 Biz 包，则 Ark 包中会存在多个 Biz 包。当只有一个 Biz 包时，默认将其设置为宿主应用；如果存在多个 Biz 包，则需要配置指定宿主应用。宿主应用相对其他 Biz 包最大的不同，即不允许被卸载。\n简单总结下，在 SOFAArk 框架中，应用(配置、源码、依赖)被打包成 Biz 包组织在一起，但是特殊的依赖（Ark Plugin 和其他应用 Biz 包）不会被打入 Biz 包中，Biz 包是不可执行的 Fat Jar; Ark Plugin 是特殊的二方包，可以将多个二方依赖打包成 Plugin，运行时由独立的 PluginClassLoader 加载，根据打包时配置的导出导入资源、类，构建运行时类加载模型；Ark 包是可执行 Fat Jar，一般由 Ark Container、Ark Plugin(0个或多个)、Ark Biz(至少一个)。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-terminology/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b6d0ed10afe9d04bc00307017ffba7c5","permalink":"/projects/sofa-boot/sofa-ark-terminology/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-terminology/","summary":"Ark 包 SOFAArk 定义特殊格式的可执行 Jar 包，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将工程应用打包成一个标准格式的 Ark 包；使用命令 java -jar 即可在 SOFAArk 容器之上启动应用；Ark 包","tags":null,"title":"基础术语","type":"projects","url":"/projects/sofa-boot/sofa-ark-terminology/","wordcount":1015},{"author":null,"categories":null,"content":"  工程地址\n 简介 该样例工程演示了如何借助 maven 插件将一个普通的 Java 工程打包成标准格式规范的 Ark Plugin\n背景 现实开发中，常常会遇到依赖包冲突的情况；假设我们开发了一个类库 sample-lib , 业务应用在引入使用时，可能存在跟已有的依赖发生冲突的情况；通常这个时候，我们会希望自己的类库能够和业务其他依赖进行隔离，互不协商双方依赖包版本。 Ark Plugin 正是基于这种需求背景下的实践产物； Ark Plugin 运行在 Ark Container 之上，由容器负责加载启动，任何一个 Ark Plugin 由独立的 ClassLoader 加载，从而做到相互隔离。Ark Plugin 存在四个概念： * 导入类：插件启动时，优先委托给导出该类的插件负责加载，如果加载不到，才会尝试从本插件内部加载；\n 导出类：其他插件如果导入了该类，优先从本插件加载；\n 导入资源：插件在查找资源时，优先委托给导出该资源的插件负责加载，如果加载不到，才会尝试从本插件内部加载；\n 导出资源：其他插件如果导入了该资源，优先从本插件加载；\n   详细请参考插件规范\n 工具 官方提供了 Maven 插件 - sofa-ark-plugin-maven-plugin ，只需要简单的配置项，即可将普通的 Java 工程打包成标准格式规范的 Ark Plugin ，插件坐标为:\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;   详细请参考插件配置文档\n 入门 基于该用例工程，我们一步步描述如何构建一个 Ark Plugin\n创建标准 Maven 工程 该用例工程是一个标准的 Maven 工程，一共包含两个模块： * common 模块：包含了插件导出类\n plugin 模块：包含了 com.alipay.sofa.ark.spi.service.PluginActivator 接口实现类和一个插件服务类，插件打包工具 sofa-ark-plugin-maven-plugin 即配置在该模块的 pom.xml 中；  配置打包插件 在 plugin 模块的 pom.xml 中按如下配置打包插件：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;ark-plugin\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--can only configure no more than one activator--\u0026amp;gt; \u0026amp;lt;activator\u0026amp;gt;com.alipay.sofa.ark.sample.activator.SamplePluginActivator\u0026amp;lt;/activator\u0026amp;gt; \u0026amp;lt;!-- configure exported class --\u0026amp;gt; \u0026amp;lt;exported\u0026amp;gt; \u0026amp;lt;!-- configure package-level exported class--\u0026amp;gt; \u0026amp;lt;packages\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;com.alipay.sofa.ark.sample.common\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;/packages\u0026amp;gt; \u0026amp;lt;!-- configure class-level exported class --\u0026amp;gt; \u0026amp;lt;classes\u0026amp;gt; \u0026amp;lt;class\u0026amp;gt;com.alipay.sofa.ark.sample.facade.SamplePluginService\u0026amp;lt;/class\u0026amp;gt; \u0026amp;lt;/classes\u0026amp;gt; \u0026amp;lt;/exported\u0026amp;gt; \u0026amp;lt;!--specify destination where ark-plugin will be saved, default saved to ${project.build.directory}--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;../target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/execution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  在用例工程中，我们只配置了一部分配置项，这已经足够生成一个可用的 Ark Plugin，各配置项含义如下： * activator: Ark 容器启动插件的入口类，最多只能配置一个；通常来说，在插件的 activator 会执行一些初始化操作，比如发布插件服务；在本样例工程中，即发布了插件服务。\n 导出包：包级别的导出类配置，插件中所有以导出包名为前缀的类，包括插件的三方依赖包，都会被导出；\n 导出类：精确类名的导出类配置，导出具体的类；\n outputDirectory： mvn package 打包后，输出的 ark plugin 文件存放目录；\n  需要指出的是，在用例工程中，我们只导出了工程创建的类；实际在使用时，也可以把工程依赖的三方包也导出去。\n打包、安装、发布、引入 和普通的工程操作类似，使用 mvn package , mvn install , mvn deploy 即可完成插件包的安装和发布；需要注意的是，默认发布的 Ark Plugin 其 Maven 坐标会增加 classifier=ark-plugin ；例如在该样例工程中，如果需要使用该 ark plugin，必须如下配置依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sample-ark-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;classifier\u0026amp;gt;ark-plugin\u0026amp;lt;/classifier\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-plugin-demo/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7afcb688938e3868c29d39f719a2e3e1","permalink":"/projects/moss/sofa-ark-ark-plugin-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-ark-plugin-demo/","summary":"工程地址 简介 该样例工程演示了如何借助 maven 插件将一个普通的 Java 工程打包成标准格式规范的 Ark Plugin 背景 现实开发中，常常会遇到依赖包冲突的情况；假设我们开发","tags":null,"title":"如何打包 Ark Plugin","type":"projects","url":"/projects/moss/sofa-ark-ark-plugin-demo/","wordcount":1176},{"author":null,"categories":null,"content":"  工程地址\n 简介 该样例工程演示了如何借助 maven 插件将一个普通的 Java 工程打包成标准格式规范的 Ark Plugin\n背景 现实开发中，常常会遇到依赖包冲突的情况；假设我们开发了一个类库 sample-lib , 业务应用在引入使用时，可能存在跟已有的依赖发生冲突的情况；通常这个时候，我们会希望自己的类库能够和业务其他依赖进行隔离，互不协商双方依赖包版本。 Ark Plugin 正是基于这种需求背景下的实践产物； Ark Plugin 运行在 Ark Container 之上，由容器负责加载启动，任何一个 Ark Plugin 由独立的 ClassLoader 加载，从而做到相互隔离。Ark Plugin 存在四个概念： * 导入类：插件启动时，优先委托给导出该类的插件负责加载，如果加载不到，才会尝试从本插件内部加载；\n 导出类：其他插件如果导入了该类，优先从本插件加载；\n 导入资源：插件在查找资源时，优先委托给导出该资源的插件负责加载，如果加载不到，才会尝试从本插件内部加载；\n 导出资源：其他插件如果导入了该资源，优先从本插件加载；\n   详细请参考插件规范\n 工具 官方提供了 Maven 插件 - sofa-ark-plugin-maven-plugin ，只需要简单的配置项，即可将普通的 Java 工程打包成标准格式规范的 Ark Plugin ，插件坐标为:\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;   详细请参考插件配置文档\n 入门 基于该用例工程，我们一步步描述如何构建一个 Ark Plugin\n创建标准 Maven 工程 该用例工程是一个标准的 Maven 工程，一共包含两个模块： * common 模块：包含了插件导出类\n plugin 模块：包含了 com.alipay.sofa.ark.spi.service.PluginActivator 接口实现类和一个插件服务类，插件打包工具 sofa-ark-plugin-maven-plugin 即配置在该模块的 pom.xml 中；  配置打包插件 在 plugin 模块的 pom.xml 中按如下配置打包插件：\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-plugin-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;ark-plugin\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--can only configure no more than one activator--\u0026amp;gt; \u0026amp;lt;activator\u0026amp;gt;com.alipay.sofa.ark.sample.activator.SamplePluginActivator\u0026amp;lt;/activator\u0026amp;gt; \u0026amp;lt;!-- configure exported class --\u0026amp;gt; \u0026amp;lt;exported\u0026amp;gt; \u0026amp;lt;!-- configure package-level exported class--\u0026amp;gt; \u0026amp;lt;packages\u0026amp;gt; \u0026amp;lt;package\u0026amp;gt;com.alipay.sofa.ark.sample.common\u0026amp;lt;/package\u0026amp;gt; \u0026amp;lt;/packages\u0026amp;gt; \u0026amp;lt;!-- configure class-level exported class --\u0026amp;gt; \u0026amp;lt;classes\u0026amp;gt; \u0026amp;lt;class\u0026amp;gt;com.alipay.sofa.ark.sample.facade.SamplePluginService\u0026amp;lt;/class\u0026amp;gt; \u0026amp;lt;/classes\u0026amp;gt; \u0026amp;lt;/exported\u0026amp;gt; \u0026amp;lt;!--specify destination where ark-plugin will be saved, default saved to ${project.build.directory}--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;../target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/execution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  在用例工程中，我们只配置了一部分配置项，这已经足够生成一个可用的 Ark Plugin，各配置项含义如下： * activator: Ark 容器启动插件的入口类，最多只能配置一个；通常来说，在插件的 activator 会执行一些初始化操作，比如发布插件服务；在本样例工程中，即发布了插件服务。\n 导出包：包级别的导出类配置，插件中所有以导出包名为前缀的类，包括插件的三方依赖包，都会被导出；\n 导出类：精确类名的导出类配置，导出具体的类；\n outputDirectory： mvn package 打包后，输出的 ark plugin 文件存放目录；\n  需要指出的是，在用例工程中，我们只导出了工程创建的类；实际在使用时，也可以把工程依赖的三方包也导出去。\n打包、安装、发布、引入 和普通的工程操作类似，使用 mvn package , mvn install , mvn deploy 即可完成插件包的安装和发布；需要注意的是，默认发布的 Ark Plugin 其 Maven 坐标会增加 classifier=ark-plugin ；例如在该样例工程中，如果需要使用该 ark plugin，必须如下配置依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sample-ark-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;classifier\u0026amp;gt;ark-plugin\u0026amp;lt;/classifier\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-plugin-demo/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d8125843ced13352dd228299f222c74d","permalink":"/projects/sofa-boot/sofa-ark-ark-plugin-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-plugin-demo/","summary":"工程地址 简介 该样例工程演示了如何借助 maven 插件将一个普通的 Java 工程打包成标准格式规范的 Ark Plugin 背景 现实开发中，常常会遇到依赖包冲突的情况；假设我们开发","tags":null,"title":"如何打包 Ark Plugin","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-plugin-demo/","wordcount":1176},{"author":null,"categories":null,"content":"  工程地址\n 简介 该样例工程演示了如何借助 Maven 插件将一个 Spring Boot Web 工程打包成标准格式规范的可执行 Ark 包；\n准备 因该样例工程依赖 sample-ark-plugin , 因此需要提前在本地安装该 Ark Plugin\n工具 官方提供了 Maven 插件 - sofa-ark-maven-plugin ，只需要简单的配置项，即可将 Spring Boot Web 工程打包成标准格式规范的可执行 Ark 包，插件坐标为：\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;   详细请参考插件使用文档\n 入门 基于该样例工程，我们一步步描述如何将一个 Spring Boot Web 工程打包成可运行 Ark 包\n创建 SpringBoot Web 工程 在官网 https://start.spring.io/ 下载一个标准的 Spring Boot Web 工程\n引入 sample-ark-plugin 在工程主 pom.xml 中如下配置，添加另一个样例工程打包生成的 Ark Plugin 依赖，参考文档\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sample-ark-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;classifier\u0026amp;gt;ark-plugin\u0026amp;lt;/classifier\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  配置打包插件 在工程主 pom.xml 中如下配置 Maven 插件 sofa-ark-maven-plugin :\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;!--goal executed to generate executable-ark-jar --\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--specify destination where executable-ark-jar will be saved, default saved to ${project.build.directory}--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;./target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!--default none--\u0026amp;gt; \u0026amp;lt;arkClassifier\u0026amp;gt;executable-ark\u0026amp;lt;/arkClassifier\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/execution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  在该样例工程中，我们只配置了一部分配置项，这已经足够生成一个可用的可执行 Ark 包，各配置项含义如下： * outputDirectory: mvn package 打包后，输出的 Ark 包文件存放目录；\n arkClassifier: 指定发布的 Ark 包其 Maven 坐标包含的 classifier 值，默认为空；  关于 arkClassifier 配置项需要特别注意下，默认值为空；如果不指定 classifier ，上传到仓库的 Jar 包其实是一个可运行的 Ark 包；如果需要和普通的打包加以区分，需要配置该项值。\n打包、安装、发布 和普通的工程操作类似，使用 mvn package , mvn install , mvn deploy 即可完成插件包的安装和发布；\n运行 我们提供了两种方式在 Ark 容器上启动工程应用，通过命令行启动或者在 IDE 启动；在 IDE 启动时，需要额外添加依赖；使用命令行启动非常简便，直接使用 java -jar 即可启动应用；下面我们说下如何在 IDE 启动 Ark 应用；\n Spring Boot 工程：Spring Boot 工程需要添加如下依赖即可：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-springboot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   普通 Java 工程： 相较于 SpringBoot 工程，普通的 Java 工程需要添加另一个依赖：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-support-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  除此之外，还需要在工程 main 方法最开始处，执行容器启动，如下：\npublic class Application{ public static void main(String[] args) { SofaArkBootstrap.launch(args); ... } }  运行测试用例 SOFAArk 提供了 org.junit.runner.Runner 的两个实现类，ArkJUnit4Runner 和 ArkBootRunner，分别用于集成 JUnit4 测试框架和 Spring Test；对于 TestNG 测试框架，提供了注解 @TestNGOnArk，对于任何 TestNG 测试用例，只有打有 @TestNGOnArk 的测试用例才会跑在 Ark Container 之上，否 …","date":-62135596800,"description":"","dir":"projects/moss/sofa-ark-ark-demo/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8cdf1579968e7ac4e79832a861b0413c","permalink":"/projects/moss/sofa-ark-ark-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofa-ark-ark-demo/","summary":"工程地址 简介 该样例工程演示了如何借助 Maven 插件将一个 Spring Boot Web 工程打包成标准格式规范的可执行 Ark 包； 准备 因该样例工程依赖 sample-ark-plugin , 因此需要提前在本地安装该 Ark","tags":null,"title":"如何打包 Ark 包","type":"projects","url":"/projects/moss/sofa-ark-ark-demo/","wordcount":1154},{"author":null,"categories":null,"content":"  工程地址\n 简介 该样例工程演示了如何借助 Maven 插件将一个 Spring Boot Web 工程打包成标准格式规范的可执行 Ark 包；\n准备 因该样例工程依赖 sample-ark-plugin , 因此需要提前在本地安装该 Ark Plugin\n工具 官方提供了 Maven 插件 - sofa-ark-maven-plugin ，只需要简单的配置项，即可将 Spring Boot Web 工程打包成标准格式规范的可执行 Ark 包，插件坐标为：\n\u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;   详细请参考插件使用文档\n 入门 基于该样例工程，我们一步步描述如何将一个 Spring Boot Web 工程打包成可运行 Ark 包\n创建 SpringBoot Web 工程 在官网 https://start.spring.io/ 下载一个标准的 Spring Boot Web 工程\n引入 sample-ark-plugin 在工程主 pom.xml 中如下配置，添加另一个样例工程打包生成的 Ark Plugin 依赖，参考文档\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sample-ark-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;classifier\u0026amp;gt;ark-plugin\u0026amp;lt;/classifier\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  配置打包插件 在工程主 pom.xml 中如下配置 Maven 插件 sofa-ark-maven-plugin :\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default-cli\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;!--goal executed to generate executable-ark-jar --\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--specify destination where executable-ark-jar will be saved, default saved to ${project.build.directory}--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;./target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!--default none--\u0026amp;gt; \u0026amp;lt;arkClassifier\u0026amp;gt;executable-ark\u0026amp;lt;/arkClassifier\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/execution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  在该样例工程中，我们只配置了一部分配置项，这已经足够生成一个可用的可执行 Ark 包，各配置项含义如下： * outputDirectory: mvn package 打包后，输出的 Ark 包文件存放目录；\n arkClassifier: 指定发布的 Ark 包其 Maven 坐标包含的 classifier 值，默认为空；  关于 arkClassifier 配置项需要特别注意下，默认值为空；如果不指定 classifier ，上传到仓库的 Jar 包其实是一个可运行的 Ark 包；如果需要和普通的打包加以区分，需要配置该项值。\n打包、安装、发布 和普通的工程操作类似，使用 mvn package , mvn install , mvn deploy 即可完成插件包的安装和发布；\n运行 我们提供了两种方式在 Ark 容器上启动工程应用，通过命令行启动或者在 IDE 启动；在 IDE 启动时，需要额外添加依赖；使用命令行启动非常简便，直接使用 java -jar 即可启动应用；下面我们说下如何在 IDE 启动 Ark 应用；\n Spring Boot 工程：Spring Boot 工程需要添加如下依赖即可：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-springboot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   普通 Java 工程： 相较于 SpringBoot 工程，普通的 Java 工程需要添加另一个依赖：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-support-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.ark.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  除此之外，还需要在工程 main 方法最开始处，执行容器启动，如下：\npublic class Application{ public static void main(String[] args) { SofaArkBootstrap.launch(args); ... } }  运行测试用例 SOFAArk 提供了 org.junit.runner.Runner 的两个实现类，ArkJUnit4Runner 和 ArkBootRunner，分别用于集成 JUnit4 测试框架和 Spring Test；对于 TestNG 测试框架，提供了注解 @TestNGOnArk，对于任何 TestNG 测试用例，只有打有 @TestNGOnArk 的测试用例才会跑在 Ark Container 之上，否 …","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofa-ark-ark-demo/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2c97c409788f41051c79836d277997be","permalink":"/projects/sofa-boot/sofa-ark-ark-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofa-ark-ark-demo/","summary":"工程地址 简介 该样例工程演示了如何借助 Maven 插件将一个 Spring Boot Web 工程打包成标准格式规范的可执行 Ark 包； 准备 因该样例工程依赖 sample-ark-plugin , 因此需要提前在本地安装该 Ark","tags":null,"title":"如何打包 Ark 包","type":"projects","url":"/projects/sofa-boot/sofa-ark-ark-demo/","wordcount":1154},{"author":null,"categories":null,"content":" Q: Readiness Check 有啥应用场景？ Liveness Check 和 Readiness Check 概念来自于 Kuberentes，分别代表运行时检查和启动时检查。Spring Boot 提供了 Liveness Check，但是没有提供 Readiness Check。利用 Readiness Check 的能力，SOFA 中间件中的各个组件只有在 Readiness Check 通过之后，才将流量引入到应用的实例中，比如 RPC，只有在 Readiness Check 通过之后，才会向服务注册中心注册，后面来自上游应用的流量才会进入。除了中间件可以利用 Readiness Check 的事件来控制流量，PAAS 系统也可以通过访问 http://localhost:8080/health/readiness 来获取应用的 Readiness Check 的状况，从而控制例如负载均衡设备等等的流量。\nQ: 是否可以在 SOFABoot 模块中定义 Controller 组件？ SOFABoot 模块一般用于封装对外发布服务接口的具体实现，属于业务层，Controller 属于展现层内容，我们不建议也不支持在 SOFABoot 模块中定义 Controller 组件，Controller 组件相关定义建议直接放在 Root Application Context。\nQ: 类隔离在蚂蚁内部使用是否广泛？ 类隔离在蚂蚁内部使用非常广泛，绝大部分业务应用都是运行在蚂蚁中间件自研的类隔离框架之上。主要是为了解决依赖冲突的问题，像蚂蚁金服这种体量的公司，业务线繁杂、基础服务组件众多，很难做到对所有 JAR 包做统一管控。特别涉及到跨团队模块组件相互依赖时，因为各自技术栈历史包袱的存在，难以有效统一冲突包版本。使用类隔离技术解决了实际开发中的很多痛点，业务开发者不需要担心自身依赖冲突的问题，在多团队协作开发中，也有很大的优势。\nQ: SOFABoot类隔离框架（SOFAArk）和 OSGI 容器有哪些差异？ 作为开源界早负盛名的动态模块系统，基于 OSGi 规范的 Equinox、Felix 等同样具备类隔离能力，然而他们更多强调的是一种编程模型，面向模块化开发，有一整套模块生命周期的管理，定义模块通信机制以及复杂的类加载模型。作为专注于解决依赖冲突的隔离框架，SOFAArk 专注于类隔离，简化了类加载模型，因此显得更加轻量。其次在 OSGi 规范中，所有的模块定义成 Bundle 形式，作为应用开发者，他需要了解 OSGi 背后的工作原理，对开发者要求比较高。在 SOFAArk 中，定义了两层模块类型，Ark Plugin 和 Ark Biz，应用开发者只需要添加隔离的 Ark Plugin 依赖，底层的类加载模型对应用开发者俩说是透明的，基本不会带来额外的学习成本。\nQ: SOFAArk 和 Java9 模块化有哪些差异？ Jigsaw 作为 Java9 模块化方案，抛开内部实现细节，在使用规范上和 OSGi 特别相似：模块的依赖、包导入导出、动态导出、可读性传递、模块服务注册与消费、开放模块、可选模块等等若干概念，相对于 SOFAArk 简单的包导入导出显然过于复杂。在实现细节上，考虑到 JDK 代码的兼容性，Jigsaw 没有采用类加载器隔离的方式，不同模块之间仍然可能是同一个类加载器加载。严格上来讲，Jigsaw 并没有解决同一个类多版本的问题，但是因为模块显示的依赖声明，使用纯 Jigsaw 模块化编程，不同版本类冲突的问题在编译期就能被检查或者启动失败，因为不允许不同模块含有相同类名的包。对于在实际开发中遇到的一类情况，例如两个组件依赖不同版本 hessian 包，即使这两个组件定义成了两个模块，运行时也只有一个hessian版本被加载，依然解决不了不同版本类共存的问题。另外，Jigsaw 相对 Ark 或者 OSGi 有一个明显的缺点，Jigsaw 不允许运行时动态发布模块服务，模块间的通信依赖在 module-info.java 中使用 provides 和 uses 静态注册和引用模块服务。当然，Jigsaw 有很多自己的优点，通过引入module-path，在 module 中显示声明模块依赖关系，避免了传统 maven/gradle 中因为间接依赖导致运行时加载类不确定的缺点；其次通过设置模块包的导入导出配置，可以完全做到接口和实现的分离，提升安全性；另外 Java9 本身借助模块化改造，使用jlink工具，开发者可以将自身应用必须的模块聚合，打包一个自定义的jre镜像。\nQ: 为什么使用 SNAPSHOT 版本拉取不到依赖？ 如果需要使用处于研发状态的 SNAPSHOT 版本，有两种方式：\n 拉取 sofa-ark 仓库代码，本地执行 mvn install。 在本地 maven setting.xml 文件增加如下 profile 配置:  \u0026amp;lt;profile\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;activation\u0026amp;gt; \u0026amp;lt;activeByDefault\u0026amp;gt;true\u0026amp;lt;/activeByDefault\u0026amp;gt; \u0026amp;lt;/activation\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;maven-snapshot\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://oss.sonatype.org/content/repositories/snapshots\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;/repositories\u0026amp;gt; \u0026amp;lt;pluginRepositories\u0026amp;gt; \u0026amp;lt;pluginRepository\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;maven-snapshot\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://oss.sonatype.org/content/repositories/snapshots\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;/pluginRepository\u0026amp;gt; \u0026amp;lt;/pluginRepositories\u0026amp;gt; \u0026amp;lt;/profile\u0026amp;gt;  Q: 为什么使用 java -jar 启动 Spring Boot/SOFABoot 应用 Ark 包时，应用自动退出？ 因为 SOFAArk 容器不会开启任何非 Daemon 线程，如果是非 Web 应用或者应用启动时不会创建非 Daemon 线程，则应用在执行完 main 方法时，会正常退出。判断 Ark 包是否正常启动，可以观察是否有如下日志出现：\nArk container started in …","date":-62135596800,"description":"","dir":"projects/moss/faq/","fuzzywordcount":2100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c74643cfc0683c3fd5c89d0cc1cc9835","permalink":"/projects/moss/faq/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/moss/faq/","summary":"Q: Readiness Check 有啥应用场景？ Liveness Check 和 Readiness Check 概念来自于 Kuberentes，分别代表运行时检查和启动时检查。Spring Boot 提供了 Liveness Check，但是没有提供","tags":null,"title":"常见问题","type":"projects","url":"/projects/moss/faq/","wordcount":2071},{"author":null,"categories":null,"content":" Q: Readiness Check 有啥应用场景？ Liveness Check 和 Readiness Check 概念来自于 Kuberentes，分别代表运行时检查和启动时检查。Spring Boot 提供了 Liveness Check，但是没有提供 Readiness Check。利用 Readiness Check 的能力，SOFA 中间件中的各个组件只有在 Readiness Check 通过之后，才将流量引入到应用的实例中，比如 RPC，只有在 Readiness Check 通过之后，才会向服务注册中心注册，后面来自上游应用的流量才会进入。除了中间件可以利用 Readiness Check 的事件来控制流量，PAAS 系统也可以通过访问 http://localhost:8080/health/readiness 来获取应用的 Readiness Check 的状况，从而控制例如负载均衡设备等等的流量。\nQ: 是否可以在 SOFABoot 模块中定义 Controller 组件？ SOFABoot 模块一般用于封装对外发布服务接口的具体实现，属于业务层，Controller 属于展现层内容，我们不建议也不支持在 SOFABoot 模块中定义 Controller 组件，Controller 组件相关定义建议直接放在 Root Application Context。\nQ: 类隔离在蚂蚁内部使用是否广泛？ 类隔离在蚂蚁内部使用非常广泛，绝大部分业务应用都是运行在蚂蚁中间件自研的类隔离框架之上。主要是为了解决依赖冲突的问题，像蚂蚁金服这种体量的公司，业务线繁杂、基础服务组件众多，很难做到对所有 JAR 包做统一管控。特别涉及到跨团队模块组件相互依赖时，因为各自技术栈历史包袱的存在，难以有效统一冲突包版本。使用类隔离技术解决了实际开发中的很多痛点，业务开发者不需要担心自身依赖冲突的问题，在多团队协作开发中，也有很大的优势。\nQ: SOFABoot类隔离框架（SOFAArk）和 OSGI 容器有哪些差异？ 作为开源界早负盛名的动态模块系统，基于 OSGi 规范的 Equinox、Felix 等同样具备类隔离能力，然而他们更多强调的是一种编程模型，面向模块化开发，有一整套模块生命周期的管理，定义模块通信机制以及复杂的类加载模型。作为专注于解决依赖冲突的隔离框架，SOFAArk 专注于类隔离，简化了类加载模型，因此显得更加轻量。其次在 OSGi 规范中，所有的模块定义成 Bundle 形式，作为应用开发者，他需要了解 OSGi 背后的工作原理，对开发者要求比较高。在 SOFAArk 中，定义了两层模块类型，Ark Plugin 和 Ark Biz，应用开发者只需要添加隔离的 Ark Plugin 依赖，底层的类加载模型对应用开发者俩说是透明的，基本不会带来额外的学习成本。\nQ: SOFAArk 和 Java9 模块化有哪些差异？ Jigsaw 作为 Java9 模块化方案，抛开内部实现细节，在使用规范上和 OSGi 特别相似：模块的依赖、包导入导出、动态导出、可读性传递、模块服务注册与消费、开放模块、可选模块等等若干概念，相对于 SOFAArk 简单的包导入导出显然过于复杂。在实现细节上，考虑到 JDK 代码的兼容性，Jigsaw 没有采用类加载器隔离的方式，不同模块之间仍然可能是同一个类加载器加载。严格上来讲，Jigsaw 并没有解决同一个类多版本的问题，但是因为模块显示的依赖声明，使用纯 Jigsaw 模块化编程，不同版本类冲突的问题在编译期就能被检查或者启动失败，因为不允许不同模块含有相同类名的包。对于在实际开发中遇到的一类情况，例如两个组件依赖不同版本 hessian 包，即使这两个组件定义成了两个模块，运行时也只有一个hessian版本被加载，依然解决不了不同版本类共存的问题。另外，Jigsaw 相对 Ark 或者 OSGi 有一个明显的缺点，Jigsaw 不允许运行时动态发布模块服务，模块间的通信依赖在 module-info.java 中使用 provides 和 uses 静态注册和引用模块服务。当然，Jigsaw 有很多自己的优点，通过引入module-path，在 module 中显示声明模块依赖关系，避免了传统 maven/gradle 中因为间接依赖导致运行时加载类不确定的缺点；其次通过设置模块包的导入导出配置，可以完全做到接口和实现的分离，提升安全性；另外 Java9 本身借助模块化改造，使用jlink工具，开发者可以将自身应用必须的模块聚合，打包一个自定义的jre镜像。\nQ: 为什么使用 SNAPSHOT 版本拉取不到依赖？ 如果需要使用处于研发状态的 SNAPSHOT 版本，有两种方式：\n 拉取 sofa-ark 仓库代码，本地执行 mvn install。 在本地 maven setting.xml 文件增加如下 profile 配置:  \u0026amp;lt;profile\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;default\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;activation\u0026amp;gt; \u0026amp;lt;activeByDefault\u0026amp;gt;true\u0026amp;lt;/activeByDefault\u0026amp;gt; \u0026amp;lt;/activation\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;maven-snapshot\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://oss.sonatype.org/content/repositories/snapshots\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;/repositories\u0026amp;gt; \u0026amp;lt;pluginRepositories\u0026amp;gt; \u0026amp;lt;pluginRepository\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;maven-snapshot\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://oss.sonatype.org/content/repositories/snapshots\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;/pluginRepository\u0026amp;gt; \u0026amp;lt;/pluginRepositories\u0026amp;gt; \u0026amp;lt;/profile\u0026amp;gt;  Q: 为什么使用 java -jar 启动 Spring Boot/SOFABoot 应用 Ark 包时，应用自动退出？ 因为 SOFAArk 容器不会开启任何非 Daemon 线程，如果是非 Web 应用或者应用启动时不会创建非 Daemon 线程，则应用在执行完 main 方法时，会正常退出。判断 Ark 包是否正常启动，可以观察是否有如下日志出现：\nArk container started in …","date":-62135596800,"description":"","dir":"projects/sofa-boot/faq/","fuzzywordcount":2100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"56f06d32d37d8a5947d7c7ee43d6d955","permalink":"/projects/sofa-boot/faq/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/sofa-boot/faq/","summary":"Q: Readiness Check 有啥应用场景？ Liveness Check 和 Readiness Check 概念来自于 Kuberentes，分别代表运行时检查和启动时检查。Spring Boot 提供了 Liveness Check，但是没有提供","tags":null,"title":"常见问题","type":"projects","url":"/projects/sofa-boot/faq/","wordcount":2071},{"author":null,"categories":null,"content":" 在本文档中，将创建一个 Spring Boot 的工程，引入 SOFABoot 基础依赖，并且引入 SOFABoot 的健康检查扩展能力，演示如何快速上手 SOFABoot。\n环境准备 要使用 SOFABoot，需要先准备好基础环境，SOFABoot 依赖以下环境： - JDK7 或 JDK8 - 需要采用 Apache Maven 3.2.5 或者以上的版本来编译\n创建工程 SOFABoot 是直接构建在 Spring Boot 之上，因此可以使用 Spring Boot 的工程生成工具 来生成，在本文档中，我们需要添加一个 Web 的依赖，以便最后在浏览器中查看效果。\n引入 SOFABoot 在创建好一个 Spring Boot 的工程之后，接下来就需要引入 SOFABoot 的依赖，首先，需要将上文中生成的 Spring Boot 工程的 zip 包解压后，修改 maven 项目的配置文件 pom.xml，将\n\u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-parent\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring.boot.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;relativePath/\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt;  替换为：\n\u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofaboot-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.boot.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt;  这里的 ${sofa.boot.version} 指定具体的 SOFABoot 版本，参考发布历史。 然后，添加 SOFABoot 健康检查扩展能力的依赖及 Web 依赖(方便查看健康检查结果)：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;healthcheck-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-web\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  最后，在工程的 application.properties 文件下添加 SOFABoot 工程常用的参数配置，其中 spring.application.name 是必需的参数，用于标示当前应用的名称；logging path 用于指定日志的输出目录。\n# Application Name spring.application.name=SOFABoot Demo # logging path logging.path=./logs  运行 可以将工程导入到 IDE 中运行生成的工程里面中的 main 方法（一般上在 XXXApplication 这个类中）启动应用，也可以直接在该工程的根目录下运行 mvn spring-boot:run，将会在控制台中看到启动打印的日志：\n2018-04-05 21:36:26.572 INFO ---- Initializing ProtocolHandler [\u0026amp;quot;http-nio-8080\u0026amp;quot;] 2018-04-05 21:36:26.587 INFO ---- Starting ProtocolHandler [http-nio-8080] 2018-04-05 21:36:26.608 INFO ---- Using a shared selector for servlet write/read 2018-04-05 21:36:26.659 INFO ---- Tomcat started on port(s): 8080 (http)  可以通过在浏览器中输入 http://localhost:8080/sofaboot/versions 来查看当前 SOFABoot 中使用 Maven 插件生成的版本信息汇总，结果类似如下：\n[ { GroupId: \u0026amp;quot;com.alipay.sofa\u0026amp;quot;, Doc-Url: \u0026amp;quot;https://github.com/sofastack/sofa-boot\u0026amp;quot;, ArtifactId: \u0026amp;quot;infra-sofa-boot-starter\u0026amp;quot;, Built-Time: \u0026amp;quot;2018-04-05T20:55:26+0800\u0026amp;quot;, Commit-Time: \u0026amp;quot;2018-04-05T20:54:26+0800\u0026amp;quot;, Commit-Id: \u0026amp;quot;049bf890bb468aafe6a3e07b77df45c831076996\u0026amp;quot;, Version: \u0026amp;quot;2.4.4\u0026amp;quot; } ]  注: 在 SOFABoot 3.x 中调整了 endpoint 路径，sofaboot/versions 更改为 actuator/versions\n可以通过在浏览器中输入 http://localhost:8080/health/readiness 查看应用 Readiness Check 的状况，类似如下：\n{ status: \u0026amp;quot;UP\u0026amp;quot;, sofaBootComponentHealthCheckInfo: { status: \u0026amp;quot;UP\u0026amp;quot; }, springContextHealthCheckInfo: { status: \u0026amp;quot;UP\u0026amp;quot; }, DiskSpace: { status: \u0026amp;quot;UP\u0026amp;quot;, total: 250140434432, free: 22845308928, threshold: 10485760 } }  注: 在 SOFABoot 3.x 中调整了 endpoint 路径，health/readiness 更改为 actuator/readiness\nstatus: \u0026amp;quot;UP\u0026amp;quot; 表示应用 Readiness Check 健康的。可以通过在浏览器中输入 http://localhost:8080/health 来查看应用的运行时健康状态（可能会随着时间发生变化）。\n注: 在 SOFABOOT 3.X 中调整了 endpoint 路径，/health 更改 …","date":-62135596800,"description":"","dir":"projects/moss/quick-start/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d6159d57d20b12f3abc066a7c9f2eb5b","permalink":"/projects/moss/quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/moss/quick-start/","summary":"在本文档中，将创建一个 Spring Boot 的工程，引入 SOFABoot 基础依赖，并且引入 SOFABoot 的健康检查扩展能力，演示如何快速上手 SOFABoot。 环境准备 要使用 SOFABo","tags":null,"title":"快速开始","type":"projects","url":"/projects/moss/quick-start/","wordcount":2155},{"author":null,"categories":null,"content":" 在本文档中，将创建一个 Spring Boot 的工程，引入 SOFABoot 基础依赖，并且引入 SOFABoot 的健康检查扩展能力，演示如何快速上手 SOFABoot。\n环境准备 要使用 SOFABoot，需要先准备好基础环境，SOFABoot 依赖以下环境： - JDK7 或 JDK8 - 需要采用 Apache Maven 3.2.5 或者以上的版本来编译\n创建工程 SOFABoot 是直接构建在 Spring Boot 之上，因此可以使用 Spring Boot 的工程生成工具 来生成，在本文档中，我们需要添加一个 Web 的依赖，以便最后在浏览器中查看效果。\n引入 SOFABoot 在创建好一个 Spring Boot 的工程之后，接下来就需要引入 SOFABoot 的依赖，首先，需要将上文中生成的 Spring Boot 工程的 zip 包解压后，修改 maven 项目的配置文件 pom.xml，将\n\u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-parent\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring.boot.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;relativePath/\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt;  替换为：\n\u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofaboot-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.boot.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt;  这里的 ${sofa.boot.version} 指定具体的 SOFABoot 版本，参考发布历史。 然后，添加 SOFABoot 健康检查扩展能力的依赖及 Web 依赖(方便查看健康检查结果)：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;healthcheck-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-web\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  最后，在工程的 application.properties 文件下添加 SOFABoot 工程常用的参数配置，其中 spring.application.name 是必需的参数，用于标示当前应用的名称；logging path 用于指定日志的输出目录。\n# Application Name spring.application.name=SOFABoot Demo # logging path logging.path=./logs  运行 可以将工程导入到 IDE 中运行生成的工程里面中的 main 方法（一般上在 XXXApplication 这个类中）启动应用，也可以直接在该工程的根目录下运行 mvn spring-boot:run，将会在控制台中看到启动打印的日志：\n2018-04-05 21:36:26.572 INFO ---- Initializing ProtocolHandler [\u0026amp;quot;http-nio-8080\u0026amp;quot;] 2018-04-05 21:36:26.587 INFO ---- Starting ProtocolHandler [http-nio-8080] 2018-04-05 21:36:26.608 INFO ---- Using a shared selector for servlet write/read 2018-04-05 21:36:26.659 INFO ---- Tomcat started on port(s): 8080 (http)  可以通过在浏览器中输入 http://localhost:8080/sofaboot/versions 来查看当前 SOFABoot 中使用 Maven 插件生成的版本信息汇总，结果类似如下：\n[ { GroupId: \u0026amp;quot;com.alipay.sofa\u0026amp;quot;, Doc-Url: \u0026amp;quot;https://github.com/sofastack/sofa-boot\u0026amp;quot;, ArtifactId: \u0026amp;quot;infra-sofa-boot-starter\u0026amp;quot;, Built-Time: \u0026amp;quot;2018-04-05T20:55:26+0800\u0026amp;quot;, Commit-Time: \u0026amp;quot;2018-04-05T20:54:26+0800\u0026amp;quot;, Commit-Id: \u0026amp;quot;049bf890bb468aafe6a3e07b77df45c831076996\u0026amp;quot;, Version: \u0026amp;quot;2.4.4\u0026amp;quot; } ]  注: 在 SOFABoot 3.x 中调整了 endpoint 路径，sofaboot/versions 更改为 actuator/versions\n可以通过在浏览器中输入 http://localhost:8080/health/readiness 查看应用 Readiness Check 的状况，类似如下：\n{ status: \u0026amp;quot;UP\u0026amp;quot;, sofaBootComponentHealthCheckInfo: { status: \u0026amp;quot;UP\u0026amp;quot; }, springContextHealthCheckInfo: { status: \u0026amp;quot;UP\u0026amp;quot; }, DiskSpace: { status: \u0026amp;quot;UP\u0026amp;quot;, total: 250140434432, free: 22845308928, threshold: 10485760 } }  注: 在 SOFABoot 3.x 中调整了 endpoint 路径，health/readiness 更改为 actuator/readiness\nstatus: \u0026amp;quot;UP\u0026amp;quot; 表示应用 Readiness Check 健康的。可以通过在浏览器中输入 http://localhost:8080/health 来查看应用的运行时健康状态（可能会随着时间发生变化）。\n注: 在 SOFABOOT 3.X 中调整了 endpoint 路径，/health 更改 …","date":-62135596800,"description":"","dir":"projects/sofa-boot/quick-start/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7f582b905fde4a56791c03d4dd6b5a57","permalink":"/projects/sofa-boot/quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/sofa-boot/quick-start/","summary":"在本文档中，将创建一个 Spring Boot 的工程，引入 SOFABoot 基础依赖，并且引入 SOFABoot 的健康检查扩展能力，演示如何快速上手 SOFABoot。 环境准备 要使用 SOFABo","tags":null,"title":"快速开始","type":"projects","url":"/projects/sofa-boot/quick-start/","wordcount":2155},{"author":null,"categories":null,"content":" SOFABoot 从 2.4.0 版本开始支持基于 Spring 上下文隔离的模块化开发能力。为了更好的理解 SOFABoot 模块化开发的概念，我们来区分几个常见的模块化形式：\n 基于代码组织上的模块化：这是最常见的形式，在开发期，将不同功能的代码放在不同 Java 工程下，在编译期被打进不同 jar 包，在运行期，所有 Java 类都在一个 classpath 下，没做任何隔离； 基于 Spring 上下文隔离的模块化：借用 Spring 上下文来做不同功能模块的隔离，在开发期和编译期，代码和配置也会分在不同 Java 工程中，但在运行期，不同模块间的 Spring Bean 相互不可见，DI 只在同一个上下文内部发生，但是所有的 Java 类还是在同一个 ClassLoader 下； 基于 ClassLoader 隔离的模块化：借用 ClassLoader 来做隔离，每个模块都有独立的 ClassLoader，模块与模块之间的 classpath 不同，SOFAArk 就是这种模块化的实践方式。  SOFABoot 模块化开发属于第二种模块化形式 —— 基于 Spring 上下文隔离的模块化。每个 SOFABoot 模块使用独立的 Spring 上下文，避免不同 SOFABoot 模块间的 BeanId 冲突，有效降低企业级多模块开发时团队间的沟通成本。\n关于 SOFABoot 模块化产生的背景，可参考文章《蚂蚁金服的业务系统模块化 \u0026amp;mdash;- 模块化隔离方案》\n功能简介 依赖引入 使用 SOFABoot 模块化开发方案，需要引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;isle-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  SOFABoot 模块 SOFABoot 框架定义了 SOFABoot 模块的概念，一个 SOFABoot 模块是一个包括 Java 代码、Spring 配置文件、SOFABoot 模块标识等信息的普通 Jar 包，一个 SOFABoot 应用可以包含多个 SOFABoot 模块，每个 SOFABoot 模块都含有独立的 Spring 上下文。\n以 SOFABoot 模块为单元的模块化方式为开发者提供了以下功能：\n 运行时，每个 SOFABoot 模块的 Spring 上下文是隔离的，模块间定义的 Bean 不会相互影响； 每个 SOFABoot 模块是功能完备且自包含的，可以很容易在不同的 SOFABoot 应用中进行模块迁移和复用，只需将 SOFABoot 模块整个拷贝过去，调整 Maven 依赖，即可运行。  SOFABoot 模块的格式定义见: 模块配置。\nSOFABoot 模块间通信 上下文隔离后，模块与模块间的 Bean 无法直接注入，模块间需要通过 SOFA 服务进行通信，目前SOFABoot 提供了两种形式的服务发布和引用，用于解决不同级别的模块间调用的问题：\n JVM 服务发布和引用：解决一个 SOFABoot 应用内部各个 SOFABoot 模块之间的调用问题， JVM 服务发布与引用 RPC 服务发布和引用：解决多个 SOFABoot 应用之间的远程调用问题，RPC 服务发布与引用。  模块并行化启动 每个 SOFABoot 模块都是独立的 Spring 上下文，多个 SOFABoot 模块支持并行化启动，与 Spring Boot 的单 Spring 上下文模式相比，模块并行化启动能够加快应用的启动速度。\nRoot Application Context SOFABoot 应用运行时，本身会产生一个 Spring Context，我们把它叫做 Root Application Context，它是每个 SOFABoot 模块创建的 Spring Context 的 Parent。这样设计的目的是为了保证每个 SOFABoot 模块的 Spring Context 都能发现 Root Application Context 中创建的 Bean，这样当应用新增 Starter 时，不仅 Root Application Context 能够使用 Starter 中新增的 Bean，每个 SOFABoot 模块的 Spring Context 也能使用这些 Bean。\n","date":-62135596800,"description":"","dir":"projects/moss/modular-development/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"79c6cee056d2f42bfd76907c4e442bdf","permalink":"/projects/moss/modular-development/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/modular-development/","summary":"SOFABoot 从 2.4.0 版本开始支持基于 Spring 上下文隔离的模块化开发能力。为了更好的理解 SOFABoot 模块化开发的概念，我们来区分几个常见的模块化形式： 基于代码组织上的模块化","tags":null,"title":"模块化开发概述","type":"projects","url":"/projects/moss/modular-development/","wordcount":1073},{"author":null,"categories":null,"content":" SOFABoot 从 2.4.0 版本开始支持基于 Spring 上下文隔离的模块化开发能力。为了更好的理解 SOFABoot 模块化开发的概念，我们来区分几个常见的模块化形式：\n 基于代码组织上的模块化：这是最常见的形式，在开发期，将不同功能的代码放在不同 Java 工程下，在编译期被打进不同 jar 包，在运行期，所有 Java 类都在一个 classpath 下，没做任何隔离； 基于 Spring 上下文隔离的模块化：借用 Spring 上下文来做不同功能模块的隔离，在开发期和编译期，代码和配置也会分在不同 Java 工程中，但在运行期，不同模块间的 Spring Bean 相互不可见，DI 只在同一个上下文内部发生，但是所有的 Java 类还是在同一个 ClassLoader 下； 基于 ClassLoader 隔离的模块化：借用 ClassLoader 来做隔离，每个模块都有独立的 ClassLoader，模块与模块之间的 classpath 不同，SOFAArk 就是这种模块化的实践方式。  SOFABoot 模块化开发属于第二种模块化形式 —— 基于 Spring 上下文隔离的模块化。每个 SOFABoot 模块使用独立的 Spring 上下文，避免不同 SOFABoot 模块间的 BeanId 冲突，有效降低企业级多模块开发时团队间的沟通成本。\n关于 SOFABoot 模块化产生的背景，可参考文章《蚂蚁金服的业务系统模块化 \u0026amp;mdash;- 模块化隔离方案》\n功能简介 依赖引入 使用 SOFABoot 模块化开发方案，需要引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;isle-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  SOFABoot 模块 SOFABoot 框架定义了 SOFABoot 模块的概念，一个 SOFABoot 模块是一个包括 Java 代码、Spring 配置文件、SOFABoot 模块标识等信息的普通 Jar 包，一个 SOFABoot 应用可以包含多个 SOFABoot 模块，每个 SOFABoot 模块都含有独立的 Spring 上下文。\n以 SOFABoot 模块为单元的模块化方式为开发者提供了以下功能：\n 运行时，每个 SOFABoot 模块的 Spring 上下文是隔离的，模块间定义的 Bean 不会相互影响； 每个 SOFABoot 模块是功能完备且自包含的，可以很容易在不同的 SOFABoot 应用中进行模块迁移和复用，只需将 SOFABoot 模块整个拷贝过去，调整 Maven 依赖，即可运行。  SOFABoot 模块的格式定义见: 模块配置。\nSOFABoot 模块间通信 上下文隔离后，模块与模块间的 Bean 无法直接注入，模块间需要通过 SOFA 服务进行通信，目前SOFABoot 提供了两种形式的服务发布和引用，用于解决不同级别的模块间调用的问题：\n JVM 服务发布和引用：解决一个 SOFABoot 应用内部各个 SOFABoot 模块之间的调用问题， JVM 服务发布与引用 RPC 服务发布和引用：解决多个 SOFABoot 应用之间的远程调用问题，RPC 服务发布与引用。  模块并行化启动 每个 SOFABoot 模块都是独立的 Spring 上下文，多个 SOFABoot 模块支持并行化启动，与 Spring Boot 的单 Spring 上下文模式相比，模块并行化启动能够加快应用的启动速度。\nRoot Application Context SOFABoot 应用运行时，本身会产生一个 Spring Context，我们把它叫做 Root Application Context，它是每个 SOFABoot 模块创建的 Spring Context 的 Parent。这样设计的目的是为了保证每个 SOFABoot 模块的 Spring Context 都能发现 Root Application Context 中创建的 Bean，这样当应用新增 Starter 时，不仅 Root Application Context 能够使用 Starter 中新增的 Bean，每个 SOFABoot 模块的 Spring Context 也能使用这些 Bean。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/modular-development/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"95bc080787c3614bfa485d2f3cd0de4c","permalink":"/projects/sofa-boot/modular-development/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/modular-development/","summary":"SOFABoot 从 2.4.0 版本开始支持基于 Spring 上下文隔离的模块化开发能力。为了更好的理解 SOFABoot 模块化开发的概念，我们来区分几个常见的模块化形式： 基于代码组织上的模块化","tags":null,"title":"模块化开发概述","type":"projects","url":"/projects/sofa-boot/modular-development/","wordcount":1073},{"author":null,"categories":null,"content":"SOFABoot 会根据 Require-Module 计算模块依赖树，例如以下依赖树表示模块B 和模块C 依赖模块A，模块E 依赖模块D，模块F 依赖模块E：\n该依赖树会保证模块A 必定在模块B 和模块C 之前启动，模块D 在模块E 之前启动，模块E 在模块F 之前启动，但是依赖树没有定义模块B 与模块C，模块B、C与模块D、E、F之间的启动顺序，这几个模块之间可以串行启动，也可以并行启动。\nSOFABoot 默认会并行启动模块，在使用过程中，如果希望关闭并行启动，可以在 application.properties 中增加以下参数:\ncom.alipay.sofa.boot.module-start-up-parallel=false  ","date":-62135596800,"description":"","dir":"projects/moss/parallel-start/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"387f9339745e5736484549a33c502f6a","permalink":"/projects/moss/parallel-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/moss/parallel-start/","summary":"SOFABoot 会根据 Require-Module 计算模块依赖树，例如以下依赖树表示模块B 和模块C 依赖模块A，模块E 依赖模块D，模块F 依赖模块E： 该依赖树会保证模块A 必定在模块B 和","tags":null,"title":"模块并行化启动","type":"projects","url":"/projects/moss/parallel-start/","wordcount":204},{"author":null,"categories":null,"content":"SOFABoot 会根据 Require-Module 计算模块依赖树，例如以下依赖树表示模块B 和模块C 依赖模块A，模块E 依赖模块D，模块F 依赖模块E：\n该依赖树会保证模块A 必定在模块B 和模块C 之前启动，模块D 在模块E 之前启动，模块E 在模块F 之前启动，但是依赖树没有定义模块B 与模块C，模块B、C与模块D、E、F之间的启动顺序，这几个模块之间可以串行启动，也可以并行启动。\nSOFABoot 默认会并行启动模块，在使用过程中，如果希望关闭并行启动，可以在 application.properties 中增加以下参数:\ncom.alipay.sofa.boot.module-start-up-parallel=false  ","date":-62135596800,"description":"","dir":"projects/sofa-boot/parallel-start/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a6ef51b78d2a4f9af0debbc25ea45e8a","permalink":"/projects/sofa-boot/parallel-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-boot/parallel-start/","summary":"SOFABoot 会根据 Require-Module 计算模块依赖树，例如以下依赖树表示模块B 和模块C 依赖模块A，模块E 依赖模块D，模块F 依赖模块E： 该依赖树会保证模块A 必定在模块B 和","tags":null,"title":"模块并行化启动","type":"projects","url":"/projects/sofa-boot/parallel-start/","wordcount":204},{"author":null,"categories":null,"content":" SOFABoot 模块是一个普通的 Jar 包加上一些 SOFABoot 特有的配置，这些 SOFABoot 特有的配置，让一个 Jar 包能够被 SOFABoot 识别，使之具备模块化的能力。\n一个完整的 SOFABoot 模块和一个普通的 Jar 包有两点区别:\n SOFABoot 模块包含一份 sofa-module.properties 文件，这份文件里面定义了 SOFABoot 模块的名称以及模块之间的依赖关系。 SOFABoot 模块的 META-INF/spring 目录下，可以放置任意多的 Spring 配置文件，SOFABoot 会自动把它们作为本模块的 Spring 配置加载起来。  sofa-module.properties 文件详解 先来看一份完整的 sofa-module.properties 文件：\nModule-Name=com.alipay.test.biz.service.impl Spring-Parent=com.alipay.test.common.dal Require-Module=com.alipay.test.biz.shared Module-Profile=dev  Module-Name Module-Name 是 SOFABoot 模块的名称，也是 SOFABoot 模块的唯一标示符。在一个 SOFABoot 应用中，一个 SOFABoot 模块的 Module-Name 必须和其他的 SOFABoot 模块的 Module-Name 不一样。需要注意的一点是，一个 SOFABoot 应用运行时的 SOFABoot 模块，不仅仅只包含本应用的模块，还包括依赖了其他应用的 SOFABoot 模块，确定是否唯一的时候需要把这些 SOFABoot 模块也考虑进去。\nRequire-Module Require-Module 用于定义模块之间的依赖顺序，值是以逗号分隔的 SOFABoot 模块名列表，比如上面的配置中，就表示本模块依赖于 com.alipay.test.biz.shared 模块。对于这种依赖关系的处理，SOFABoot 会将 com.alipay.test.biz.shared 模块在本模块之前启动，即com.alipay.test.biz.shared 模块将先启动 Spring 上下文。\n一般情况下，是不需要为模块定义 Require-Module 的，只有当模块的 Spring 上下文的启动依赖于另一个模块的 Spring 上下文的启动时，才需要定义 Require-Module。举一个例子，如果你在 A 模块中发布了一个 SOFA JVM Service。在 B 模块的某一个 Bean 的 init 方法里面，需要使用 SOFA Reference 调用这个 JVM Service。假设 B 模块在 A 模块之前启动了，那么 B 模块的 Bean 就会因为 A 模块的 JVM Service 没有发布而 init 失败，导致 Spring 上下文启动失败。这个时候，我们就可以使用 Require-Module 来强制 A 模块在 B 模块之前启动。\nSpring-Parent 在 SOFABoot 应用中，每一个 SOFABoot 模块都是一个独立的 Spring 上下文，并且这些 Spring 上下文之间是相互隔离的。虽然这样的模块化方式可以带来诸多好处，但是，在某些场景下还是会有一些不便，这个时候，你可以通过 Spring-Parent 来打通两个 SOFABoot 模块的 Spring 上下文。Spring-Parent 属性可以配置一个模块的名称，比如上面的配置中，就将 com.alipay.test.common.dal 的 Spring 上下文设置为当前模块的 Spring 上下文的父 Spring 上下文。\n由于 Spring 的限制，一个模块的 Spring-Parent 只能有一个模块\n关于 Spring 的父上下文的作用可以看 Spring 的 BeanFactory 的说明：http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html\nModule-Profile 支持 SOFABoot Profile 能力： SOFABoot Profile\nSpring 配置文件 SOFABoot 模块可以包含 Spring 配置文件，配置文件需要放置在 META-INF/spring 目录下，SOFABoot 启动时会自动扫描该目录，并把目录下所有 XML 文件作为本模块的 Spring 配置加载起来。在 Spring 配置文件中，我们可以定义 Bean、发布服务等等。\nSOFABoot 模块一般用于封装对外发布服务接口的具体实现，属于业务层，Controller 属于展现层内容，我们不建议也不支持在 SOFABoot 模块中定义 Controller 组件，Controller 组件相关定义请直接放在 Root Application Context。\n","date":-62135596800,"description":"","dir":"projects/moss/sofaboot-module/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"506a1cba16f99850bbdb2c622ff5ee53","permalink":"/projects/moss/sofaboot-module/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/moss/sofaboot-module/","summary":"SOFABoot 模块是一个普通的 Jar 包加上一些 SOFABoot 特有的配置，这些 SOFABoot 特有的配置，让一个 Jar 包能够被 SOFABoot 识别，使之具备模块化的能力。 一个完整的 SOFABoot 模块和一个普通的 Jar 包","tags":null,"title":"模块配置","type":"projects","url":"/projects/moss/sofaboot-module/","wordcount":1171},{"author":null,"categories":null,"content":" SOFABoot 模块是一个普通的 Jar 包加上一些 SOFABoot 特有的配置，这些 SOFABoot 特有的配置，让一个 Jar 包能够被 SOFABoot 识别，使之具备模块化的能力。\n一个完整的 SOFABoot 模块和一个普通的 Jar 包有两点区别:\n SOFABoot 模块包含一份 sofa-module.properties 文件，这份文件里面定义了 SOFABoot 模块的名称以及模块之间的依赖关系。 SOFABoot 模块的 META-INF/spring 目录下，可以放置任意多的 Spring 配置文件，SOFABoot 会自动把它们作为本模块的 Spring 配置加载起来。  sofa-module.properties 文件详解 先来看一份完整的 sofa-module.properties 文件：\nModule-Name=com.alipay.test.biz.service.impl Spring-Parent=com.alipay.test.common.dal Require-Module=com.alipay.test.biz.shared Module-Profile=dev  Module-Name Module-Name 是 SOFABoot 模块的名称，也是 SOFABoot 模块的唯一标示符。在一个 SOFABoot 应用中，一个 SOFABoot 模块的 Module-Name 必须和其他的 SOFABoot 模块的 Module-Name 不一样。需要注意的一点是，一个 SOFABoot 应用运行时的 SOFABoot 模块，不仅仅只包含本应用的模块，还包括依赖了其他应用的 SOFABoot 模块，确定是否唯一的时候需要把这些 SOFABoot 模块也考虑进去。\nRequire-Module Require-Module 用于定义模块之间的依赖顺序，值是以逗号分隔的 SOFABoot 模块名列表，比如上面的配置中，就表示本模块依赖于 com.alipay.test.biz.shared 模块。对于这种依赖关系的处理，SOFABoot 会将 com.alipay.test.biz.shared 模块在本模块之前启动，即com.alipay.test.biz.shared 模块将先启动 Spring 上下文。\n一般情况下，是不需要为模块定义 Require-Module 的，只有当模块的 Spring 上下文的启动依赖于另一个模块的 Spring 上下文的启动时，才需要定义 Require-Module。举一个例子，如果你在 A 模块中发布了一个 SOFA JVM Service。在 B 模块的某一个 Bean 的 init 方法里面，需要使用 SOFA Reference 调用这个 JVM Service。假设 B 模块在 A 模块之前启动了，那么 B 模块的 Bean 就会因为 A 模块的 JVM Service 没有发布而 init 失败，导致 Spring 上下文启动失败。这个时候，我们就可以使用 Require-Module 来强制 A 模块在 B 模块之前启动。\nSpring-Parent 在 SOFABoot 应用中，每一个 SOFABoot 模块都是一个独立的 Spring 上下文，并且这些 Spring 上下文之间是相互隔离的。虽然这样的模块化方式可以带来诸多好处，但是，在某些场景下还是会有一些不便，这个时候，你可以通过 Spring-Parent 来打通两个 SOFABoot 模块的 Spring 上下文。Spring-Parent 属性可以配置一个模块的名称，比如上面的配置中，就将 com.alipay.test.common.dal 的 Spring 上下文设置为当前模块的 Spring 上下文的父 Spring 上下文。\n由于 Spring 的限制，一个模块的 Spring-Parent 只能有一个模块\n关于 Spring 的父上下文的作用可以看 Spring 的 BeanFactory 的说明：http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html\nModule-Profile 支持 SOFABoot Profile 能力： SOFABoot Profile\nSpring 配置文件 SOFABoot 模块可以包含 Spring 配置文件，配置文件需要放置在 META-INF/spring 目录下，SOFABoot 启动时会自动扫描该目录，并把目录下所有 XML 文件作为本模块的 Spring 配置加载起来。在 Spring 配置文件中，我们可以定义 Bean、发布服务等等。\nSOFABoot 模块一般用于封装对外发布服务接口的具体实现，属于业务层，Controller 属于展现层内容，我们不建议也不支持在 SOFABoot 模块中定义 Controller 组件，Controller 组件相关定义请直接放在 Root Application Context。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/sofaboot-module/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2dbb8a536237f21afbee1e3f320b8193","permalink":"/projects/sofa-boot/sofaboot-module/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/sofa-boot/sofaboot-module/","summary":"SOFABoot 模块是一个普通的 Jar 包加上一些 SOFABoot 特有的配置，这些 SOFABoot 特有的配置，让一个 Jar 包能够被 SOFABoot 识别，使之具备模块化的能力。 一个完整的 SOFABoot 模块和一个普通的 Jar 包","tags":null,"title":"模块配置","type":"projects","url":"/projects/sofa-boot/sofaboot-module/","wordcount":1171},{"author":null,"categories":null,"content":" 通过 SOFABoot，我们可以直接在浏览器中就可以查看 SOFA 中间件的版本等详细信息。\n引入 SOFABoot Infra 依赖 要在 SOFABoot 中直接通过浏览器查看 SOFA 中间件的版本信息，只需要在 Maven 依赖中增加如下的内容即可：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;infra-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  版本信息查看 在应用启动成功后，可以在浏览器中输入 http://localhost:8080/sofaboot/versions 查看 SOFA 中间件的版本信息，如：\n[ { GroupId: \u0026amp;quot;com.alipay.sofa\u0026amp;quot;, Doc-Url: \u0026amp;quot;https://github.com/sofastack/sofa-boot\u0026amp;quot;, ArtifactId: \u0026amp;quot;infra-sofa-boot-starter\u0026amp;quot;, Built-Time: \u0026amp;quot;2018-04-05T20:55:22+0800\u0026amp;quot;, Commit-Time: \u0026amp;quot;2018-04-05T20:54:26+0800\u0026amp;quot;, Commit-Id: \u0026amp;quot;049bf890bb468aafe6a3e07b77df45c831076996\u0026amp;quot;, Version: \u0026amp;quot;2.4.0\u0026amp;quot; } ]  注: 在 SOFABoot 3.x 中调整了 endpoint 路径，sofaboot/versions 更改为 actuator/versions\n","date":-62135596800,"description":"","dir":"projects/moss/view-versions/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e2c8d88bba8f4f7d891a01c2bd75e358","permalink":"/projects/moss/view-versions/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/moss/view-versions/","summary":"通过 SOFABoot，我们可以直接在浏览器中就可以查看 SOFA 中间件的版本等详细信息。 引入 SOFABoot Infra 依赖 要在 SOFABoot 中直接通过浏览器查看 SOFA 中间件的版本信息，只","tags":null,"title":"版本查看","type":"projects","url":"/projects/moss/view-versions/","wordcount":182},{"author":null,"categories":null,"content":" 通过 SOFABoot，我们可以直接在浏览器中就可以查看 SOFA 中间件的版本等详细信息。\n引入 SOFABoot Infra 依赖 要在 SOFABoot 中直接通过浏览器查看 SOFA 中间件的版本信息，只需要在 Maven 依赖中增加如下的内容即可：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;infra-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  版本信息查看 在应用启动成功后，可以在浏览器中输入 http://localhost:8080/sofaboot/versions 查看 SOFA 中间件的版本信息，如：\n[ { GroupId: \u0026amp;quot;com.alipay.sofa\u0026amp;quot;, Doc-Url: \u0026amp;quot;https://github.com/sofastack/sofa-boot\u0026amp;quot;, ArtifactId: \u0026amp;quot;infra-sofa-boot-starter\u0026amp;quot;, Built-Time: \u0026amp;quot;2018-04-05T20:55:22+0800\u0026amp;quot;, Commit-Time: \u0026amp;quot;2018-04-05T20:54:26+0800\u0026amp;quot;, Commit-Id: \u0026amp;quot;049bf890bb468aafe6a3e07b77df45c831076996\u0026amp;quot;, Version: \u0026amp;quot;2.4.0\u0026amp;quot; } ]  注: 在 SOFABoot 3.x 中调整了 endpoint 路径，sofaboot/versions 更改为 actuator/versions\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/view-versions/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c6b6d22e9038aa1f5e4ce74449ba1cda","permalink":"/projects/sofa-boot/view-versions/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-boot/view-versions/","summary":"通过 SOFABoot，我们可以直接在浏览器中就可以查看 SOFA 中间件的版本等详细信息。 引入 SOFABoot Infra 依赖 要在 SOFABoot 中直接通过浏览器查看 SOFA 中间件的版本信息，只","tags":null,"title":"版本查看","type":"projects","url":"/projects/sofa-boot/view-versions/","wordcount":182},{"author":null,"categories":null,"content":"SOFABoot 使用了一些三方开源组件，他们分别是：\n一些主要依赖：\n Spring under Apache 2.0 license Spring Boot under Apache 2.0 license SLF4j under the MIT License sofa-common-tools under Apache 2.0 license  一些扩展依赖：\n nuxeo under Apache License, Version 2.0  \u0026amp;hellip; 其它整理中。\n","date":-62135596800,"description":"","dir":"projects/moss/notice/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"51778cde820df2aa09130d15588abf42","permalink":"/projects/moss/notice/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/moss/notice/","summary":"SOFABoot 使用了一些三方开源组件，他们分别是： 一些主要依赖： Spring under Apache 2.0 license Spring Boot under Apache 2.0 license SLF4j under the MIT License sofa-common-tools under Apache 2.0 license 一些扩展依赖： nuxeo under Apache License, Version 2.0 \u0026hellip; 其它整理中。","tags":null,"title":"版权声明","type":"projects","url":"/projects/moss/notice/","wordcount":67},{"author":null,"categories":null,"content":"SOFABoot 使用了一些三方开源组件，他们分别是：\n一些主要依赖：\n Spring under Apache 2.0 license Spring Boot under Apache 2.0 license SLF4j under the MIT License sofa-common-tools under Apache 2.0 license  一些扩展依赖：\n nuxeo under Apache License, Version 2.0  \u0026amp;hellip; 其它整理中。\n","date":-62135596800,"description":"","dir":"projects/sofa-boot/notice/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"11f073a7a9965ab5690ed166fe319bbd","permalink":"/projects/sofa-boot/notice/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/sofa-boot/notice/","summary":"SOFABoot 使用了一些三方开源组件，他们分别是： 一些主要依赖： Spring under Apache 2.0 license Spring Boot under Apache 2.0 license SLF4j under the MIT License sofa-common-tools under Apache 2.0 license 一些扩展依赖： nuxeo under Apache License, Version 2.0 \u0026hellip; 其它整理中。","tags":null,"title":"版权声明","type":"projects","url":"/projects/sofa-boot/notice/","wordcount":67}]